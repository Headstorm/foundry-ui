{"version":3,"file":"main.14d963ba.iframe.bundle.js","mappings":";;;;AAoBA;;AAKA;;;;;;;;ACWA;;;;;;;ACPA;ACkBA;AAcA;;;;;;;;AAQA;AAGA;AACA;AAGA;ACnDA;AASA;;;ACmFA;;;;;AAOA;;AAIA;;;;ACxGA;;AAGA;;AAUA;;;;;;ACAA;;;;;;;;;ACFA;ACZA;;;;;;;;AAUA;AACA;;;;;;;;;;;AAaA;;AAaA;;;AAGA;AASA;;;;;AC7CA;;;AAKA;;;;;;AAQA;;;AAKA;;;AAKA;;;AC7BA;;AAGA;;AAGA;;;AAKA;;;;AAMA;;;AAKA;;;;;;;ACMA;;;;;AAOA;ACbA;AAwBA;AACA;AASA;AACA;AAMA;ACQA;AA0DA;;AAIA;;;;;;AAQA;;AAIA;AACA;AAKA;AACA;AAKA;AC3JA;AAmCA;AACA;AAYA;;AAIA;AACA;AAUA;AACA;AAiBA;;;;;;AAoCA;;;;;;;;;;;AC7GA;AACA;AAaA;AACA;AA6BA;AACA;AAcA;;;;AAMA;AACA;AAQA;AACA;AAQA;AACA;AAQA;AACA;AAuCA;AC1JA;AAWA;;;;;AAoBA;ACIA;AAaA;AACA;AA4BA;;;;AAMA;;;;AAMA;;;AAKA;AACA;AAiCA;AACA;AAUA;AACA;AAiCA;AACA;AAcA;;;AAKA;AACA;AAwBA;;;AAOA;AACA;AAiGA;;AC7TA;;;;;AAwBA;AC7BA;AAYA;;;AAmCA;;;;;;;;;;;ACxBA;;;;;;;AAUA;AAGA;AA0EA;;;AC9GA;AACA;AAKA;AACA;;;;;;;;;;;;;;AAcA;;;AAKA;ACXA;AA6CA;AACA;AAyBA;AACA;AAiBA;AACA;AAgBA;AACA;AAYA;AACA;AAYA;AACA;AAcA;AACA;AAYA;;;AC5KA;AACA;AAGA;AACA;AAIA;;;;AAIA;AACA;AACA;;;;;;;;;;;;;;;;;AAiBA;;AAKA;AACA;AAuCA;;;;;;;;;;AC3DA;;;AAKA;;;;;;;;;;;AAaA;;ACjBA;AACA;AAGA;AACA;;;;;;AASA;AACA;;AAIA;;AAEA;;;AAGA;;;AAMA;AACA;;;;;;;;;AASA;;;;;;AAQA;AACA;;AAIA;;AAEA;;;AAGA;AACA;;AAKA;;;;;;;;;;;AAaA;AACA;;;;AAMA;;;;;;;AAOA;;AAKA;AACA;;AAIA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;AACA;AAQA;;;;;;AASA;AACA;;;;;AAYA;;AAEA;;;AAMA;;;AAOA;AC/JA;AA0BA;;;;;AAOA;AACA;AAQA;ACrFA;AA2BA;;AAIA;AACA;AAWA;ACpBA;AAkCA;AACA;AAaA;AACA;AAeA;;;AAKA;AACA;AAaA;AACA;;AAIA;;AAEA;;AAKA;AACA;;;AAKA;;;AA6CA;;;;;;;;;;;ACnJA;AACA;AAsCA;AACA;AAgDA;ACsCA;AAKA","sources":["webpack://@headstorm/foundry-react-ui/./src/components/Appendix/Appendix.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Avatar/Avatar.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Button/Button.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Card/Card.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Divider/Divider.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Examples/Form.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Examples/GlobalStyles.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/InteractionFeedback/InteractionFeedback.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Modal/Modal.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/RangeSlider/RangeSlider.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Skeleton/Skeleton.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Spotlight/Spotlight.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Table/Table.stories.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Avatar/Avatar.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Button/Button.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Card/Card.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Checkbox/Checkbox.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Divider/Divider.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Dropdown/Dropdown.tsx","webpack://@headstorm/foundry-react-ui/./src/components/InteractionFeedback/InteractionFeedback.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Label/Label.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Modal/Modal.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Progress/Progress.tsx","webpack://@headstorm/foundry-react-ui/./src/components/RangeSlider/RangeSlider.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Skeleton/Skeleton.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Spotlight/Spotlight.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Table/Table.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Tag/Tag.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Text/Text.tsx","webpack://@headstorm/foundry-react-ui/./src/components/TextInput/TextInput.tsx","webpack://@headstorm/foundry-react-ui/./src/components/Toggle/Toggle.tsx","webpack://@headstorm/foundry-react-ui/./src/context/index.tsx"],"sourcesContent":["\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from 'react';\\nimport styled from 'styled-components';\\n\\nimport { Story, Meta } from '@storybook/react';\\n\\nimport { StyledBaseDiv } from '../../htmlElements';\\n\\nconst DocContainer = styled(StyledBaseDiv)`\\n  justify-self: flex-start;\\n  padding: 2rem;\\n  max-width: 60rem;\\n`;\\nconst FullWidthImage = styled.img`\\n  width: 100%;\\n`;\\n\\n// TODO: Turn these images into html\\nexport const Appendix: Story = () => {\\n  return (\\n    <DocContainer>\\n      <h1>Welcome to Headstorm UI</h1>\\n      <p>\\n        Headstorm UI is a component library which is in it for the long haul. Unlike other bootstrap\\n        libraries, it lets you fully customize and theme every piece of it through a\\n        straight-forward API, which means you won't have to rip out your components and rewrite them\\n        once your app is out of the \\\"POC\\\" phase.\\n      </p>\\n      <p>\\n        The components you used in the hackathon will be the same ones you use when you're a fortune\\n        500 megacorp.\\n      </p>\\n      <FullWidthImage\\n        src={`${process.env.PUBLIC_URL}/images/ThemingExample.png`}\\n        alt=\\\"Theming Example\\\"\\n      />\\n      <FullWidthImage\\n        src={`${process.env.PUBLIC_URL}/images/ThemeExampleCode.png`}\\n        alt=\\\"Theming Example Code\\\"\\n      />\\n    </DocContainer>\\n  );\\n};\\n\\nexport default {\\n  title: 'Appendix',\\n  parameters: { controls: { hideNoControlsWarning: true } },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Appendix\":{\"startLoc\":{\"col\":31,\"line\":18},\"endLoc\":{\"col\":1,\"line\":42},\"startBody\":{\"col\":31,\"line\":18},\"endBody\":{\"col\":1,\"line\":42}}};\n    \nimport React from 'react';\nimport styled from 'styled-components';\n\nimport { Story, Meta } from '@storybook/react';\n\nimport { StyledBaseDiv } from '../../htmlElements';\n\nconst DocContainer = styled(StyledBaseDiv)`\n  justify-self: flex-start;\n  padding: 2rem;\n  max-width: 60rem;\n`;\nconst FullWidthImage = styled.img`\n  width: 100%;\n`;\n\n// TODO: Turn these images into html\nexport const Appendix: Story = () => {\n  return (\n    <DocContainer>\n      <h1>Welcome to Headstorm UI</h1>\n      <p>\n        Headstorm UI is a component library which is in it for the long haul. Unlike other bootstrap\n        libraries, it lets you fully customize and theme every piece of it through a\n        straight-forward API, which means you won't have to rip out your components and rewrite them\n        once your app is out of the \"POC\" phase.\n      </p>\n      <p>\n        The components you used in the hackathon will be the same ones you use when you're a fortune\n        500 megacorp.\n      </p>\n      <FullWidthImage\n        src={`${process.env.PUBLIC_URL}/images/ThemingExample.png`}\n        alt=\"Theming Example\"\n      />\n      <FullWidthImage\n        src={`${process.env.PUBLIC_URL}/images/ThemeExampleCode.png`}\n        alt=\"Theming Example Code\"\n      />\n    </DocContainer>\n  );\n};\n\nexport default {\n  title: 'Appendix',\n  parameters: { controls: { hideNoControlsWarning: true } },\n} as Meta;\n\n\n\nAppendix.parameters = { storySource: { source: \"() => {\\n  return (\\n    <DocContainer>\\n      <h1>Welcome to Headstorm UI</h1>\\n      <p>\\n        Headstorm UI is a component library which is in it for the long haul. Unlike other bootstrap\\n        libraries, it lets you fully customize and theme every piece of it through a\\n        straight-forward API, which means you won't have to rip out your components and rewrite them\\n        once your app is out of the \\\"POC\\\" phase.\\n      </p>\\n      <p>\\n        The components you used in the hackathon will be the same ones you use when you're a fortune\\n        500 megacorp.\\n      </p>\\n      <FullWidthImage\\n        src={`${process.env.PUBLIC_URL}/images/ThemingExample.png`}\\n        alt=\\\"Theming Example\\\"\\n      />\\n      <FullWidthImage\\n        src={`${process.env.PUBLIC_URL}/images/ThemeExampleCode.png`}\\n        alt=\\\"Theming Example Code\\\"\\n      />\\n    </DocContainer>\\n  );\\n}\" }, ...Appendix.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import * as React from 'react';\\nimport { Story, Meta } from '@storybook/react';\\nimport styled from 'styled-components';\\nimport { withFoundryContext } from '../../../.storybook/decorators';\\nimport colors from '../../enums/colors';\\nimport Avatar, { AvatarProps } from './Avatar';\\n\\nexport const DefaultAvatar: Story<AvatarProps> = (args: AvatarProps) => <Avatar {...args} />;\\nDefaultAvatar.args = {\\n  placeholder: 'AA',\\n  children: '',\\n  size: 10,\\n  imgURL: 'https://source.unsplash.com/collection/19271953',\\n  borderRadiusPercent: 50,\\n  color: colors.grayXlight,\\n  isLoading: false,\\n};\\n\\nconst LabelContainer = styled.div`\\n  position: absolute;\\n  bottom: 0;\\n  width: 100%;\\n  background-color: rgba(0, 0, 0, 0.5);\\n  color: white;\\n  padding: 8px 0;\\n  text-align: center;\\n`;\\n\\nexport const LabelAvatar: Story<AvatarProps & { children: string }> = ({\\n  children,\\n  ...args\\n}: AvatarProps) => (\\n  <Avatar {...args}>\\n    <LabelContainer>{children}</LabelContainer>\\n  </Avatar>\\n);\\n\\nLabelAvatar.args = {\\n  placeholder: 'JS',\\n  children: 'John Smith',\\n  size: 10,\\n  imgURL: 'https://source.unsplash.com/collection/19271953',\\n  borderRadiusPercent: 10,\\n  color: colors.grayXlight,\\n  isLoading: false,\\n};\\n\\nexport default {\\n  title: 'Avatar',\\n  component: Avatar,\\n  decorators: [withFoundryContext],\\n  argTypes: {\\n    borderRadiusPercent: { control: { type: 'range', min: 0, max: 50, step: 1 } },\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"DefaultAvatar\":{\"startLoc\":{\"col\":49,\"line\":8},\"endLoc\":{\"col\":92,\"line\":8},\"startBody\":{\"col\":49,\"line\":8},\"endBody\":{\"col\":92,\"line\":8}},\"LabelAvatar\":{\"startLoc\":{\"col\":70,\"line\":29},\"endLoc\":{\"col\":1,\"line\":36},\"startBody\":{\"col\":70,\"line\":29},\"endBody\":{\"col\":1,\"line\":36}}};\n    \nimport * as React from 'react';\nimport { Story, Meta } from '@storybook/react';\nimport styled from 'styled-components';\nimport { withFoundryContext } from '../../../.storybook/decorators';\nimport colors from '../../enums/colors';\nimport Avatar, { AvatarProps } from './Avatar';\n\nexport const DefaultAvatar: Story<AvatarProps> = (args: AvatarProps) => <Avatar {...args} />;;\nDefaultAvatar.args = {\n  placeholder: 'AA',\n  children: '',\n  size: 10,\n  imgURL: 'https://source.unsplash.com/collection/19271953',\n  borderRadiusPercent: 50,\n  color: colors.grayXlight,\n  isLoading: false,\n};\n\nconst LabelContainer = styled.div`\n  position: absolute;\n  bottom: 0;\n  width: 100%;\n  background-color: rgba(0, 0, 0, 0.5);\n  color: white;\n  padding: 8px 0;\n  text-align: center;\n`;\n\nexport const LabelAvatar: Story<AvatarProps & { children: string }> = ({\n  children,\n  ...args\n}: AvatarProps) => (\n  <Avatar {...args}>\n    <LabelContainer>{children}</LabelContainer>\n  </Avatar>\n);\n\nLabelAvatar.args = {\n  placeholder: 'JS',\n  children: 'John Smith',\n  size: 10,\n  imgURL: 'https://source.unsplash.com/collection/19271953',\n  borderRadiusPercent: 10,\n  color: colors.grayXlight,\n  isLoading: false,\n};\n\nexport default {\n  title: 'Avatar',\n  component: Avatar,\n  decorators: [withFoundryContext],\n  argTypes: {\n    borderRadiusPercent: { control: { type: 'range', min: 0, max: 50, step: 1 } },\n  },\n} as Meta;\n\n\n\nDefaultAvatar.parameters = { storySource: { source: \"(args: AvatarProps) => <Avatar {...args} />\" }, ...DefaultAvatar.parameters };\nLabelAvatar.parameters = { storySource: { source: \"({\\n  children,\\n  ...args\\n}: AvatarProps) => (\\n  <Avatar {...args}>\\n    <LabelContainer>{children}</LabelContainer>\\n  </Avatar>\\n)\" }, ...LabelAvatar.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import * as React from 'react';\\nimport styled from 'styled-components';\\n\\nimport { Story, Meta } from '@storybook/react';\\n\\nimport { mdiMessage, mdiSend } from '@mdi/js';\\n\\nimport variants from '../../enums/variants';\\nimport colors from '../../enums/colors';\\nimport FeedbackTypes from '../../enums/feedbackTypes';\\nimport Button, { ButtonProps } from './Button';\\n\\nconst StyledIconContainer = styled.div`\\n  z-index: 1;\\n  margin-left: 1em;\\n  transition: transform 0.5s ease;\\n  &:hover {\\n    transform: rotate(180deg);\\n  }\\n`;\\n\\nexport const BasicButton: Story<ButtonProps> = args => <Button {...args} />;\\nBasicButton.args = {\\n  variant: variants.fill,\\n  color: colors.primaryDark,\\n  disabled: false,\\n  feedbackType: FeedbackTypes.ripple,\\n  isLoading: false,\\n  elevation: 1,\\n  isProcessing: false,\\n  iconPrefix: 'none',\\n  iconSuffix: 'none',\\n  children: 'Default text',\\n  StyledRightIconContainer: StyledIconContainer,\\n  leftIconProps: { size: '1em' },\\n  rightIconProps: { size: '1em' },\\n};\\n\\nconst iconOptions = {\\n  options: ['none', 'mdiMessage', 'mdiSend'],\\n  mapping: {\\n    none: '',\\n    mdiMessage,\\n    mdiSend,\\n  },\\n  control: {\\n    type: 'radio',\\n  },\\n};\\n\\nexport default {\\n  title: 'Button',\\n  component: Button,\\n  argTypes: {\\n    elevation: { control: { type: 'range', min: -5, max: 5, step: 1 } },\\n    iconPrefix: iconOptions,\\n    iconSuffix: iconOptions,\\n  },\\n  parameters: {\\n    design: {\\n      type: 'figma',\\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=83%3A2',\\n    },\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"BasicButton\":{\"startLoc\":{\"col\":47,\"line\":22},\"endLoc\":{\"col\":75,\"line\":22},\"startBody\":{\"col\":47,\"line\":22},\"endBody\":{\"col\":75,\"line\":22}}};\n    \nimport * as React from 'react';\nimport styled from 'styled-components';\n\nimport { Story, Meta } from '@storybook/react';\n\nimport { mdiMessage, mdiSend } from '@mdi/js';\n\nimport variants from '../../enums/variants';\nimport colors from '../../enums/colors';\nimport FeedbackTypes from '../../enums/feedbackTypes';\nimport Button, { ButtonProps } from './Button';\n\nconst StyledIconContainer = styled.div`\n  z-index: 1;\n  margin-left: 1em;\n  transition: transform 0.5s ease;\n  &:hover {\n    transform: rotate(180deg);\n  }\n`;\n\nexport const BasicButton: Story<ButtonProps> = args => <Button {...args} />;\nBasicButton.args = {\n  variant: variants.fill,\n  color: colors.primaryDark,\n  disabled: false,\n  feedbackType: FeedbackTypes.ripple,\n  isLoading: false,\n  elevation: 1,\n  isProcessing: false,\n  iconPrefix: 'none',\n  iconSuffix: 'none',\n  children: 'Default text',\n  StyledRightIconContainer: StyledIconContainer,\n  leftIconProps: { size: '1em' },\n  rightIconProps: { size: '1em' },\n};\n\nconst iconOptions = {\n  options: ['none', 'mdiMessage', 'mdiSend'],\n  mapping: {\n    none: '',\n    mdiMessage,\n    mdiSend,\n  },\n  control: {\n    type: 'radio',\n  },\n};\n\nexport default {\n  title: 'Button',\n  component: Button,\n  argTypes: {\n    elevation: { control: { type: 'range', min: -5, max: 5, step: 1 } },\n    iconPrefix: iconOptions,\n    iconSuffix: iconOptions,\n  },\n  parameters: {\n    design: {\n      type: 'figma',\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=83%3A2',\n    },\n  },\n} as Meta;\n\n\n\nBasicButton.parameters = { storySource: { source: \"args => <Button {...args} />\" }, ...BasicButton.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from 'react';\\nimport styled from 'styled-components';\\n\\nimport { Story, Meta } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport Card, { Header, Footer } from './Card';\\nimport colors from '../../enums/colors';\\nimport timings from '../../enums/timings';\\nimport fonts from '../../enums/fonts';\\nimport feedbackTypes from '../../enums/feedbackTypes';\\n\\nconst Template: Story = args => {\\n  return <Card {...args} disableFeedback />;\\n};\\n\\nexport const Default = Template.bind({});\\nDefault.args = {\\n  header: 'Card title',\\n  footer: 'Actionable buttons, whatever other stuff you want to pass in!',\\n  elevation: 2,\\n  feedbackType: feedbackTypes.ripple,\\n  disableFeedback: false,\\n  children:\\n    'A Hello, World! program generally is a computer program that outputs or displays the message Hello, World!.',\\n};\\n\\nconst themeColors = {\\n  ...colors,\\n  background: 'beige',\\n  primary: 'purple',\\n};\\n\\nconst themeTimings = {\\n  ...timings,\\n  xSlow: '2s',\\n};\\n\\nconst ThemedContainer = styled.div`\\n  ${({ elevation = 0 }: { elevation: number }) => `\\n      border-radius: 1rem;\\n      width: fit-content;\\n      background-color: ${themeColors.background};\\n\\n      transition: transform ${themeTimings.xSlow};\\n      transform: scale(${elevation * 0.05 + 1});\\n\\n      ${fonts.body}\\n      font-size: 1rem;\\n      border: 1px solid ${themeColors.primary};\\n    `}\\n`;\\n\\nconst ThemedHeader = styled(Header)`\\n  font-family: Parchment, serif;\\n  line-height: 0;\\n  font-size: 4rem;\\n  padding-top: 2.5rem;\\n  padding-left: 0.75rem;\\n  padding-bottom: 1rem;\\n  text-transform: unset;\\n  color: ${themeColors.primary};\\n`;\\n\\nconst ThemedFooter = styled(Footer)`\\n  border-top: 1px solid ${themeColors.primary};\\n`;\\n\\nexport const Themed = Template.bind({});\\nThemed.args = {\\n  ...Default.args,\\n  elevation: 0,\\n  StyledContainer: ThemedContainer,\\n  StyledHeader: ThemedHeader,\\n  StyledFooter: ThemedFooter,\\n};\\n\\nconst cardContainerRef = React.createRef<HTMLDivElement>();\\nconst cardHeaderRef = React.createRef<HTMLDivElement>();\\nconst cardBodyRef = React.createRef<HTMLDivElement>();\\nconst cardFooterRef = React.createRef<HTMLDivElement>();\\nconst interactiveFeedbackRef = React.createRef<HTMLDivElement>();\\nconst onClick = (e: React.SyntheticEvent) => {\\n  e.preventDefault();\\n  action('onClick')(\\n    `container width x height: ${cardContainerRef.current?.clientWidth} x ${cardContainerRef.current?.clientHeight}\\n    header width x height: ${cardHeaderRef.current?.clientWidth} x ${cardHeaderRef.current?.clientHeight}\\n    body width x height: ${cardBodyRef.current?.clientWidth} x ${cardBodyRef.current?.clientHeight}\\n    footer width x height: ${cardFooterRef.current?.clientWidth} x ${cardFooterRef.current?.clientHeight}\\n    interactive width x height: ${interactiveFeedbackRef.current?.clientWidth} x ${interactiveFeedbackRef.current?.clientHeight}`,\\n  );\\n};\\n\\nexport const Ref = Template.bind({});\\nRef.args = {\\n  ...Default.args,\\n  header: 'View the Actions tab below',\\n  footer:\\n    'Try adjusting the width of the viewport. New clicks will return the updated dimensions for each element.',\\n  onClick,\\n  containerRef: cardContainerRef,\\n  headerRef: cardHeaderRef,\\n  bodyRef: cardBodyRef,\\n  footerRef: cardFooterRef,\\n  interactiveFeedbackRef,\\n  children:\\n    'Then click anywhere on the Card to see the width/height of the child elements calculated via the Ref props!',\\n};\\n\\nexport default {\\n  title: 'Card',\\n  component: Card,\\n  argTypes: {\\n    elevation: { control: { type: 'range', min: -5, max: 5, step: 1 } },\\n  },\\n  parameters: {\\n    design: {\\n      type: 'figma',\\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=102%3A0',\\n    },\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Default\":{\"startLoc\":{\"col\":24,\"line\":13},\"endLoc\":{\"col\":1,\"line\":15},\"startBody\":{\"col\":24,\"line\":13},\"endBody\":{\"col\":1,\"line\":15}},\"Themed\":{\"startLoc\":{\"col\":24,\"line\":13},\"endLoc\":{\"col\":1,\"line\":15},\"startBody\":{\"col\":24,\"line\":13},\"endBody\":{\"col\":1,\"line\":15}},\"Ref\":{\"startLoc\":{\"col\":24,\"line\":13},\"endLoc\":{\"col\":1,\"line\":15},\"startBody\":{\"col\":24,\"line\":13},\"endBody\":{\"col\":1,\"line\":15}}};\n    \nimport React from 'react';\nimport styled from 'styled-components';\n\nimport { Story, Meta } from '@storybook/react';\nimport { action } from '@storybook/addon-actions';\n\nimport Card, { Header, Footer } from './Card';\nimport colors from '../../enums/colors';\nimport timings from '../../enums/timings';\nimport fonts from '../../enums/fonts';\nimport feedbackTypes from '../../enums/feedbackTypes';\n\nconst Template: Story = args => {\n  return <Card {...args} disableFeedback />;\n};\n\nexport const Default = Template.bind({});;\nDefault.args = {\n  header: 'Card title',\n  footer: 'Actionable buttons, whatever other stuff you want to pass in!',\n  elevation: 2,\n  feedbackType: feedbackTypes.ripple,\n  disableFeedback: false,\n  children:\n    'A Hello, World! program generally is a computer program that outputs or displays the message Hello, World!.',\n};\n\nconst themeColors = {\n  ...colors,\n  background: 'beige',\n  primary: 'purple',\n};\n\nconst themeTimings = {\n  ...timings,\n  xSlow: '2s',\n};\n\nconst ThemedContainer = styled.div`\n  ${({ elevation = 0 }: { elevation: number }) => `\n      border-radius: 1rem;\n      width: fit-content;\n      background-color: ${themeColors.background};\n\n      transition: transform ${themeTimings.xSlow};\n      transform: scale(${elevation * 0.05 + 1});\n\n      ${fonts.body}\n      font-size: 1rem;\n      border: 1px solid ${themeColors.primary};\n    `}\n`;\n\nconst ThemedHeader = styled(Header)`\n  font-family: Parchment, serif;\n  line-height: 0;\n  font-size: 4rem;\n  padding-top: 2.5rem;\n  padding-left: 0.75rem;\n  padding-bottom: 1rem;\n  text-transform: unset;\n  color: ${themeColors.primary};\n`;\n\nconst ThemedFooter = styled(Footer)`\n  border-top: 1px solid ${themeColors.primary};\n`;\n\nexport const Themed = Template.bind({});;\nThemed.args = {\n  ...Default.args,\n  elevation: 0,\n  StyledContainer: ThemedContainer,\n  StyledHeader: ThemedHeader,\n  StyledFooter: ThemedFooter,\n};\n\nconst cardContainerRef = React.createRef<HTMLDivElement>();\nconst cardHeaderRef = React.createRef<HTMLDivElement>();\nconst cardBodyRef = React.createRef<HTMLDivElement>();\nconst cardFooterRef = React.createRef<HTMLDivElement>();\nconst interactiveFeedbackRef = React.createRef<HTMLDivElement>();\nconst onClick = (e: React.SyntheticEvent) => {\n  e.preventDefault();\n  action('onClick')(\n    `container width x height: ${cardContainerRef.current?.clientWidth} x ${cardContainerRef.current?.clientHeight}\n    header width x height: ${cardHeaderRef.current?.clientWidth} x ${cardHeaderRef.current?.clientHeight}\n    body width x height: ${cardBodyRef.current?.clientWidth} x ${cardBodyRef.current?.clientHeight}\n    footer width x height: ${cardFooterRef.current?.clientWidth} x ${cardFooterRef.current?.clientHeight}\n    interactive width x height: ${interactiveFeedbackRef.current?.clientWidth} x ${interactiveFeedbackRef.current?.clientHeight}`,\n  );\n};\n\nexport const Ref = Template.bind({});\nRef.args = {\n  ...Default.args,\n  header: 'View the Actions tab below',\n  footer:\n    'Try adjusting the width of the viewport. New clicks will return the updated dimensions for each element.',\n  onClick,\n  containerRef: cardContainerRef,\n  headerRef: cardHeaderRef,\n  bodyRef: cardBodyRef,\n  footerRef: cardFooterRef,\n  interactiveFeedbackRef,\n  children:\n    'Then click anywhere on the Card to see the width/height of the child elements calculated via the Ref props!',\n};\n\nexport default {\n  title: 'Card',\n  component: Card,\n  argTypes: {\n    elevation: { control: { type: 'range', min: -5, max: 5, step: 1 } },\n  },\n  parameters: {\n    design: {\n      type: 'figma',\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=102%3A0',\n    },\n  },\n} as Meta;\n\n\n\nDefault.parameters = { storySource: { source: \"args => {\\n  return <Card {...args} disableFeedback />;\\n}\" }, ...Default.parameters };\nThemed.parameters = { storySource: { source: \"args => {\\n  return <Card {...args} disableFeedback />;\\n}\" }, ...Themed.parameters };\nRef.parameters = { storySource: { source: \"args => {\\n  return <Card {...args} disableFeedback />;\\n}\" }, ...Ref.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from 'react';\\nimport styled from 'styled-components';\\n\\nimport { Story, Meta } from '@storybook/react';\\n\\nimport colors from '../../enums/colors';\\nimport Divider from './Divider';\\n\\nconst Template: Story = args => <Divider {...args} />;\\n\\nexport const Default = Template.bind({});\\nDefault.args = {\\n  width: '10rem',\\n  height: '1px',\\n};\\n\\nconst ThemedDivider = styled.hr`\\n  ${({ height, width }: { height: string; width: string }) => `\\n      box-shadow: 10px, 10px, ${colors.primary};\\n      border: none;\\n      background: radial-gradient(${colors.primary}, transparent);\\n      height: ${height};\\n        width: ${width};\\n    `}\\n`;\\n\\nexport const Themed = Template.bind({});\\nThemed.args = {\\n  ...Default.args,\\n  height: '2px',\\n  StyledDivider: ThemedDivider,\\n};\\n\\nexport default {\\n  title: 'Divider',\\n  component: Divider,\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Default\":{\"startLoc\":{\"col\":24,\"line\":9},\"endLoc\":{\"col\":53,\"line\":9},\"startBody\":{\"col\":24,\"line\":9},\"endBody\":{\"col\":53,\"line\":9}},\"Themed\":{\"startLoc\":{\"col\":24,\"line\":9},\"endLoc\":{\"col\":53,\"line\":9},\"startBody\":{\"col\":24,\"line\":9},\"endBody\":{\"col\":53,\"line\":9}}};\n    \nimport React from 'react';\nimport styled from 'styled-components';\n\nimport { Story, Meta } from '@storybook/react';\n\nimport colors from '../../enums/colors';\nimport Divider from './Divider';\n\nconst Template: Story = args => <Divider {...args} />;\n\nexport const Default = Template.bind({});;\nDefault.args = {\n  width: '10rem',\n  height: '1px',\n};\n\nconst ThemedDivider = styled.hr`\n  ${({ height, width }: { height: string; width: string }) => `\n      box-shadow: 10px, 10px, ${colors.primary};\n      border: none;\n      background: radial-gradient(${colors.primary}, transparent);\n      height: ${height};\n        width: ${width};\n    `}\n`;\n\nexport const Themed = Template.bind({});\nThemed.args = {\n  ...Default.args,\n  height: '2px',\n  StyledDivider: ThemedDivider,\n};\n\nexport default {\n  title: 'Divider',\n  component: Divider,\n} as Meta;\n\n\n\nDefault.parameters = { storySource: { source: \"args => <Divider {...args} />\" }, ...Default.parameters };\nThemed.parameters = { storySource: { source: \"args => <Divider {...args} />\" }, ...Themed.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React, { useState } from 'react';\\nimport styled from 'styled-components';\\nimport { Story, Meta } from '@storybook/react';\\nimport { mdiAccountCircleOutline, mdiRefresh } from '@mdi/js';\\nimport { name, address, internet, company, phone, commerce, lorem } from 'faker';\\nimport TextInput from '../TextInput';\\nimport Button from '../Button';\\nimport Card from '../Card';\\nimport Divider from '../Divider';\\nimport Dropdown from '../Dropdown';\\nimport Modal from '../Modal';\\nimport Text from '../Text';\\nimport Label from '../Label';\\n\\nimport colors from '../../enums/colors';\\nimport variants from '../../enums/variants';\\nimport Toggle from '../Toggle/Toggle';\\n\\n// All 50 + DC\\nconst stateAbbreviations = [\\n  'AL',\\n  'AK',\\n  'AZ',\\n  'AR',\\n  'CA',\\n  'CO',\\n  'CT',\\n  'DE',\\n  'DC',\\n  'FL',\\n  'GA',\\n  'HI',\\n  'ID',\\n  'IL',\\n  'IN',\\n  'IA',\\n  'KS',\\n  'KY',\\n  'LA',\\n  'ME',\\n  'MD',\\n  'MA',\\n  'MI',\\n  'MN',\\n  'MS',\\n  'MO',\\n  'MT',\\n  'NE',\\n  'NV',\\n  'NH',\\n  'NJ',\\n  'NM',\\n  'NY',\\n  'NC',\\n  'ND',\\n  'OH',\\n  'OK',\\n  'OR',\\n  'PA',\\n  'RI',\\n  'SC',\\n  'SD',\\n  'TN',\\n  'TX',\\n  'UT',\\n  'VT',\\n  'VA',\\n  'WA',\\n  'WV',\\n  'WI',\\n  'WY',\\n];\\n\\ninterface state {\\n  firstName: string;\\n  lastName: string;\\n  title: string;\\n  city: string;\\n  state: string;\\n  phone: string;\\n  email: string;\\n  company: string;\\n  department: string;\\n  notifications: boolean;\\n  bio: string;\\n  age: number;\\n}\\n\\nconst defaultState: state = {\\n  firstName: name.firstName(),\\n  lastName: name.lastName(),\\n  title: name.title(),\\n  city: address.city(),\\n  state: address.stateAbbr(),\\n  phone: phone.phoneNumber(),\\n  age: Math.ceil(Math.random() * 50 + 18),\\n  email: internet.email(),\\n  company: company.companyName(),\\n  department: commerce.department(),\\n  notifications: false,\\n  bio: lorem.paragraph(5),\\n};\\n\\n// Adjusting the style of the footer to help position the buttons added\\nconst StyledFooter = styled(Card.Footer)`\\n  display: flex;\\n  justify-content: space-between;\\n`;\\n\\nconst StyledBody = styled(Card.Body)`\\n  display: grid;\\n  grid-template-columns: 1fr 1fr;\\n  column-gap: 1rem;\\n  row-gap: 1.5rem;\\n`;\\n\\nconst ResetButtonContainer = styled(Button.Container)`\\n  margin-right: 1.5rem;\\n`;\\n\\nexport const ControlledForm: Story = () => {\\n  const [state, setState] = useState(defaultState);\\n  const [isSaving, setIsSaving] = useState(false);\\n  const [isResetting, setIsResetting] = useState(false);\\n  const [savedState, setSavedState] = useState(defaultState);\\n  const [isModalOpen, setIsModalOpen] = useState(false);\\n\\n  // By creating a callback function like this, we will create a new callback for each\\n  // handler on every render, which is not the ideal scenario for maximum performance.\\n  // To prevent this, use the useCallback helper. We're  doing this to shorten the length\\n  // of the example's source code.\\n  const createTextInputCallback = (property: string): ((event: any) => void) => {\\n    return event => {\\n      setState({ ...state, [property]: event.target.value });\\n    };\\n  };\\n\\n  const onSave = () => {\\n    const newSavedState = { ...state };\\n    setIsSaving(true);\\n\\n    // Use a setTimeout to simulate a network call\\n    setTimeout(() => {\\n      setSavedState(newSavedState);\\n      setIsSaving(false);\\n    }, Math.random() * 1000);\\n  };\\n\\n  const onReset = () => {\\n    setIsResetting(true);\\n    setIsModalOpen(false);\\n\\n    // Simulate network call\\n    setTimeout(() => {\\n      setIsResetting(false);\\n      setState({ ...savedState });\\n    }, Math.random() * 1000 + 500);\\n  };\\n\\n  const closeModal = () => {\\n    setIsModalOpen(false);\\n  };\\n\\n  const openModal = () => {\\n    setIsModalOpen(true);\\n  };\\n\\n  const saveButton = (\\n    <Button\\n      key=\\\"saveButton\\\"\\n      onClick={onSave}\\n      color={colors.primaryDark}\\n      isProcessing={isSaving}\\n      type={Button.ButtonTypes.submit}\\n    >\\n      {isSaving ? 'Saving' : 'Save'}\\n    </Button>\\n  );\\n\\n  const cancelButton = (\\n    <Button\\n      key=\\\"cancelButton\\\"\\n      onClick={openModal}\\n      color={colors.destructive}\\n      isProcessing={isResetting}\\n      variant={variants.text}\\n    >\\n      Reset\\n    </Button>\\n  );\\n\\n  const confirmButton = (\\n    <Button\\n      key=\\\"confirmButton\\\"\\n      onClick={onReset}\\n      color={colors.destructive}\\n      iconPrefix={mdiRefresh}\\n      type={Button.ButtonTypes.reset}\\n    >\\n      Reset form\\n    </Button>\\n  );\\n\\n  const abortButton = (\\n    <Button\\n      key=\\\"cancelButton\\\"\\n      onClick={closeModal}\\n      color={colors.destructive}\\n      variant={variants.text}\\n      StyledContainer={ResetButtonContainer}\\n      type={Button.ButtonTypes.button}\\n    >\\n      Go back\\n    </Button>\\n  );\\n\\n  const Header = (\\n    <>\\n      <Text key=\\\"headerText\\\" iconPrefix={mdiAccountCircleOutline}>\\n        Edit Your Profile\\n      </Text>\\n      <Divider width=\\\"100%\\\" />\\n    </>\\n  );\\n\\n  return (\\n    <>\\n      <Card\\n        elevation={1}\\n        header={Header}\\n        footer={[cancelButton, saveButton]}\\n        StyledFooter={StyledFooter}\\n        StyledBody={StyledBody}\\n      >\\n        <Label\\n          labelText=\\\"First Name\\\"\\n          htmlFor=\\\"firstName\\\"\\n          isValid={state.firstName !== ''}\\n          isRequired\\n          key=\\\"firstName\\\"\\n        >\\n          <TextInput\\n            onChange={createTextInputCallback('firstName')}\\n            value={state.firstName}\\n            isValid={typeof state.firstName !== 'undefined' && state.firstName.length > 0}\\n            errorMessage=\\\"First Name cannot be blank\\\"\\n            id=\\\"firstName\\\"\\n          />\\n        </Label>\\n\\n        <Label labelText=\\\"Last Name\\\" htmlFor=\\\"lastName\\\" key=\\\"lastName\\\">\\n          <TextInput\\n            onChange={createTextInputCallback('lastName')}\\n            value={state.lastName}\\n            id=\\\"lastName\\\"\\n          />\\n        </Label>\\n\\n        <Label\\n          labelText=\\\"Age\\\"\\n          htmlFor=\\\"age\\\"\\n          isRequired\\n          isValid={!!state.age && +state.age > 13}\\n          key=\\\"age\\\"\\n        >\\n          <TextInput\\n            onChange={createTextInputCallback('age')}\\n            value={`${state.age}`}\\n            errorMessage=\\\"Must be 13+\\\"\\n            isValid={!!state.age && +state.age > 13}\\n            id=\\\"age\\\"\\n            type=\\\"number\\\"\\n          />\\n        </Label>\\n\\n        <Label\\n          labelText=\\\"Bio\\\"\\n          htmlFor=\\\"bio\\\"\\n          key=\\\"bio\\\"\\n          isRequired\\n          isValid={!!state.bio && state.bio.length > 30}\\n        >\\n          <TextInput\\n            onChange={createTextInputCallback('bio')}\\n            value={state.bio}\\n            id=\\\"bio\\\"\\n            isValid={!!state.bio && state.bio.length > 30}\\n            errorMessage=\\\"Write a little more\\\"\\n            isMultiline\\n            rows={3}\\n            cols={25}\\n          />\\n        </Label>\\n\\n        <Label labelText=\\\"Title\\\" htmlFor=\\\"title\\\" key=\\\"title\\\">\\n          <TextInput onChange={createTextInputCallback('title')} value={state.title} id=\\\"title\\\" />\\n        </Label>\\n\\n        <Label labelText=\\\"Company\\\" htmlFor=\\\"company\\\" key=\\\"company\\\">\\n          <TextInput\\n            onChange={createTextInputCallback('company')}\\n            value={state.company}\\n            id=\\\"company\\\"\\n          />\\n        </Label>\\n\\n        <Label labelText=\\\"City\\\" htmlFor=\\\"city\\\" key=\\\"city\\\">\\n          <TextInput onChange={createTextInputCallback('city')} value={state.city} id=\\\"city\\\" />\\n        </Label>\\n\\n        <Label labelText=\\\"State\\\" htmlFor=\\\"state\\\" key=\\\"state\\\">\\n          <Dropdown\\n            name=\\\"state-dropdown\\\"\\n            options={stateAbbreviations.map(abr => ({ id: abr, optionValue: abr }))}\\n            color={colors.primaryDark}\\n            values={[state.state]}\\n            searchable\\n            onSelect={val => {\\n              setState({ ...state, state: `${val}` });\\n            }}\\n            variant={variants.fill}\\n          />\\n        </Label>\\n\\n        <Label labelText=\\\"Notifications\\\" htmlFor=\\\"notifications\\\" key=\\\"notifications\\\">\\n          <Toggle\\n            onToggle={() => {\\n              setState({ ...state, notifications: !state.notifications });\\n            }}\\n            checked={state.notifications}\\n            inputProps={{ onChange: () => {} }}\\n            color={state.notifications ? '#8f8' : 'white'}\\n          />\\n          {state.notifications ? '  Enabled' : '  Disabled'}\\n        </Label>\\n      </Card>\\n      {isModalOpen && (\\n        <Modal onClose={closeModal} onClickOutside={closeModal} backgroundDarkness={0.5}>\\n          <Card\\n            elevation={1}\\n            header=\\\"Would you like to continue?\\\"\\n            footer={[abortButton, confirmButton]}\\n          >\\n            You will lose any unsaved changes, are you sure you would like to reset?\\n          </Card>\\n        </Modal>\\n      )}\\n    </>\\n  );\\n};\\n\\nexport default {\\n  title: 'Form Example',\\n  parameters: {\\n    design: {\\n      type: 'figma',\\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=0%3A1',\\n    },\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"ControlledForm\":{\"startLoc\":{\"col\":37,\"line\":121},\"endLoc\":{\"col\":1,\"line\":350},\"startBody\":{\"col\":37,\"line\":121},\"endBody\":{\"col\":1,\"line\":350}}};\n    \nimport React, { useState } from 'react';\nimport styled from 'styled-components';\nimport { Story, Meta } from '@storybook/react';\nimport { mdiAccountCircleOutline, mdiRefresh } from '@mdi/js';\nimport { name, address, internet, company, phone, commerce, lorem } from 'faker';\nimport TextInput from '../TextInput';\nimport Button from '../Button';\nimport Card from '../Card';\nimport Divider from '../Divider';\nimport Dropdown from '../Dropdown';\nimport Modal from '../Modal';\nimport Text from '../Text';\nimport Label from '../Label';\n\nimport colors from '../../enums/colors';\nimport variants from '../../enums/variants';\nimport Toggle from '../Toggle/Toggle';\n\n// All 50 + DC\nconst stateAbbreviations = [\n  'AL',\n  'AK',\n  'AZ',\n  'AR',\n  'CA',\n  'CO',\n  'CT',\n  'DE',\n  'DC',\n  'FL',\n  'GA',\n  'HI',\n  'ID',\n  'IL',\n  'IN',\n  'IA',\n  'KS',\n  'KY',\n  'LA',\n  'ME',\n  'MD',\n  'MA',\n  'MI',\n  'MN',\n  'MS',\n  'MO',\n  'MT',\n  'NE',\n  'NV',\n  'NH',\n  'NJ',\n  'NM',\n  'NY',\n  'NC',\n  'ND',\n  'OH',\n  'OK',\n  'OR',\n  'PA',\n  'RI',\n  'SC',\n  'SD',\n  'TN',\n  'TX',\n  'UT',\n  'VT',\n  'VA',\n  'WA',\n  'WV',\n  'WI',\n  'WY',\n];\n\ninterface state {\n  firstName: string;\n  lastName: string;\n  title: string;\n  city: string;\n  state: string;\n  phone: string;\n  email: string;\n  company: string;\n  department: string;\n  notifications: boolean;\n  bio: string;\n  age: number;\n}\n\nconst defaultState: state = {\n  firstName: name.firstName(),\n  lastName: name.lastName(),\n  title: name.title(),\n  city: address.city(),\n  state: address.stateAbbr(),\n  phone: phone.phoneNumber(),\n  age: Math.ceil(Math.random() * 50 + 18),\n  email: internet.email(),\n  company: company.companyName(),\n  department: commerce.department(),\n  notifications: false,\n  bio: lorem.paragraph(5),\n};\n\n// Adjusting the style of the footer to help position the buttons added\nconst StyledFooter = styled(Card.Footer)`\n  display: flex;\n  justify-content: space-between;\n`;\n\nconst StyledBody = styled(Card.Body)`\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  column-gap: 1rem;\n  row-gap: 1.5rem;\n`;\n\nconst ResetButtonContainer = styled(Button.Container)`\n  margin-right: 1.5rem;\n`;\n\nexport const ControlledForm: Story = () => {\n  const [state, setState] = useState(defaultState);\n  const [isSaving, setIsSaving] = useState(false);\n  const [isResetting, setIsResetting] = useState(false);\n  const [savedState, setSavedState] = useState(defaultState);\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  // By creating a callback function like this, we will create a new callback for each\n  // handler on every render, which is not the ideal scenario for maximum performance.\n  // To prevent this, use the useCallback helper. We're  doing this to shorten the length\n  // of the example's source code.\n  const createTextInputCallback = (property: string): ((event: any) => void) => {\n    return event => {\n      setState({ ...state, [property]: event.target.value });\n    };\n  };\n\n  const onSave = () => {\n    const newSavedState = { ...state };\n    setIsSaving(true);\n\n    // Use a setTimeout to simulate a network call\n    setTimeout(() => {\n      setSavedState(newSavedState);\n      setIsSaving(false);\n    }, Math.random() * 1000);\n  };\n\n  const onReset = () => {\n    setIsResetting(true);\n    setIsModalOpen(false);\n\n    // Simulate network call\n    setTimeout(() => {\n      setIsResetting(false);\n      setState({ ...savedState });\n    }, Math.random() * 1000 + 500);\n  };\n\n  const closeModal = () => {\n    setIsModalOpen(false);\n  };\n\n  const openModal = () => {\n    setIsModalOpen(true);\n  };\n\n  const saveButton = (\n    <Button\n      key=\"saveButton\"\n      onClick={onSave}\n      color={colors.primaryDark}\n      isProcessing={isSaving}\n      type={Button.ButtonTypes.submit}\n    >\n      {isSaving ? 'Saving' : 'Save'}\n    </Button>\n  );\n\n  const cancelButton = (\n    <Button\n      key=\"cancelButton\"\n      onClick={openModal}\n      color={colors.destructive}\n      isProcessing={isResetting}\n      variant={variants.text}\n    >\n      Reset\n    </Button>\n  );\n\n  const confirmButton = (\n    <Button\n      key=\"confirmButton\"\n      onClick={onReset}\n      color={colors.destructive}\n      iconPrefix={mdiRefresh}\n      type={Button.ButtonTypes.reset}\n    >\n      Reset form\n    </Button>\n  );\n\n  const abortButton = (\n    <Button\n      key=\"cancelButton\"\n      onClick={closeModal}\n      color={colors.destructive}\n      variant={variants.text}\n      StyledContainer={ResetButtonContainer}\n      type={Button.ButtonTypes.button}\n    >\n      Go back\n    </Button>\n  );\n\n  const Header = (\n    <>\n      <Text key=\"headerText\" iconPrefix={mdiAccountCircleOutline}>\n        Edit Your Profile\n      </Text>\n      <Divider width=\"100%\" />\n    </>\n  );\n\n  return (\n    <>\n      <Card\n        elevation={1}\n        header={Header}\n        footer={[cancelButton, saveButton]}\n        StyledFooter={StyledFooter}\n        StyledBody={StyledBody}\n      >\n        <Label\n          labelText=\"First Name\"\n          htmlFor=\"firstName\"\n          isValid={state.firstName !== ''}\n          isRequired\n          key=\"firstName\"\n        >\n          <TextInput\n            onChange={createTextInputCallback('firstName')}\n            value={state.firstName}\n            isValid={typeof state.firstName !== 'undefined' && state.firstName.length > 0}\n            errorMessage=\"First Name cannot be blank\"\n            id=\"firstName\"\n          />\n        </Label>\n\n        <Label labelText=\"Last Name\" htmlFor=\"lastName\" key=\"lastName\">\n          <TextInput\n            onChange={createTextInputCallback('lastName')}\n            value={state.lastName}\n            id=\"lastName\"\n          />\n        </Label>\n\n        <Label\n          labelText=\"Age\"\n          htmlFor=\"age\"\n          isRequired\n          isValid={!!state.age && +state.age > 13}\n          key=\"age\"\n        >\n          <TextInput\n            onChange={createTextInputCallback('age')}\n            value={`${state.age}`}\n            errorMessage=\"Must be 13+\"\n            isValid={!!state.age && +state.age > 13}\n            id=\"age\"\n            type=\"number\"\n          />\n        </Label>\n\n        <Label\n          labelText=\"Bio\"\n          htmlFor=\"bio\"\n          key=\"bio\"\n          isRequired\n          isValid={!!state.bio && state.bio.length > 30}\n        >\n          <TextInput\n            onChange={createTextInputCallback('bio')}\n            value={state.bio}\n            id=\"bio\"\n            isValid={!!state.bio && state.bio.length > 30}\n            errorMessage=\"Write a little more\"\n            isMultiline\n            rows={3}\n            cols={25}\n          />\n        </Label>\n\n        <Label labelText=\"Title\" htmlFor=\"title\" key=\"title\">\n          <TextInput onChange={createTextInputCallback('title')} value={state.title} id=\"title\" />\n        </Label>\n\n        <Label labelText=\"Company\" htmlFor=\"company\" key=\"company\">\n          <TextInput\n            onChange={createTextInputCallback('company')}\n            value={state.company}\n            id=\"company\"\n          />\n        </Label>\n\n        <Label labelText=\"City\" htmlFor=\"city\" key=\"city\">\n          <TextInput onChange={createTextInputCallback('city')} value={state.city} id=\"city\" />\n        </Label>\n\n        <Label labelText=\"State\" htmlFor=\"state\" key=\"state\">\n          <Dropdown\n            name=\"state-dropdown\"\n            options={stateAbbreviations.map(abr => ({ id: abr, optionValue: abr }))}\n            color={colors.primaryDark}\n            values={[state.state]}\n            searchable\n            onSelect={val => {\n              setState({ ...state, state: `${val}` });\n            }}\n            variant={variants.fill}\n          />\n        </Label>\n\n        <Label labelText=\"Notifications\" htmlFor=\"notifications\" key=\"notifications\">\n          <Toggle\n            onToggle={() => {\n              setState({ ...state, notifications: !state.notifications });\n            }}\n            checked={state.notifications}\n            inputProps={{ onChange: () => {} }}\n            color={state.notifications ? '#8f8' : 'white'}\n          />\n          {state.notifications ? '  Enabled' : '  Disabled'}\n        </Label>\n      </Card>\n      {isModalOpen && (\n        <Modal onClose={closeModal} onClickOutside={closeModal} backgroundDarkness={0.5}>\n          <Card\n            elevation={1}\n            header=\"Would you like to continue?\"\n            footer={[abortButton, confirmButton]}\n          >\n            You will lose any unsaved changes, are you sure you would like to reset?\n          </Card>\n        </Modal>\n      )}\n    </>\n  );\n};\n\nexport default {\n  title: 'Form Example',\n  parameters: {\n    design: {\n      type: 'figma',\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=0%3A1',\n    },\n  },\n} as Meta;\n\n\n\nControlledForm.parameters = { storySource: { source: \"() => {\\n  const [state, setState] = useState(defaultState);\\n  const [isSaving, setIsSaving] = useState(false);\\n  const [isResetting, setIsResetting] = useState(false);\\n  const [savedState, setSavedState] = useState(defaultState);\\n  const [isModalOpen, setIsModalOpen] = useState(false);\\n\\n  // By creating a callback function like this, we will create a new callback for each\\n  // handler on every render, which is not the ideal scenario for maximum performance.\\n  // To prevent this, use the useCallback helper. We're  doing this to shorten the length\\n  // of the example's source code.\\n  const createTextInputCallback = (property: string): ((event: any) => void) => {\\n    return event => {\\n      setState({ ...state, [property]: event.target.value });\\n    };\\n  };\\n\\n  const onSave = () => {\\n    const newSavedState = { ...state };\\n    setIsSaving(true);\\n\\n    // Use a setTimeout to simulate a network call\\n    setTimeout(() => {\\n      setSavedState(newSavedState);\\n      setIsSaving(false);\\n    }, Math.random() * 1000);\\n  };\\n\\n  const onReset = () => {\\n    setIsResetting(true);\\n    setIsModalOpen(false);\\n\\n    // Simulate network call\\n    setTimeout(() => {\\n      setIsResetting(false);\\n      setState({ ...savedState });\\n    }, Math.random() * 1000 + 500);\\n  };\\n\\n  const closeModal = () => {\\n    setIsModalOpen(false);\\n  };\\n\\n  const openModal = () => {\\n    setIsModalOpen(true);\\n  };\\n\\n  const saveButton = (\\n    <Button\\n      key=\\\"saveButton\\\"\\n      onClick={onSave}\\n      color={colors.primaryDark}\\n      isProcessing={isSaving}\\n      type={Button.ButtonTypes.submit}\\n    >\\n      {isSaving ? 'Saving' : 'Save'}\\n    </Button>\\n  );\\n\\n  const cancelButton = (\\n    <Button\\n      key=\\\"cancelButton\\\"\\n      onClick={openModal}\\n      color={colors.destructive}\\n      isProcessing={isResetting}\\n      variant={variants.text}\\n    >\\n      Reset\\n    </Button>\\n  );\\n\\n  const confirmButton = (\\n    <Button\\n      key=\\\"confirmButton\\\"\\n      onClick={onReset}\\n      color={colors.destructive}\\n      iconPrefix={mdiRefresh}\\n      type={Button.ButtonTypes.reset}\\n    >\\n      Reset form\\n    </Button>\\n  );\\n\\n  const abortButton = (\\n    <Button\\n      key=\\\"cancelButton\\\"\\n      onClick={closeModal}\\n      color={colors.destructive}\\n      variant={variants.text}\\n      StyledContainer={ResetButtonContainer}\\n      type={Button.ButtonTypes.button}\\n    >\\n      Go back\\n    </Button>\\n  );\\n\\n  const Header = (\\n    <>\\n      <Text key=\\\"headerText\\\" iconPrefix={mdiAccountCircleOutline}>\\n        Edit Your Profile\\n      </Text>\\n      <Divider width=\\\"100%\\\" />\\n    </>\\n  );\\n\\n  return (\\n    <>\\n      <Card\\n        elevation={1}\\n        header={Header}\\n        footer={[cancelButton, saveButton]}\\n        StyledFooter={StyledFooter}\\n        StyledBody={StyledBody}\\n      >\\n        <Label\\n          labelText=\\\"First Name\\\"\\n          htmlFor=\\\"firstName\\\"\\n          isValid={state.firstName !== ''}\\n          isRequired\\n          key=\\\"firstName\\\"\\n        >\\n          <TextInput\\n            onChange={createTextInputCallback('firstName')}\\n            value={state.firstName}\\n            isValid={typeof state.firstName !== 'undefined' && state.firstName.length > 0}\\n            errorMessage=\\\"First Name cannot be blank\\\"\\n            id=\\\"firstName\\\"\\n          />\\n        </Label>\\n\\n        <Label labelText=\\\"Last Name\\\" htmlFor=\\\"lastName\\\" key=\\\"lastName\\\">\\n          <TextInput\\n            onChange={createTextInputCallback('lastName')}\\n            value={state.lastName}\\n            id=\\\"lastName\\\"\\n          />\\n        </Label>\\n\\n        <Label\\n          labelText=\\\"Age\\\"\\n          htmlFor=\\\"age\\\"\\n          isRequired\\n          isValid={!!state.age && +state.age > 13}\\n          key=\\\"age\\\"\\n        >\\n          <TextInput\\n            onChange={createTextInputCallback('age')}\\n            value={`${state.age}`}\\n            errorMessage=\\\"Must be 13+\\\"\\n            isValid={!!state.age && +state.age > 13}\\n            id=\\\"age\\\"\\n            type=\\\"number\\\"\\n          />\\n        </Label>\\n\\n        <Label\\n          labelText=\\\"Bio\\\"\\n          htmlFor=\\\"bio\\\"\\n          key=\\\"bio\\\"\\n          isRequired\\n          isValid={!!state.bio && state.bio.length > 30}\\n        >\\n          <TextInput\\n            onChange={createTextInputCallback('bio')}\\n            value={state.bio}\\n            id=\\\"bio\\\"\\n            isValid={!!state.bio && state.bio.length > 30}\\n            errorMessage=\\\"Write a little more\\\"\\n            isMultiline\\n            rows={3}\\n            cols={25}\\n          />\\n        </Label>\\n\\n        <Label labelText=\\\"Title\\\" htmlFor=\\\"title\\\" key=\\\"title\\\">\\n          <TextInput onChange={createTextInputCallback('title')} value={state.title} id=\\\"title\\\" />\\n        </Label>\\n\\n        <Label labelText=\\\"Company\\\" htmlFor=\\\"company\\\" key=\\\"company\\\">\\n          <TextInput\\n            onChange={createTextInputCallback('company')}\\n            value={state.company}\\n            id=\\\"company\\\"\\n          />\\n        </Label>\\n\\n        <Label labelText=\\\"City\\\" htmlFor=\\\"city\\\" key=\\\"city\\\">\\n          <TextInput onChange={createTextInputCallback('city')} value={state.city} id=\\\"city\\\" />\\n        </Label>\\n\\n        <Label labelText=\\\"State\\\" htmlFor=\\\"state\\\" key=\\\"state\\\">\\n          <Dropdown\\n            name=\\\"state-dropdown\\\"\\n            options={stateAbbreviations.map(abr => ({ id: abr, optionValue: abr }))}\\n            color={colors.primaryDark}\\n            values={[state.state]}\\n            searchable\\n            onSelect={val => {\\n              setState({ ...state, state: `${val}` });\\n            }}\\n            variant={variants.fill}\\n          />\\n        </Label>\\n\\n        <Label labelText=\\\"Notifications\\\" htmlFor=\\\"notifications\\\" key=\\\"notifications\\\">\\n          <Toggle\\n            onToggle={() => {\\n              setState({ ...state, notifications: !state.notifications });\\n            }}\\n            checked={state.notifications}\\n            inputProps={{ onChange: () => {} }}\\n            color={state.notifications ? '#8f8' : 'white'}\\n          />\\n          {state.notifications ? '  Enabled' : '  Disabled'}\\n        </Label>\\n      </Card>\\n      {isModalOpen && (\\n        <Modal onClose={closeModal} onClickOutside={closeModal} backgroundDarkness={0.5}>\\n          <Card\\n            elevation={1}\\n            header=\\\"Would you like to continue?\\\"\\n            footer={[abortButton, confirmButton]}\\n          >\\n            You will lose any unsaved changes, are you sure you would like to reset?\\n          </Card>\\n        </Modal>\\n      )}\\n    </>\\n  );\\n}\" }, ...ControlledForm.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from 'react';\\nimport styled from 'styled-components';\\nimport { Story, Meta } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\nimport { FoundryProvider } from '../../context';\\nimport Text from '../Text';\\nimport Card from '../Card';\\nimport Button from '../Button';\\nimport colorsEnum from '../../enums/colors';\\n\\nconst Container = styled.div`\\n  display: flex;\\n  align-items: center;\\n  flex-direction: column;\\n`;\\n\\nconst StyledTextContainer = styled(Text.Container)`\\n  margin-bottom: 1rem;\\n`;\\nconst StyledCardContainer = styled(Card.Container)`\\n  margin-bottom: 1rem;\\n`;\\n\\ninterface ExampleProps {\\n  'font-family': string;\\n  primary: string;\\n  grayDark: string;\\n}\\n\\nexport const Example: Story<ExampleProps> = ({\\n  'font-family': fontFamily,\\n  primary,\\n  grayDark,\\n}: ExampleProps) => {\\n  const globalStyles = `\\n    font-family: ${fontFamily};\\n  `;\\n  const colors = {\\n    primary,\\n    grayDark,\\n  };\\n  const showAnalytics = (\\n    componentType: string,\\n    eventType: string,\\n    eventArgs?: React.ChangeEvent<HTMLInputElement>,\\n    dateTime?: Date,\\n    deviceInfo?: Record<string, unknown>,\\n    currentURL?: string,\\n    props?: any,\\n  ): void => {\\n    action(`${componentType} ${eventType}`)(\\n      componentType,\\n      eventType,\\n      eventArgs,\\n      dateTime,\\n      deviceInfo,\\n      currentURL,\\n      props,\\n    );\\n  };\\n  const styleConstants = {\\n    paddingSmall: '1rem',\\n    paddingLarge: '2rem',\\n  };\\n  return (\\n    <FoundryProvider\\n      value={{ globalStyles, colors, styleConstants, analyticsFunction: showAnalytics }}\\n    >\\n      <Container>\\n        <Text StyledContainer={StyledTextContainer}>Hello!</Text>\\n        <Card StyledContainer={StyledCardContainer} elevation={0} header=\\\"Title\\\">\\n          These components all have a global set of styles applied to them through React's Context\\n          API.\\n        </Card>\\n        <Button onClick={action('click button')}>Example button</Button>\\n      </Container>\\n    </FoundryProvider>\\n  );\\n};\\nExample.args = {\\n  'font-family': 'Arial',\\n  primary: colorsEnum.primary,\\n  grayDark: colorsEnum.grayDark,\\n} as ExampleProps;\\n\\nexport default {\\n  title: 'Global styles',\\n  argTypes: {\\n    'font-family': {\\n      options: ['Arial', 'Times New Roman', 'Monospace', 'unset'],\\n      mapping: {\\n        Arial: 'Arial,Roboto,sans-serif',\\n        'Times New Roman': '\\\"Times New Roman\\\",Times,serif',\\n        Monospace: '\\\"Lucida Console\\\",Courier,monospace',\\n        unset: 'unset',\\n      },\\n      control: {\\n        type: 'radio',\\n      },\\n    },\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Example\":{\"startLoc\":{\"col\":44,\"line\":30},\"endLoc\":{\"col\":1,\"line\":79},\"startBody\":{\"col\":44,\"line\":30},\"endBody\":{\"col\":1,\"line\":79}}};\n    \nimport React from 'react';\nimport styled from 'styled-components';\nimport { Story, Meta } from '@storybook/react';\nimport { action } from '@storybook/addon-actions';\nimport { FoundryProvider } from '../../context';\nimport Text from '../Text';\nimport Card from '../Card';\nimport Button from '../Button';\nimport colorsEnum from '../../enums/colors';\n\nconst Container = styled.div`\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n`;\n\nconst StyledTextContainer = styled(Text.Container)`\n  margin-bottom: 1rem;\n`;\nconst StyledCardContainer = styled(Card.Container)`\n  margin-bottom: 1rem;\n`;\n\ninterface ExampleProps {\n  'font-family': string;\n  primary: string;\n  grayDark: string;\n}\n\nexport const Example: Story<ExampleProps> = ({\n  'font-family': fontFamily,\n  primary,\n  grayDark,\n}: ExampleProps) => {\n  const globalStyles = `\n    font-family: ${fontFamily};\n  `;\n  const colors = {\n    primary,\n    grayDark,\n  };\n  const showAnalytics = (\n    componentType: string,\n    eventType: string,\n    eventArgs?: React.ChangeEvent<HTMLInputElement>,\n    dateTime?: Date,\n    deviceInfo?: Record<string, unknown>,\n    currentURL?: string,\n    props?: any,\n  ): void => {\n    action(`${componentType} ${eventType}`)(\n      componentType,\n      eventType,\n      eventArgs,\n      dateTime,\n      deviceInfo,\n      currentURL,\n      props,\n    );\n  };\n  const styleConstants = {\n    paddingSmall: '1rem',\n    paddingLarge: '2rem',\n  };\n  return (\n    <FoundryProvider\n      value={{ globalStyles, colors, styleConstants, analyticsFunction: showAnalytics }}\n    >\n      <Container>\n        <Text StyledContainer={StyledTextContainer}>Hello!</Text>\n        <Card StyledContainer={StyledCardContainer} elevation={0} header=\"Title\">\n          These components all have a global set of styles applied to them through React's Context\n          API.\n        </Card>\n        <Button onClick={action('click button')}>Example button</Button>\n      </Container>\n    </FoundryProvider>\n  );\n};\nExample.args = {\n  'font-family': 'Arial',\n  primary: colorsEnum.primary,\n  grayDark: colorsEnum.grayDark,\n} as ExampleProps;\n\nexport default {\n  title: 'Global styles',\n  argTypes: {\n    'font-family': {\n      options: ['Arial', 'Times New Roman', 'Monospace', 'unset'],\n      mapping: {\n        Arial: 'Arial,Roboto,sans-serif',\n        'Times New Roman': '\"Times New Roman\",Times,serif',\n        Monospace: '\"Lucida Console\",Courier,monospace',\n        unset: 'unset',\n      },\n      control: {\n        type: 'radio',\n      },\n    },\n  },\n} as Meta;\n\n\n\nExample.parameters = { storySource: { source: \"({\\n  'font-family': fontFamily,\\n  primary,\\n  grayDark,\\n}: ExampleProps) => {\\n  const globalStyles = `\\n    font-family: ${fontFamily};\\n  `;\\n  const colors = {\\n    primary,\\n    grayDark,\\n  };\\n  const showAnalytics = (\\n    componentType: string,\\n    eventType: string,\\n    eventArgs?: React.ChangeEvent<HTMLInputElement>,\\n    dateTime?: Date,\\n    deviceInfo?: Record<string, unknown>,\\n    currentURL?: string,\\n    props?: any,\\n  ): void => {\\n    action(`${componentType} ${eventType}`)(\\n      componentType,\\n      eventType,\\n      eventArgs,\\n      dateTime,\\n      deviceInfo,\\n      currentURL,\\n      props,\\n    );\\n  };\\n  const styleConstants = {\\n    paddingSmall: '1rem',\\n    paddingLarge: '2rem',\\n  };\\n  return (\\n    <FoundryProvider\\n      value={{ globalStyles, colors, styleConstants, analyticsFunction: showAnalytics }}\\n    >\\n      <Container>\\n        <Text StyledContainer={StyledTextContainer}>Hello!</Text>\\n        <Card StyledContainer={StyledCardContainer} elevation={0} header=\\\"Title\\\">\\n          These components all have a global set of styles applied to them through React's Context\\n          API.\\n        </Card>\\n        <Button onClick={action('click button')}>Example button</Button>\\n      </Container>\\n    </FoundryProvider>\\n  );\\n}\" }, ...Example.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from 'react';\\nimport styled from 'styled-components';\\nimport { Story, Meta } from '@storybook/react';\\nimport { action } from '@storybook/addon-actions';\\n\\nimport InteractionFeedback from './InteractionFeedback';\\nimport colors from '../../enums/colors';\\nimport Text from '../Text';\\n\\nconst InteractionInnerContainer = styled.div`\\n  height: 100vh;\\n  width: 100vw;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n`;\\n\\ninterface SplashProps {\\n  entranceOpacity: number;\\n  exitOpacity: number;\\n  startingRadius: number;\\n  endingRadius: number;\\n  mass: number;\\n  tension: number;\\n  friction: number;\\n  clamp: boolean;\\n  color: string;\\n}\\n\\nexport const Splash: Story<SplashProps> = ({\\n  startingRadius,\\n  entranceOpacity,\\n  endingRadius,\\n  exitOpacity,\\n  mass,\\n  tension,\\n  friction,\\n  clamp,\\n  color,\\n}: SplashProps) => {\\n  const transitionProps = {\\n    from: {\\n      r: `${startingRadius}`,\\n      opacity: entranceOpacity,\\n    },\\n    enter: {\\n      r: `${endingRadius}`,\\n      opacity: exitOpacity,\\n    },\\n    config: {\\n      mass,\\n      tension,\\n      friction,\\n      clamp,\\n    },\\n  };\\n  const interpolationFunctions = {\\n    r: (r: any) => r.to((val: string) => `${Math.abs(parseFloat(val)).toFixed(1)}`),\\n    opacity: (opacity: any) => opacity.to((val: number) => val.toFixed(2)),\\n  };\\n  return (\\n    <InteractionFeedback\\n      color={color}\\n      interpolationFunctions={interpolationFunctions}\\n      transitionProps={transitionProps}\\n    >\\n      <InteractionInnerContainer onClick={action('button-click')}>\\n        <Text>Click Anywhere!</Text>\\n      </InteractionInnerContainer>\\n    </InteractionFeedback>\\n  );\\n};\\nSplash.args = {\\n  entranceOpacity: 0.5,\\n  exitOpacity: 0,\\n  startingRadius: 0,\\n  endingRadius: 100,\\n  mass: 90,\\n  tension: 1000,\\n  friction: 20,\\n  clamp: true,\\n  color: colors.grayDark,\\n} as SplashProps;\\n\\nexport default {\\n  title: 'InteractionFeedback',\\n  argTypes: {\\n    entranceOpacity: {\\n      control: { type: 'range', min: 0, max: 1, step: 0.05, label: 'Circle entrance opacity' },\\n    },\\n    exitOpacity: {\\n      control: { type: 'range', min: 0, max: 1, step: 0.05, label: 'Circle exit opacity' },\\n    },\\n    startingRadius: {\\n      control: { type: 'range', min: 0, max: 100, step: 1, label: 'Starting circle radius' },\\n    },\\n    endingRadius: {\\n      control: { type: 'range', min: 0, max: 100, step: 1, label: 'Ending circle radius' },\\n    },\\n    mass: { control: { type: 'range', min: 1, max: 100, step: 1 } },\\n    tension: { control: { type: 'range', min: 50, max: 1000, step: 50 } },\\n    friction: { control: { type: 'range', min: 1, max: 100, step: 1 } },\\n  },\\n  parameters: {\\n    design: {\\n      type: 'figma',\\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=102%3A88',\\n    },\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Splash\":{\"startLoc\":{\"col\":42,\"line\":30},\"endLoc\":{\"col\":1,\"line\":72},\"startBody\":{\"col\":42,\"line\":30},\"endBody\":{\"col\":1,\"line\":72}}};\n    \nimport React from 'react';\nimport styled from 'styled-components';\nimport { Story, Meta } from '@storybook/react';\nimport { action } from '@storybook/addon-actions';\n\nimport InteractionFeedback from './InteractionFeedback';\nimport colors from '../../enums/colors';\nimport Text from '../Text';\n\nconst InteractionInnerContainer = styled.div`\n  height: 100vh;\n  width: 100vw;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n`;\n\ninterface SplashProps {\n  entranceOpacity: number;\n  exitOpacity: number;\n  startingRadius: number;\n  endingRadius: number;\n  mass: number;\n  tension: number;\n  friction: number;\n  clamp: boolean;\n  color: string;\n}\n\nexport const Splash: Story<SplashProps> = ({\n  startingRadius,\n  entranceOpacity,\n  endingRadius,\n  exitOpacity,\n  mass,\n  tension,\n  friction,\n  clamp,\n  color,\n}: SplashProps) => {\n  const transitionProps = {\n    from: {\n      r: `${startingRadius}`,\n      opacity: entranceOpacity,\n    },\n    enter: {\n      r: `${endingRadius}`,\n      opacity: exitOpacity,\n    },\n    config: {\n      mass,\n      tension,\n      friction,\n      clamp,\n    },\n  };\n  const interpolationFunctions = {\n    r: (r: any) => r.to((val: string) => `${Math.abs(parseFloat(val)).toFixed(1)}`),\n    opacity: (opacity: any) => opacity.to((val: number) => val.toFixed(2)),\n  };\n  return (\n    <InteractionFeedback\n      color={color}\n      interpolationFunctions={interpolationFunctions}\n      transitionProps={transitionProps}\n    >\n      <InteractionInnerContainer onClick={action('button-click')}>\n        <Text>Click Anywhere!</Text>\n      </InteractionInnerContainer>\n    </InteractionFeedback>\n  );\n};\nSplash.args = {\n  entranceOpacity: 0.5,\n  exitOpacity: 0,\n  startingRadius: 0,\n  endingRadius: 100,\n  mass: 90,\n  tension: 1000,\n  friction: 20,\n  clamp: true,\n  color: colors.grayDark,\n} as SplashProps;\n\nexport default {\n  title: 'InteractionFeedback',\n  argTypes: {\n    entranceOpacity: {\n      control: { type: 'range', min: 0, max: 1, step: 0.05, label: 'Circle entrance opacity' },\n    },\n    exitOpacity: {\n      control: { type: 'range', min: 0, max: 1, step: 0.05, label: 'Circle exit opacity' },\n    },\n    startingRadius: {\n      control: { type: 'range', min: 0, max: 100, step: 1, label: 'Starting circle radius' },\n    },\n    endingRadius: {\n      control: { type: 'range', min: 0, max: 100, step: 1, label: 'Ending circle radius' },\n    },\n    mass: { control: { type: 'range', min: 1, max: 100, step: 1 } },\n    tension: { control: { type: 'range', min: 50, max: 1000, step: 50 } },\n    friction: { control: { type: 'range', min: 1, max: 100, step: 1 } },\n  },\n  parameters: {\n    design: {\n      type: 'figma',\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=102%3A88',\n    },\n  },\n} as Meta;\n\n\n\nSplash.parameters = { storySource: { source: \"({\\n  startingRadius,\\n  entranceOpacity,\\n  endingRadius,\\n  exitOpacity,\\n  mass,\\n  tension,\\n  friction,\\n  clamp,\\n  color,\\n}: SplashProps) => {\\n  const transitionProps = {\\n    from: {\\n      r: `${startingRadius}`,\\n      opacity: entranceOpacity,\\n    },\\n    enter: {\\n      r: `${endingRadius}`,\\n      opacity: exitOpacity,\\n    },\\n    config: {\\n      mass,\\n      tension,\\n      friction,\\n      clamp,\\n    },\\n  };\\n  const interpolationFunctions = {\\n    r: (r: any) => r.to((val: string) => `${Math.abs(parseFloat(val)).toFixed(1)}`),\\n    opacity: (opacity: any) => opacity.to((val: number) => val.toFixed(2)),\\n  };\\n  return (\\n    <InteractionFeedback\\n      color={color}\\n      interpolationFunctions={interpolationFunctions}\\n      transitionProps={transitionProps}\\n    >\\n      <InteractionInnerContainer onClick={action('button-click')}>\\n        <Text>Click Anywhere!</Text>\\n      </InteractionInnerContainer>\\n    </InteractionFeedback>\\n  );\\n}\" }, ...Splash.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React, { useCallback, useRef, useState } from 'react';\\nimport styled from 'styled-components';\\nimport { Story, Meta } from '@storybook/react';\\n\\nimport colors from '../../enums/colors';\\nimport Modal, { ModalProps, ModalApi } from './Modal';\\nimport Button from '../Button/Button';\\nimport Card from '../Card';\\nimport { withFoundryContext } from '../../../.storybook/decorators';\\n\\nconst Background = styled.div`\\n  background-image: url(https://source.unsplash.com/weekly?landscape);\\n  background-size: cover;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n\\n  height: 100vh;\\n  width: 100vw;\\n`;\\n\\ntype DefaultProps = Omit<ModalProps, 'backgroundBlur'> & {\\n  backgroundBlur: number;\\n  'onClickOutside function': boolean;\\n  onClose: () => void;\\n};\\n\\nexport const Default: Story<DefaultProps> = ({\\n  backgroundBlur,\\n  'onClickOutside function': onClickOutside,\\n  onClose,\\n  ...args\\n}: DefaultProps) => {\\n  const [isOpen, setIsOpen] = useState(true);\\n\\n  const handleClose = () => {\\n    setIsOpen(false);\\n    onClose();\\n  };\\n\\n  const modalRef = useRef<ModalApi>();\\n\\n  const customCloseButtonClick = useCallback(() => {\\n    if (modalRef.current) {\\n      modalRef.current.close();\\n    }\\n  }, [modalRef]);\\n\\n  return (\\n    <Background>\\n      <Card elevation={1} header=\\\"Use this button to open the modal again\\\">\\n        <Button\\n          color={colors.primaryDark}\\n          StyledContainer={Button.Container}\\n          onClick={() => setIsOpen(true)}\\n        >\\n          Open modal\\n        </Button>\\n      </Card>\\n      {isOpen && (\\n        <Modal\\n          {...args}\\n          backgroundBlur={`${backgroundBlur}rem`}\\n          onClickOutside={onClickOutside ? handleClose : undefined}\\n          onClose={handleClose}\\n          ref={modalRef}\\n        >\\n          <Card\\n            header=\\\"Hello world!\\\"\\n            footer={\\n              <Button color={colors.primaryDark} onClick={customCloseButtonClick}>\\n                Okay...\\n              </Button>\\n            }\\n            elevation={1}\\n          >\\n            The content of the modal (the card and everything inside it) is customizable. The close\\n            &times; is built-in but can be easily overwritten. It is the very model of a modern\\n            major React modal.\\n          </Card>\\n        </Modal>\\n      )}\\n    </Background>\\n  );\\n};\\nDefault.args = {\\n  closeButtonAttachment: 'inside',\\n  backgroundDarkness: 0.5,\\n  backgroundBlur: 0.5,\\n  'onClickOutside function': true,\\n};\\n\\nexport default {\\n  title: 'Modal',\\n  component: Modal,\\n  argTypes: {\\n    closeButtonAttachment: {\\n      options: ['inside', 'outside', 'corner'],\\n      control: {\\n        type: 'select',\\n      },\\n    },\\n    backgroundDarkness: {\\n      control: { type: 'range', min: 0, max: 1, step: 0.05 },\\n    },\\n    backgroundBlur: {\\n      control: { type: 'range', min: 0, max: 5, step: 0.1 },\\n    },\\n  },\\n  decorators: [withFoundryContext],\\n  parameters: {\\n    layout: 'fullscreen',\\n    design: {\\n      type: 'figma',\\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=102%3A14',\\n    },\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Default\":{\"startLoc\":{\"col\":44,\"line\":28},\"endLoc\":{\"col\":1,\"line\":85},\"startBody\":{\"col\":44,\"line\":28},\"endBody\":{\"col\":1,\"line\":85}}};\n    \nimport React, { useCallback, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport { Story, Meta } from '@storybook/react';\n\nimport colors from '../../enums/colors';\nimport Modal, { ModalProps, ModalApi } from './Modal';\nimport Button from '../Button/Button';\nimport Card from '../Card';\nimport { withFoundryContext } from '../../../.storybook/decorators';\n\nconst Background = styled.div`\n  background-image: url(https://source.unsplash.com/weekly?landscape);\n  background-size: cover;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  height: 100vh;\n  width: 100vw;\n`;\n\ntype DefaultProps = Omit<ModalProps, 'backgroundBlur'> & {\n  backgroundBlur: number;\n  'onClickOutside function': boolean;\n  onClose: () => void;\n};\n\nexport const Default: Story<DefaultProps> = ({\n  backgroundBlur,\n  'onClickOutside function': onClickOutside,\n  onClose,\n  ...args\n}: DefaultProps) => {\n  const [isOpen, setIsOpen] = useState(true);\n\n  const handleClose = () => {\n    setIsOpen(false);\n    onClose();\n  };\n\n  const modalRef = useRef<ModalApi>();\n\n  const customCloseButtonClick = useCallback(() => {\n    if (modalRef.current) {\n      modalRef.current.close();\n    }\n  }, [modalRef]);\n\n  return (\n    <Background>\n      <Card elevation={1} header=\"Use this button to open the modal again\">\n        <Button\n          color={colors.primaryDark}\n          StyledContainer={Button.Container}\n          onClick={() => setIsOpen(true)}\n        >\n          Open modal\n        </Button>\n      </Card>\n      {isOpen && (\n        <Modal\n          {...args}\n          backgroundBlur={`${backgroundBlur}rem`}\n          onClickOutside={onClickOutside ? handleClose : undefined}\n          onClose={handleClose}\n          ref={modalRef}\n        >\n          <Card\n            header=\"Hello world!\"\n            footer={\n              <Button color={colors.primaryDark} onClick={customCloseButtonClick}>\n                Okay...\n              </Button>\n            }\n            elevation={1}\n          >\n            The content of the modal (the card and everything inside it) is customizable. The close\n            &times; is built-in but can be easily overwritten. It is the very model of a modern\n            major React modal.\n          </Card>\n        </Modal>\n      )}\n    </Background>\n  );\n};\nDefault.args = {\n  closeButtonAttachment: 'inside',\n  backgroundDarkness: 0.5,\n  backgroundBlur: 0.5,\n  'onClickOutside function': true,\n};\n\nexport default {\n  title: 'Modal',\n  component: Modal,\n  argTypes: {\n    closeButtonAttachment: {\n      options: ['inside', 'outside', 'corner'],\n      control: {\n        type: 'select',\n      },\n    },\n    backgroundDarkness: {\n      control: { type: 'range', min: 0, max: 1, step: 0.05 },\n    },\n    backgroundBlur: {\n      control: { type: 'range', min: 0, max: 5, step: 0.1 },\n    },\n  },\n  decorators: [withFoundryContext],\n  parameters: {\n    layout: 'fullscreen',\n    design: {\n      type: 'figma',\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=102%3A14',\n    },\n  },\n} as Meta;\n\n\n\nDefault.parameters = { storySource: { source: \"({\\n  backgroundBlur,\\n  'onClickOutside function': onClickOutside,\\n  onClose,\\n  ...args\\n}: DefaultProps) => {\\n  const [isOpen, setIsOpen] = useState(true);\\n\\n  const handleClose = () => {\\n    setIsOpen(false);\\n    onClose();\\n  };\\n\\n  const modalRef = useRef<ModalApi>();\\n\\n  const customCloseButtonClick = useCallback(() => {\\n    if (modalRef.current) {\\n      modalRef.current.close();\\n    }\\n  }, [modalRef]);\\n\\n  return (\\n    <Background>\\n      <Card elevation={1} header=\\\"Use this button to open the modal again\\\">\\n        <Button\\n          color={colors.primaryDark}\\n          StyledContainer={Button.Container}\\n          onClick={() => setIsOpen(true)}\\n        >\\n          Open modal\\n        </Button>\\n      </Card>\\n      {isOpen && (\\n        <Modal\\n          {...args}\\n          backgroundBlur={`${backgroundBlur}rem`}\\n          onClickOutside={onClickOutside ? handleClose : undefined}\\n          onClose={handleClose}\\n          ref={modalRef}\\n        >\\n          <Card\\n            header=\\\"Hello world!\\\"\\n            footer={\\n              <Button color={colors.primaryDark} onClick={customCloseButtonClick}>\\n                Okay...\\n              </Button>\\n            }\\n            elevation={1}\\n          >\\n            The content of the modal (the card and everything inside it) is customizable. The close\\n            &times; is built-in but can be easily overwritten. It is the very model of a modern\\n            major React modal.\\n          </Card>\\n        </Modal>\\n      )}\\n    </Background>\\n  );\\n}\" }, ...Default.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React, { useState, useEffect, forwardRef } from 'react';\\nimport styled from 'styled-components';\\nimport { Story, Meta } from '@storybook/react';\\nimport { readableColor, toColorString } from 'polished';\\n\\nimport { action } from '@storybook/addon-actions';\\nimport { withFoundryContext } from '../../../.storybook/decorators';\\nimport fonts from '../../enums/fonts';\\nimport colors from '../../enums/colors';\\nimport RangeSlider, { SlideRail } from './RangeSlider';\\nimport { RangeSliderProps, ValueProp } from './types';\\n\\nimport Card from '../Card';\\n\\nconst Row = styled.div`\\n  ${fonts.body}\\n  display: flex;\\n  flex-flow: row nowrap;\\n  align-items: center;\\n  padding: 0.5em;\\n  min-width: 20em;\\n  width: 90%;\\n  margin: 0 auto;\\n`;\\n\\nconst ColorPreview = styled.div`\\n  ${fonts.body}\\n\\n  height: 12rem;\\n  width: 34rem;\\n  transition: color 0.5s;\\n  font-size: 5rem;\\n  display: flex;\\n  justify-content: center;\\n  align-items: center;\\n  text-transform: uppercase;\\n  font-weight: 900;\\n`;\\n\\nconst skillLabels = [\\n  'WhatJS?',\\n  \\\"I've used it...\\\",\\n  \\\"We're aight\\\",\\n  'I love it',\\n  'I dream in React',\\n  'I am React',\\n];\\n\\nconst skillColors = ['red', 'orangered', 'orange', 'goldenrod', 'yellowgreen', 'forestgreen'];\\n\\nconst StyledSlideRail = styled(SlideRail)`\\n  filter: grayscale(0.5) brightness(1.3);\\n  border: 0.5px solid ${colors.grayLight};\\n  height: 0.5em;\\n  border-radius: 0.25rem;\\n  background-image: linear-gradient(to right, ${skillColors.join(', ')});\\n`;\\n\\ntype DefaultProps = Omit<RangeSliderProps, 'markers'> & {\\n  value: number;\\n  'use marker labels': boolean;\\n  markers: string;\\n};\\n\\nexport const Default: Story<DefaultProps> = ({\\n  value,\\n  markers,\\n  'use marker labels': markerLabels,\\n  disabled,\\n  showDomainLabels,\\n  showSelectedRange,\\n  min,\\n  max,\\n  dragHandleAttachment,\\n  readonly,\\n  debounceInterval,\\n  animated,\\n}: DefaultProps) => {\\n  const [val, setVal] = useState(value);\\n\\n  useEffect(() => {\\n    setVal(value);\\n  }, [value]);\\n\\n  const markersSelection = markers;\\n  const markersArray: Array<number | ValueProp> = [];\\n  if (markersSelection === 'all values') {\\n    for (let i = min; i <= max; i++) {\\n      markersArray.push(markerLabels ? { value: i, label: `${i}` } : i);\\n    }\\n  } else if (markersSelection === 'middle value') {\\n    const midpoint = (min + max) / 2;\\n    markersArray.push(markerLabels ? { value: midpoint, label: `${midpoint}` } : midpoint);\\n  }\\n\\n  return (\\n    <Row>\\n      <RangeSlider\\n        disabled={disabled}\\n        readonly={readonly}\\n        showDomainLabels={showDomainLabels}\\n        showSelectedRange={showSelectedRange}\\n        animated={animated}\\n        min={min}\\n        max={max}\\n        debounceInterval={debounceInterval}\\n        onChange={newVal => {\\n          action('onChange')(newVal);\\n          setVal(Math.round(newVal));\\n        }}\\n        dragHandleAttachment={dragHandleAttachment}\\n        values={[{ value: val, label: val }]}\\n        markers={markersArray as RangeSliderProps['markers']}\\n      />\\n    </Row>\\n  );\\n};\\nDefault.args = {\\n  value: 1,\\n  min: 0,\\n  max: 5,\\n  markers: 'none',\\n  'use marker labels': false,\\n  disabled: false,\\n  readonly: false,\\n  showDomainLabels: false,\\n  showHandleLabels: true,\\n  showSelectedRange: true,\\n  dragHandleAttachment: 'value',\\n  debounceInterval: 10,\\n  animated: true,\\n};\\n\\ntype RatingProps = Omit<RangeSliderProps, 'markers'> & {\\n  value: number;\\n};\\n\\nexport const Rating: Story<RatingProps> = ({\\n  value,\\n  disabled,\\n  showDomainLabels,\\n  showSelectedRange,\\n  min,\\n  max,\\n}: RatingProps) => {\\n  const [val, setVal] = useState(value);\\n\\n  return (\\n    <Row>\\n      <span>ReactJS:&nbsp;&nbsp;&nbsp;&nbsp;</span>\\n      <RangeSlider\\n        StyledSlideRail={StyledSlideRail}\\n        disabled={disabled}\\n        showDomainLabels={showDomainLabels}\\n        showSelectedRange={showSelectedRange}\\n        min={min}\\n        max={max}\\n        onChange={newVal => {\\n          action('onChange')(newVal);\\n          setVal(Math.round(newVal));\\n        }}\\n        values={[\\n          {\\n            value: val,\\n            label: skillLabels[Math.round(val)],\\n            color: skillColors[Math.round(val)],\\n          },\\n        ]}\\n      />\\n    </Row>\\n  );\\n};\\nRating.args = {\\n  value: 0,\\n  disabled: false,\\n  showDomainLabels: false,\\n  showSelectedRange: false,\\n  min: 0,\\n  max: 5,\\n};\\n\\ninterface ColorPickerProps {\\n  hue: number;\\n  lightness: number;\\n  saturation: number;\\n  disabled: boolean;\\n  showDomainLabels: boolean;\\n  debounceInterval: number;\\n}\\n\\nexport const ColorPicker: Story<ColorPickerProps> = ({\\n  hue,\\n  lightness,\\n  saturation,\\n  disabled,\\n  showDomainLabels,\\n  debounceInterval,\\n}: ColorPickerProps) => {\\n  const [hue_, setHue] = useState(hue);\\n  const [sat, setSat] = useState(saturation);\\n  const [light, setLight] = useState(lightness);\\n\\n  useEffect(() => {\\n    setHue(hue_);\\n  }, [hue_]);\\n\\n  useEffect(() => {\\n    setSat(saturation);\\n  }, [saturation]);\\n\\n  useEffect(() => {\\n    setLight(lightness);\\n  }, [lightness]);\\n\\n  const allHues = Array.from({ length: 360 }, (_, i) => i).map(\\n    num => `hsl(${num}, ${sat}%, ${light}%)`,\\n  );\\n  const allSats = [`hsl(${hue_}, 0%, ${light}%)`, `hsl(${hue_}, 100%, ${light}%`];\\n  const allLights = [`hsl(${hue_}, ${sat}%, 10%)`, `hsl(${hue_}, ${sat}%, 90%)`];\\n\\n  return (\\n    <Card\\n      elevation={2}\\n      StyledHeader={Card.NoPaddingHeader}\\n      header={\\n        <ColorPreview\\n          style={{\\n            backgroundColor: `hsl(${hue_},${sat}%,${light}%)`,\\n            color: readableColor(`hsl(${hue_},${sat}%,${light}%)`),\\n          }}\\n        >\\n          {toColorString({\\n            hue: hue_,\\n            saturation: sat / 100,\\n            lightness: light / 100,\\n          })}\\n        </ColorPreview>\\n      }\\n    >\\n      <Row>\\n        <span>H:&nbsp;&nbsp;&nbsp;</span>\\n        <RangeSlider\\n          StyledSlideRail={forwardRef((props, ref) => (\\n            <SlideRail\\n              ref={ref as React.RefObject<HTMLDivElement>}\\n              {...props}\\n              style={{\\n                backgroundImage: `linear-gradient(to right, ${allHues.join(', ')})`,\\n              }}\\n            />\\n          ))}\\n          disabled={disabled}\\n          showDomainLabels={showDomainLabels}\\n          showSelectedRange={false}\\n          min={0}\\n          max={360}\\n          debounceInterval={debounceInterval}\\n          onDebounceChange={val => {\\n            action('onDebounceChange hue')(val);\\n            setHue(Math.round(val));\\n          }}\\n          values={[\\n            {\\n              value: hue_,\\n              label: hue_,\\n              color: colors.grayLight,\\n            },\\n          ]}\\n        />\\n      </Row>\\n      <Row>\\n        <span>S:&nbsp;&nbsp;&nbsp;</span>\\n        <RangeSlider\\n          StyledSlideRail={forwardRef((props, ref) => (\\n            <SlideRail\\n              ref={ref as React.RefObject<HTMLDivElement>}\\n              {...props}\\n              style={{\\n                backgroundImage: `linear-gradient(to right, ${allSats.join(', ')})`,\\n              }}\\n            />\\n          ))}\\n          min={0}\\n          max={100}\\n          debounceInterval={debounceInterval}\\n          onDebounceChange={val => {\\n            action('onDebounceChange saturation')(val);\\n            setSat(Math.round(val));\\n          }}\\n          showDomainLabels={false}\\n          showSelectedRange={false}\\n          values={[\\n            {\\n              value: sat,\\n              label: sat,\\n              color: colors.grayLight,\\n            },\\n          ]}\\n        />\\n      </Row>\\n      <Row>\\n        <span>L:&nbsp;&nbsp;&nbsp;</span>\\n        <RangeSlider\\n          StyledSlideRail={forwardRef((props, ref) => (\\n            <SlideRail\\n              \\n              // @ts-ignore\\n              ref={ref}\\n              {...props}\\n              style={{\\n                backgroundImage: `linear-gradient(to right, ${allLights.join(', ')})`,\\n              }}\\n            />\\n          ))}\\n          min={0}\\n          max={100}\\n          debounceInterval={debounceInterval}\\n          onDebounceChange={val => {\\n            action('onDebounceChange lightness')(val);\\n            setLight(Math.round(val));\\n          }}\\n          showDomainLabels={false}\\n          showSelectedRange={false}\\n          values={[\\n            {\\n              value: light,\\n              label: light,\\n              color: colors.grayLight,\\n            },\\n          ]}\\n        />\\n      </Row>\\n    </Card>\\n  );\\n};\\nColorPicker.args = {\\n  hue: 0,\\n  saturation: 50,\\n  lightness: 50,\\n  disabled: false,\\n  showDomainLabels: false,\\n  debounceInterval: 10,\\n};\\n\\nexport default {\\n  title: 'RangeSlider',\\n  argTypes: {\\n    value: {\\n      control: {\\n        type: 'range',\\n        min: 0,\\n        max: 5,\\n        step: 1,\\n      },\\n    },\\n    min: {\\n      control: { type: 'range', min: -10, max: 10, step: 1 },\\n    },\\n    max: {\\n      control: {\\n        type: 'range',\\n        min: -10,\\n        max: 10,\\n        step: 1,\\n      },\\n    },\\n    debounceInterval: {\\n      control: {\\n        type: 'range',\\n        min: 0,\\n        max: 100,\\n        step: 1,\\n      },\\n    },\\n    markers: {\\n      options: ['none', 'all values', 'middle value'],\\n      control: {\\n        type: 'radio',\\n      },\\n    },\\n    hue: {\\n      control: {\\n        type: 'range',\\n        min: 0,\\n        max: 360,\\n        step: 1,\\n      },\\n    },\\n    saturation: {\\n      control: {\\n        type: 'range',\\n        min: 0,\\n        max: 100,\\n        step: 1,\\n      },\\n    },\\n    lightness: {\\n      control: {\\n        type: 'range',\\n        min: 0,\\n        max: 100,\\n        step: 1,\\n      },\\n    },\\n    dragHandleAttachment: {\\n      control: {\\n        type: 'radio',\\n      },\\n      options: ['mouse', 'value'],\\n    },\\n  },\\n  decorators: [withFoundryContext],\\n  parameters: {\\n    design: {\\n      type: 'figma',\\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=126%3A2',\\n    },\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Default\":{\"startLoc\":{\"col\":44,\"line\":65},\"endLoc\":{\"col\":1,\"line\":117},\"startBody\":{\"col\":44,\"line\":65},\"endBody\":{\"col\":1,\"line\":117}},\"Rating\":{\"startLoc\":{\"col\":42,\"line\":138},\"endLoc\":{\"col\":1,\"line\":172},\"startBody\":{\"col\":42,\"line\":138},\"endBody\":{\"col\":1,\"line\":172}},\"ColorPicker\":{\"startLoc\":{\"col\":52,\"line\":191},\"endLoc\":{\"col\":1,\"line\":335},\"startBody\":{\"col\":52,\"line\":191},\"endBody\":{\"col\":1,\"line\":335}}};\n    \nimport React, { useState, useEffect, forwardRef } from 'react';\nimport styled from 'styled-components';\nimport { Story, Meta } from '@storybook/react';\nimport { readableColor, toColorString } from 'polished';\n\nimport { action } from '@storybook/addon-actions';\nimport { withFoundryContext } from '../../../.storybook/decorators';\nimport fonts from '../../enums/fonts';\nimport colors from '../../enums/colors';\nimport RangeSlider, { SlideRail } from './RangeSlider';\nimport { RangeSliderProps, ValueProp } from './types';\n\nimport Card from '../Card';\n\nconst Row = styled.div`\n  ${fonts.body}\n  display: flex;\n  flex-flow: row nowrap;\n  align-items: center;\n  padding: 0.5em;\n  min-width: 20em;\n  width: 90%;\n  margin: 0 auto;\n`;\n\nconst ColorPreview = styled.div`\n  ${fonts.body}\n\n  height: 12rem;\n  width: 34rem;\n  transition: color 0.5s;\n  font-size: 5rem;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  text-transform: uppercase;\n  font-weight: 900;\n`;\n\nconst skillLabels = [\n  'WhatJS?',\n  \"I've used it...\",\n  \"We're aight\",\n  'I love it',\n  'I dream in React',\n  'I am React',\n];\n\nconst skillColors = ['red', 'orangered', 'orange', 'goldenrod', 'yellowgreen', 'forestgreen'];\n\nconst StyledSlideRail = styled(SlideRail)`\n  filter: grayscale(0.5) brightness(1.3);\n  border: 0.5px solid ${colors.grayLight};\n  height: 0.5em;\n  border-radius: 0.25rem;\n  background-image: linear-gradient(to right, ${skillColors.join(', ')});\n`;\n\ntype DefaultProps = Omit<RangeSliderProps, 'markers'> & {\n  value: number;\n  'use marker labels': boolean;\n  markers: string;\n};\n\nexport const Default: Story<DefaultProps> = ({\n  value,\n  markers,\n  'use marker labels': markerLabels,\n  disabled,\n  showDomainLabels,\n  showSelectedRange,\n  min,\n  max,\n  dragHandleAttachment,\n  readonly,\n  debounceInterval,\n  animated,\n}: DefaultProps) => {\n  const [val, setVal] = useState(value);\n\n  useEffect(() => {\n    setVal(value);\n  }, [value]);\n\n  const markersSelection = markers;\n  const markersArray: Array<number | ValueProp> = [];\n  if (markersSelection === 'all values') {\n    for (let i = min; i <= max; i++) {\n      markersArray.push(markerLabels ? { value: i, label: `${i}` } : i);\n    }\n  } else if (markersSelection === 'middle value') {\n    const midpoint = (min + max) / 2;\n    markersArray.push(markerLabels ? { value: midpoint, label: `${midpoint}` } : midpoint);\n  }\n\n  return (\n    <Row>\n      <RangeSlider\n        disabled={disabled}\n        readonly={readonly}\n        showDomainLabels={showDomainLabels}\n        showSelectedRange={showSelectedRange}\n        animated={animated}\n        min={min}\n        max={max}\n        debounceInterval={debounceInterval}\n        onChange={newVal => {\n          action('onChange')(newVal);\n          setVal(Math.round(newVal));\n        }}\n        dragHandleAttachment={dragHandleAttachment}\n        values={[{ value: val, label: val }]}\n        markers={markersArray as RangeSliderProps['markers']}\n      />\n    </Row>\n  );\n};;\nDefault.args = {\n  value: 1,\n  min: 0,\n  max: 5,\n  markers: 'none',\n  'use marker labels': false,\n  disabled: false,\n  readonly: false,\n  showDomainLabels: false,\n  showHandleLabels: true,\n  showSelectedRange: true,\n  dragHandleAttachment: 'value',\n  debounceInterval: 10,\n  animated: true,\n};\n\ntype RatingProps = Omit<RangeSliderProps, 'markers'> & {\n  value: number;\n};\n\nexport const Rating: Story<RatingProps> = ({\n  value,\n  disabled,\n  showDomainLabels,\n  showSelectedRange,\n  min,\n  max,\n}: RatingProps) => {\n  const [val, setVal] = useState(value);\n\n  return (\n    <Row>\n      <span>ReactJS:&nbsp;&nbsp;&nbsp;&nbsp;</span>\n      <RangeSlider\n        StyledSlideRail={StyledSlideRail}\n        disabled={disabled}\n        showDomainLabels={showDomainLabels}\n        showSelectedRange={showSelectedRange}\n        min={min}\n        max={max}\n        onChange={newVal => {\n          action('onChange')(newVal);\n          setVal(Math.round(newVal));\n        }}\n        values={[\n          {\n            value: val,\n            label: skillLabels[Math.round(val)],\n            color: skillColors[Math.round(val)],\n          },\n        ]}\n      />\n    </Row>\n  );\n};;\nRating.args = {\n  value: 0,\n  disabled: false,\n  showDomainLabels: false,\n  showSelectedRange: false,\n  min: 0,\n  max: 5,\n};\n\ninterface ColorPickerProps {\n  hue: number;\n  lightness: number;\n  saturation: number;\n  disabled: boolean;\n  showDomainLabels: boolean;\n  debounceInterval: number;\n}\n\nexport const ColorPicker: Story<ColorPickerProps> = ({\n  hue,\n  lightness,\n  saturation,\n  disabled,\n  showDomainLabels,\n  debounceInterval,\n}: ColorPickerProps) => {\n  const [hue_, setHue] = useState(hue);\n  const [sat, setSat] = useState(saturation);\n  const [light, setLight] = useState(lightness);\n\n  useEffect(() => {\n    setHue(hue_);\n  }, [hue_]);\n\n  useEffect(() => {\n    setSat(saturation);\n  }, [saturation]);\n\n  useEffect(() => {\n    setLight(lightness);\n  }, [lightness]);\n\n  const allHues = Array.from({ length: 360 }, (_, i) => i).map(\n    num => `hsl(${num}, ${sat}%, ${light}%)`,\n  );\n  const allSats = [`hsl(${hue_}, 0%, ${light}%)`, `hsl(${hue_}, 100%, ${light}%`];\n  const allLights = [`hsl(${hue_}, ${sat}%, 10%)`, `hsl(${hue_}, ${sat}%, 90%)`];\n\n  return (\n    <Card\n      elevation={2}\n      StyledHeader={Card.NoPaddingHeader}\n      header={\n        <ColorPreview\n          style={{\n            backgroundColor: `hsl(${hue_},${sat}%,${light}%)`,\n            color: readableColor(`hsl(${hue_},${sat}%,${light}%)`),\n          }}\n        >\n          {toColorString({\n            hue: hue_,\n            saturation: sat / 100,\n            lightness: light / 100,\n          })}\n        </ColorPreview>\n      }\n    >\n      <Row>\n        <span>H:&nbsp;&nbsp;&nbsp;</span>\n        <RangeSlider\n          StyledSlideRail={forwardRef((props, ref) => (\n            <SlideRail\n              ref={ref as React.RefObject<HTMLDivElement>}\n              {...props}\n              style={{\n                backgroundImage: `linear-gradient(to right, ${allHues.join(', ')})`,\n              }}\n            />\n          ))}\n          disabled={disabled}\n          showDomainLabels={showDomainLabels}\n          showSelectedRange={false}\n          min={0}\n          max={360}\n          debounceInterval={debounceInterval}\n          onDebounceChange={val => {\n            action('onDebounceChange hue')(val);\n            setHue(Math.round(val));\n          }}\n          values={[\n            {\n              value: hue_,\n              label: hue_,\n              color: colors.grayLight,\n            },\n          ]}\n        />\n      </Row>\n      <Row>\n        <span>S:&nbsp;&nbsp;&nbsp;</span>\n        <RangeSlider\n          StyledSlideRail={forwardRef((props, ref) => (\n            <SlideRail\n              ref={ref as React.RefObject<HTMLDivElement>}\n              {...props}\n              style={{\n                backgroundImage: `linear-gradient(to right, ${allSats.join(', ')})`,\n              }}\n            />\n          ))}\n          min={0}\n          max={100}\n          debounceInterval={debounceInterval}\n          onDebounceChange={val => {\n            action('onDebounceChange saturation')(val);\n            setSat(Math.round(val));\n          }}\n          showDomainLabels={false}\n          showSelectedRange={false}\n          values={[\n            {\n              value: sat,\n              label: sat,\n              color: colors.grayLight,\n            },\n          ]}\n        />\n      </Row>\n      <Row>\n        <span>L:&nbsp;&nbsp;&nbsp;</span>\n        <RangeSlider\n          StyledSlideRail={forwardRef((props, ref) => (\n            <SlideRail\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              ref={ref}\n              {...props}\n              style={{\n                backgroundImage: `linear-gradient(to right, ${allLights.join(', ')})`,\n              }}\n            />\n          ))}\n          min={0}\n          max={100}\n          debounceInterval={debounceInterval}\n          onDebounceChange={val => {\n            action('onDebounceChange lightness')(val);\n            setLight(Math.round(val));\n          }}\n          showDomainLabels={false}\n          showSelectedRange={false}\n          values={[\n            {\n              value: light,\n              label: light,\n              color: colors.grayLight,\n            },\n          ]}\n        />\n      </Row>\n    </Card>\n  );\n};\nColorPicker.args = {\n  hue: 0,\n  saturation: 50,\n  lightness: 50,\n  disabled: false,\n  showDomainLabels: false,\n  debounceInterval: 10,\n};\n\nexport default {\n  title: 'RangeSlider',\n  argTypes: {\n    value: {\n      control: {\n        type: 'range',\n        min: 0,\n        max: 5,\n        step: 1,\n      },\n    },\n    min: {\n      control: { type: 'range', min: -10, max: 10, step: 1 },\n    },\n    max: {\n      control: {\n        type: 'range',\n        min: -10,\n        max: 10,\n        step: 1,\n      },\n    },\n    debounceInterval: {\n      control: {\n        type: 'range',\n        min: 0,\n        max: 100,\n        step: 1,\n      },\n    },\n    markers: {\n      options: ['none', 'all values', 'middle value'],\n      control: {\n        type: 'radio',\n      },\n    },\n    hue: {\n      control: {\n        type: 'range',\n        min: 0,\n        max: 360,\n        step: 1,\n      },\n    },\n    saturation: {\n      control: {\n        type: 'range',\n        min: 0,\n        max: 100,\n        step: 1,\n      },\n    },\n    lightness: {\n      control: {\n        type: 'range',\n        min: 0,\n        max: 100,\n        step: 1,\n      },\n    },\n    dragHandleAttachment: {\n      control: {\n        type: 'radio',\n      },\n      options: ['mouse', 'value'],\n    },\n  },\n  decorators: [withFoundryContext],\n  parameters: {\n    design: {\n      type: 'figma',\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=126%3A2',\n    },\n  },\n} as Meta;\n\n\n\nDefault.parameters = { storySource: { source: \"({\\n  value,\\n  markers,\\n  'use marker labels': markerLabels,\\n  disabled,\\n  showDomainLabels,\\n  showSelectedRange,\\n  min,\\n  max,\\n  dragHandleAttachment,\\n  readonly,\\n  debounceInterval,\\n  animated,\\n}: DefaultProps) => {\\n  const [val, setVal] = useState(value);\\n\\n  useEffect(() => {\\n    setVal(value);\\n  }, [value]);\\n\\n  const markersSelection = markers;\\n  const markersArray: Array<number | ValueProp> = [];\\n  if (markersSelection === 'all values') {\\n    for (let i = min; i <= max; i++) {\\n      markersArray.push(markerLabels ? { value: i, label: `${i}` } : i);\\n    }\\n  } else if (markersSelection === 'middle value') {\\n    const midpoint = (min + max) / 2;\\n    markersArray.push(markerLabels ? { value: midpoint, label: `${midpoint}` } : midpoint);\\n  }\\n\\n  return (\\n    <Row>\\n      <RangeSlider\\n        disabled={disabled}\\n        readonly={readonly}\\n        showDomainLabels={showDomainLabels}\\n        showSelectedRange={showSelectedRange}\\n        animated={animated}\\n        min={min}\\n        max={max}\\n        debounceInterval={debounceInterval}\\n        onChange={newVal => {\\n          action('onChange')(newVal);\\n          setVal(Math.round(newVal));\\n        }}\\n        dragHandleAttachment={dragHandleAttachment}\\n        values={[{ value: val, label: val }]}\\n        markers={markersArray as RangeSliderProps['markers']}\\n      />\\n    </Row>\\n  );\\n}\" }, ...Default.parameters };\nRating.parameters = { storySource: { source: \"({\\n  value,\\n  disabled,\\n  showDomainLabels,\\n  showSelectedRange,\\n  min,\\n  max,\\n}: RatingProps) => {\\n  const [val, setVal] = useState(value);\\n\\n  return (\\n    <Row>\\n      <span>ReactJS:&nbsp;&nbsp;&nbsp;&nbsp;</span>\\n      <RangeSlider\\n        StyledSlideRail={StyledSlideRail}\\n        disabled={disabled}\\n        showDomainLabels={showDomainLabels}\\n        showSelectedRange={showSelectedRange}\\n        min={min}\\n        max={max}\\n        onChange={newVal => {\\n          action('onChange')(newVal);\\n          setVal(Math.round(newVal));\\n        }}\\n        values={[\\n          {\\n            value: val,\\n            label: skillLabels[Math.round(val)],\\n            color: skillColors[Math.round(val)],\\n          },\\n        ]}\\n      />\\n    </Row>\\n  );\\n}\" }, ...Rating.parameters };\nColorPicker.parameters = { storySource: { source: \"({\\n  hue,\\n  lightness,\\n  saturation,\\n  disabled,\\n  showDomainLabels,\\n  debounceInterval,\\n}: ColorPickerProps) => {\\n  const [hue_, setHue] = useState(hue);\\n  const [sat, setSat] = useState(saturation);\\n  const [light, setLight] = useState(lightness);\\n\\n  useEffect(() => {\\n    setHue(hue_);\\n  }, [hue_]);\\n\\n  useEffect(() => {\\n    setSat(saturation);\\n  }, [saturation]);\\n\\n  useEffect(() => {\\n    setLight(lightness);\\n  }, [lightness]);\\n\\n  const allHues = Array.from({ length: 360 }, (_, i) => i).map(\\n    num => `hsl(${num}, ${sat}%, ${light}%)`,\\n  );\\n  const allSats = [`hsl(${hue_}, 0%, ${light}%)`, `hsl(${hue_}, 100%, ${light}%`];\\n  const allLights = [`hsl(${hue_}, ${sat}%, 10%)`, `hsl(${hue_}, ${sat}%, 90%)`];\\n\\n  return (\\n    <Card\\n      elevation={2}\\n      StyledHeader={Card.NoPaddingHeader}\\n      header={\\n        <ColorPreview\\n          style={{\\n            backgroundColor: `hsl(${hue_},${sat}%,${light}%)`,\\n            color: readableColor(`hsl(${hue_},${sat}%,${light}%)`),\\n          }}\\n        >\\n          {toColorString({\\n            hue: hue_,\\n            saturation: sat / 100,\\n            lightness: light / 100,\\n          })}\\n        </ColorPreview>\\n      }\\n    >\\n      <Row>\\n        <span>H:&nbsp;&nbsp;&nbsp;</span>\\n        <RangeSlider\\n          StyledSlideRail={forwardRef((props, ref) => (\\n            <SlideRail\\n              ref={ref as React.RefObject<HTMLDivElement>}\\n              {...props}\\n              style={{\\n                backgroundImage: `linear-gradient(to right, ${allHues.join(', ')})`,\\n              }}\\n            />\\n          ))}\\n          disabled={disabled}\\n          showDomainLabels={showDomainLabels}\\n          showSelectedRange={false}\\n          min={0}\\n          max={360}\\n          debounceInterval={debounceInterval}\\n          onDebounceChange={val => {\\n            action('onDebounceChange hue')(val);\\n            setHue(Math.round(val));\\n          }}\\n          values={[\\n            {\\n              value: hue_,\\n              label: hue_,\\n              color: colors.grayLight,\\n            },\\n          ]}\\n        />\\n      </Row>\\n      <Row>\\n        <span>S:&nbsp;&nbsp;&nbsp;</span>\\n        <RangeSlider\\n          StyledSlideRail={forwardRef((props, ref) => (\\n            <SlideRail\\n              ref={ref as React.RefObject<HTMLDivElement>}\\n              {...props}\\n              style={{\\n                backgroundImage: `linear-gradient(to right, ${allSats.join(', ')})`,\\n              }}\\n            />\\n          ))}\\n          min={0}\\n          max={100}\\n          debounceInterval={debounceInterval}\\n          onDebounceChange={val => {\\n            action('onDebounceChange saturation')(val);\\n            setSat(Math.round(val));\\n          }}\\n          showDomainLabels={false}\\n          showSelectedRange={false}\\n          values={[\\n            {\\n              value: sat,\\n              label: sat,\\n              color: colors.grayLight,\\n            },\\n          ]}\\n        />\\n      </Row>\\n      <Row>\\n        <span>L:&nbsp;&nbsp;&nbsp;</span>\\n        <RangeSlider\\n          StyledSlideRail={forwardRef((props, ref) => (\\n            <SlideRail\\n              \\n              // @ts-ignore\\n              ref={ref}\\n              {...props}\\n              style={{\\n                backgroundImage: `linear-gradient(to right, ${allLights.join(', ')})`,\\n              }}\\n            />\\n          ))}\\n          min={0}\\n          max={100}\\n          debounceInterval={debounceInterval}\\n          onDebounceChange={val => {\\n            action('onDebounceChange lightness')(val);\\n            setLight(Math.round(val));\\n          }}\\n          showDomainLabels={false}\\n          showSelectedRange={false}\\n          values={[\\n            {\\n              value: light,\\n              label: light,\\n              color: colors.grayLight,\\n            },\\n          ]}\\n        />\\n      </Row>\\n    </Card>\\n  );\\n}\" }, ...ColorPicker.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from 'react';\\nimport { Story, Meta } from '@storybook/react';\\nimport styled from 'styled-components';\\nimport { mdiPhone } from '@mdi/js';\\n\\nimport { withFoundryContext } from '../../../.storybook/decorators';\\n\\nimport colors from '../../enums/colors';\\n\\nimport Skeleton, { SkeletonProps } from './Skeleton';\\nimport { Button, Card, Divider, Text } from '../../index';\\n\\nconst HorizontalFlexBody = styled(Card.Body)`\\n  display: flex;\\n  gap: 1rem;\\n  align-items: flex-start;\\n  flex-flow: row nowrap;\\n`;\\n\\nconst PhotoContainer = styled.div`\\n  border-radius: 50%;\\n  overflow: hidden;\\n`;\\n\\nconst ProfilePhoto = styled.div`\\n  width: 5rem;\\n  height: 5rem;\\n  background-image: url('https://source.unsplash.com/collection/19271953');\\n  background-size: cover;\\n  background-repeat: no-repeat;\\n`;\\n\\nconst ProfileLine = styled(Skeleton.Container)`\\n  margin-bottom: 0.5rem;\\n  display: inline-block;\\n`;\\n\\nconst Name = styled(Text.Container)`\\n  font-weight: bold;\\n  font-size: 1.125rem;\\n`;\\n\\nexport const LoadingProfileExample: Story = ({ isLoading, color }: SkeletonProps) => (\\n  <Card\\n    StyledBody={HorizontalFlexBody}\\n    elevation={0}\\n    footer={\\n      <Button isLoading={isLoading} onClick={() => {}}>\\n        Add to contacts\\n      </Button>\\n    }\\n  >\\n    <PhotoContainer>\\n      <Skeleton isLoading={isLoading} color={color}>\\n        <ProfilePhoto />\\n      </Skeleton>\\n    </PhotoContainer>\\n    <div>\\n      <Skeleton isLoading={isLoading} color={color} StyledContainer={ProfileLine}>\\n        <Text StyledContainer={Name}>Jane Doe</Text>\\n      </Skeleton>\\n      <br />\\n      <Skeleton isLoading={isLoading} color={color} StyledContainer={ProfileLine}>\\n        <Text>Master of Ceremonies</Text>\\n      </Skeleton>\\n      <Divider />\\n      <Text color={colors.success} isLoading={isLoading} iconPrefix={mdiPhone}>\\n        214-555-1234\\n      </Text>\\n    </div>\\n  </Card>\\n);\\nLoadingProfileExample.args = {\\n  // variant: variants.fill,\\n  color: colors.grayLight,\\n  children: 'Default text',\\n  isLoading: true,\\n};\\n\\nexport default {\\n  title: 'Skeleton',\\n  component: Skeleton,\\n  decorators: [withFoundryContext],\\n  parameters: {\\n    // { design }, Once we have a design for Skeleton we can link it here\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"LoadingProfileExample\":{\"startLoc\":{\"col\":44,\"line\":43},\"endLoc\":{\"col\":1,\"line\":72},\"startBody\":{\"col\":44,\"line\":43},\"endBody\":{\"col\":1,\"line\":72}}};\n    \nimport React from 'react';\nimport { Story, Meta } from '@storybook/react';\nimport styled from 'styled-components';\nimport { mdiPhone } from '@mdi/js';\n\nimport { withFoundryContext } from '../../../.storybook/decorators';\n\nimport colors from '../../enums/colors';\n\nimport Skeleton, { SkeletonProps } from './Skeleton';\nimport { Button, Card, Divider, Text } from '../../index';\n\nconst HorizontalFlexBody = styled(Card.Body)`\n  display: flex;\n  gap: 1rem;\n  align-items: flex-start;\n  flex-flow: row nowrap;\n`;\n\nconst PhotoContainer = styled.div`\n  border-radius: 50%;\n  overflow: hidden;\n`;\n\nconst ProfilePhoto = styled.div`\n  width: 5rem;\n  height: 5rem;\n  background-image: url('https://source.unsplash.com/collection/19271953');\n  background-size: cover;\n  background-repeat: no-repeat;\n`;\n\nconst ProfileLine = styled(Skeleton.Container)`\n  margin-bottom: 0.5rem;\n  display: inline-block;\n`;\n\nconst Name = styled(Text.Container)`\n  font-weight: bold;\n  font-size: 1.125rem;\n`;\n\nexport const LoadingProfileExample: Story = ({ isLoading, color }: SkeletonProps) => (\n  <Card\n    StyledBody={HorizontalFlexBody}\n    elevation={0}\n    footer={\n      <Button isLoading={isLoading} onClick={() => {}}>\n        Add to contacts\n      </Button>\n    }\n  >\n    <PhotoContainer>\n      <Skeleton isLoading={isLoading} color={color}>\n        <ProfilePhoto />\n      </Skeleton>\n    </PhotoContainer>\n    <div>\n      <Skeleton isLoading={isLoading} color={color} StyledContainer={ProfileLine}>\n        <Text StyledContainer={Name}>Jane Doe</Text>\n      </Skeleton>\n      <br />\n      <Skeleton isLoading={isLoading} color={color} StyledContainer={ProfileLine}>\n        <Text>Master of Ceremonies</Text>\n      </Skeleton>\n      <Divider />\n      <Text color={colors.success} isLoading={isLoading} iconPrefix={mdiPhone}>\n        214-555-1234\n      </Text>\n    </div>\n  </Card>\n);\nLoadingProfileExample.args = {\n  // variant: variants.fill,\n  color: colors.grayLight,\n  children: 'Default text',\n  isLoading: true,\n};\n\nexport default {\n  title: 'Skeleton',\n  component: Skeleton,\n  decorators: [withFoundryContext],\n  parameters: {\n    // { design }, Once we have a design for Skeleton we can link it here\n  },\n} as Meta;\n\n\n\nLoadingProfileExample.parameters = { storySource: { source: \"({ isLoading, color }: SkeletonProps) => (\\n  <Card\\n    StyledBody={HorizontalFlexBody}\\n    elevation={0}\\n    footer={\\n      <Button isLoading={isLoading} onClick={() => {}}>\\n        Add to contacts\\n      </Button>\\n    }\\n  >\\n    <PhotoContainer>\\n      <Skeleton isLoading={isLoading} color={color}>\\n        <ProfilePhoto />\\n      </Skeleton>\\n    </PhotoContainer>\\n    <div>\\n      <Skeleton isLoading={isLoading} color={color} StyledContainer={ProfileLine}>\\n        <Text StyledContainer={Name}>Jane Doe</Text>\\n      </Skeleton>\\n      <br />\\n      <Skeleton isLoading={isLoading} color={color} StyledContainer={ProfileLine}>\\n        <Text>Master of Ceremonies</Text>\\n      </Skeleton>\\n      <Divider />\\n      <Text color={colors.success} isLoading={isLoading} iconPrefix={mdiPhone}>\\n        214-555-1234\\n      </Text>\\n    </div>\\n  </Card>\\n)\" }, ...LoadingProfileExample.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React, { useRef, useState } from 'react';\\nimport { Story, Meta } from '@storybook/react';\\nimport { mdiArrowRightBold, mdiCheckBold, mdiChevronDoubleRight, mdiDotsVertical } from '@mdi/js';\\nimport styled from 'styled-components';\\n\\nimport { withFoundryContext } from '../../../.storybook/decorators';\\nimport Spotlight, { SpotlightProps } from './Spotlight';\\nimport { Button, Card, Text, variants, colors } from '../../index';\\n\\nconst Header = styled(Card.NoPaddingHeader)`\\n  display: flex;\\n  justify-content: flex-end;\\n`;\\nconst Container = styled(Card.Container)`\\n  max-width: 35rem;\\n`;\\nconst ScrollingWindowContainer = styled(Container)`\\n  margin-top: 10rem;\\n`;\\nconst CustomScrollBody = styled(Card.Body)`\\n  overflow-y: auto;\\n  max-height: 70vh;\\n`;\\n\\nconst Annotation = styled(Spotlight.Annotation)`\\n  display: flex;\\n  flex-flow: row wrap;\\n  max-width: 16rem;\\n`;\\n\\nconst NextButtonContainer = styled(Button.Container)`\\n  flex: 1 1 auto;\\n  justify-content: center;\\n`;\\n\\nexport const Default: Story = (args: Partial<SpotlightProps>) => {\\n  const [currStep, setStep] = useState<number>(0);\\n  const buttonRef = useRef<HTMLButtonElement>(null);\\n  const cardRef = useRef<HTMLDivElement>(null);\\n  const menuRef = useRef<HTMLButtonElement>(null);\\n  const [tourStarted, setTour] = useState<boolean>(false);\\n\\n  const stepOptions = [null, menuRef, cardRef, buttonRef];\\n  const messages = [\\n    {\\n      title: 'Welcome to the tutorial!',\\n      subtitle: 'targetElement is null for this part of the tour, so nothing is highlighted!',\\n    },\\n    { title: 'This is a kebab menu.', subtitle: '' },\\n    { title: 'This is the whole card', subtitle: '' },\\n    { title: 'Press this button to restart the tour!', subtitle: '(you already knew that though)' },\\n  ];\\n\\n  const goNext = () => {\\n    setStep(step => {\\n      if (step >= stepOptions.length - 1) {\\n        setTour(false);\\n        return 0;\\n      }\\n      return step + 1;\\n    });\\n  };\\n\\n  const lastStep = currStep === stepOptions.length - 1;\\n\\n  return (\\n    <>\\n      <Card\\n        StyledHeader={Header}\\n        StyledContainer={ScrollingWindowContainer}\\n        containerRef={cardRef}\\n        header={\\n          <Button\\n            containerRef={menuRef}\\n            iconSuffix={mdiDotsVertical}\\n            variant={variants.text}\\n            color=\\\"black\\\"\\n          />\\n        }\\n        footer={\\n          <Button\\n            onClick={() => {\\n              setTour(true);\\n            }}\\n            containerRef={buttonRef}\\n            color={colors.tertiary}\\n          >\\n            Start tour\\n          </Button>\\n        }\\n      >\\n        <p>There are a few items in this card we can talk about!</p>\\n        <p>\\n          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt\\n          ut labore et dolore magna aliqua. Ultricies mi eget mauris pharetra et ultrices neque\\n          ornare aenean. Vitae purus faucibus ornare suspendisse sed nisi lacus sed viverra.\\n          Ullamcorper dignissim cras tincidunt lobortis feugiat vivamus at. Mauris a diam maecenas\\n          sed enim ut sem viverra aliquet. Ultrices in iaculis nunc sed augue lacus viverra. Sodales\\n          neque sodales ut etiam. Pulvinar neque laoreet suspendisse interdum consectetur libero id\\n          faucibus nisl. Ut placerat orci nulla pellentesque dignissim enim sit amet venenatis.\\n          Vivamus arcu felis bibendum ut tristique. Netus et malesuada fames ac turpis egestas.\\n          Porttitor rhoncus dolor purus non enim. Proin nibh nisl condimentum id. Aliquam ultrices\\n          sagittis orci a scelerisque purus semper. Faucibus purus in massa tempor nec feugiat. Et\\n          netus et malesuada fames. Cras pulvinar mattis nunc sed blandit libero. Nisi lacus sed\\n          viverra tellus in. Tellus rutrum tellus pellentesque eu tincidunt tortor aliquam nulla. Id\\n          porta nibh venenatis cras sed felis eget velit. Eros in cursus turpis massa tincidunt dui\\n          ut ornare. Proin fermentum leo vel orci porta non. Quisque non tellus orci ac auctor\\n          augue.\\n        </p>\\n      </Card>\\n      {tourStarted && (\\n        <Spotlight\\n          {...args}\\n          StyledAnnotation={Annotation}\\n          targetElement={stepOptions[currStep]?.current as HTMLElement}\\n        >\\n          <Text color=\\\"white\\\" containerProps={{ as: 'h1', style: { fontSize: '2em' } }}>\\n            {messages[currStep].title}\\n          </Text>\\n          <Text color=\\\"white\\\" containerProps={{ style: { fontWeight: '700' } }}>\\n            {messages[currStep].subtitle}\\n          </Text>\\n          <br />\\n          <br />\\n          <Button\\n            color={colors.background}\\n            iconSuffix={mdiChevronDoubleRight}\\n            variant={variants.outline}\\n            onClick={() => {\\n              setStep(0);\\n              setTour(false);\\n            }}\\n          >\\n            Skip\\n          </Button>\\n          &nbsp;\\n          <Button\\n            StyledContainer={NextButtonContainer}\\n            iconSuffix={lastStep ? mdiCheckBold : mdiArrowRightBold}\\n            elevation={1}\\n            color={lastStep ? colors.secondaryDark : colors.primaryDark}\\n            onClick={() => {\\n              goNext();\\n            }}\\n          >\\n            {lastStep ? 'I got it' : 'Next'}\\n          </Button>\\n        </Spotlight>\\n      )}\\n    </>\\n  );\\n};\\nDefault.args = {\\n  padding: 12,\\n  shape: 'rounded box',\\n  animateTargetChanges: true,\\n  backgroundDarkness: 0.3,\\n  backgroundBlur: '0.25rem',\\n  cornerRadius: 12,\\n};\\n\\nexport const CustomScrollWindow: Story = (args: Partial<SpotlightProps>) => {\\n  const [currStep, setStep] = useState<number>(0);\\n  const buttonRef = useRef<HTMLButtonElement>(null);\\n  const cardRef = useRef<HTMLDivElement>(null);\\n  const bodyRef = useRef<HTMLDivElement>(null);\\n  const menuRef = useRef<HTMLButtonElement>(null);\\n  const [tourStarted, setTour] = useState<boolean>(false);\\n\\n  const stepOptions = [null, menuRef, cardRef, buttonRef];\\n  const messages = [\\n    {\\n      title: 'Welcome to the tutorial!',\\n      subtitle: 'targetElement is null for this part of the tour, so nothing is highlighted!',\\n    },\\n    { title: 'This is a kebab menu.', subtitle: '' },\\n    { title: 'This is the whole card.', subtitle: '' },\\n    { title: 'Press this button to restart the tour!', subtitle: '(you already knew that though)' },\\n  ];\\n\\n  const goNext = () => {\\n    setStep(step => {\\n      if (step >= stepOptions.length - 1) {\\n        setTour(false);\\n        return 0;\\n      }\\n      return step + 1;\\n    });\\n  };\\n\\n  const lastStep = currStep === stepOptions.length - 1;\\n\\n  return (\\n    <>\\n      <Card\\n        StyledHeader={Header}\\n        StyledContainer={Container}\\n        StyledBody={CustomScrollBody}\\n        bodyRef={bodyRef}\\n        containerRef={cardRef}\\n      >\\n        <Button\\n          containerRef={menuRef}\\n          iconSuffix={mdiDotsVertical}\\n          variant={variants.text}\\n          color=\\\"black\\\"\\n        />\\n        <p>There are a few items in this card we can talk about!</p>\\n        <p>\\n          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt\\n          ut labore et dolore magna aliqua. Ultricies mi eget mauris pharetra et ultrices neque\\n          ornare aenean. Vitae purus faucibus ornare suspendisse sed nisi lacus sed viverra.\\n          Ullamcorper dignissim cras tincidunt lobortis feugiat vivamus at. Mauris a diam maecenas\\n          sed enim ut sem viverra aliquet. Ultrices in iaculis nunc sed augue lacus viverra. Sodales\\n          neque sodales ut etiam. Pulvinar neque laoreet suspendisse interdum consectetur libero id\\n          faucibus nisl. Ut placerat orci nulla pellentesque dignissim enim sit amet venenatis.\\n          Vivamus arcu felis bibendum ut tristique. Netus et malesuada fames ac turpis egestas.\\n          Porttitor rhoncus dolor purus non enim. Proin nibh nisl condimentum id. Aliquam ultrices\\n          sagittis orci a scelerisque purus semper. Faucibus purus in massa tempor nec feugiat. Et\\n          netus et malesuada fames. Cras pulvinar mattis nunc sed blandit libero. Nisi lacus sed\\n          viverra tellus in. Tellus rutrum tellus pellentesque eu tincidunt tortor aliquam nulla. Id\\n          porta nibh venenatis cras sed felis eget velit. Eros in cursus turpis massa tincidunt dui\\n          ut ornare. Proin fermentum leo vel orci porta non. Quisque non tellus orci ac auctor\\n          augue.\\n        </p>\\n        <Button\\n          onClick={() => {\\n            setTour(true);\\n          }}\\n          containerRef={buttonRef}\\n          color={colors.tertiary}\\n        >\\n          Start tour\\n        </Button>\\n      </Card>\\n      {tourStarted && (\\n        <Spotlight\\n          {...args}\\n          // scrollingParentElement={bodyRef.current as HTMLElement}\\n          StyledAnnotation={Annotation}\\n          targetElement={stepOptions[currStep]?.current as HTMLElement}\\n        >\\n          <Text color=\\\"white\\\" containerProps={{ as: 'h1', style: { fontSize: '2em' } }}>\\n            {messages[currStep].title}\\n          </Text>\\n          <Text color=\\\"white\\\" containerProps={{ style: { fontWeight: '700' } }}>\\n            {messages[currStep].subtitle}\\n          </Text>\\n          <br />\\n          <br />\\n          <Button\\n            color={colors.background}\\n            iconSuffix={mdiChevronDoubleRight}\\n            variant={variants.outline}\\n            onClick={() => {\\n              setStep(0);\\n              setTour(false);\\n            }}\\n          >\\n            Skip\\n          </Button>\\n          &nbsp;\\n          <Button\\n            StyledContainer={NextButtonContainer}\\n            iconSuffix={lastStep ? mdiCheckBold : mdiArrowRightBold}\\n            elevation={1}\\n            color={lastStep ? colors.secondaryDark : colors.primaryDark}\\n            onClick={() => {\\n              goNext();\\n            }}\\n          >\\n            {lastStep ? 'I got it' : 'Next'}\\n          </Button>\\n        </Spotlight>\\n      )}\\n    </>\\n  );\\n};\\nCustomScrollWindow.args = {\\n  padding: 12,\\n  shape: 'rounded box',\\n  animateTargetChanges: true,\\n  backgroundDarkness: 0.3,\\n  backgroundBlur: '0.25rem',\\n  cornerRadius: 12,\\n};\\n\\nexport default {\\n  title: 'Spotlight',\\n  component: Spotlight,\\n  decorators: [withFoundryContext],\\n  parameters: {\\n    // { design }, Once we have a design for Spotlight we can link it here\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Default\":{\"startLoc\":{\"col\":30,\"line\":36},\"endLoc\":{\"col\":1,\"line\":152},\"startBody\":{\"col\":30,\"line\":36},\"endBody\":{\"col\":1,\"line\":152}},\"CustomScrollWindow\":{\"startLoc\":{\"col\":41,\"line\":162},\"endLoc\":{\"col\":1,\"line\":278},\"startBody\":{\"col\":41,\"line\":162},\"endBody\":{\"col\":1,\"line\":278}}};\n    \nimport React, { useRef, useState } from 'react';\nimport { Story, Meta } from '@storybook/react';\nimport { mdiArrowRightBold, mdiCheckBold, mdiChevronDoubleRight, mdiDotsVertical } from '@mdi/js';\nimport styled from 'styled-components';\n\nimport { withFoundryContext } from '../../../.storybook/decorators';\nimport Spotlight, { SpotlightProps } from './Spotlight';\nimport { Button, Card, Text, variants, colors } from '../../index';\n\nconst Header = styled(Card.NoPaddingHeader)`\n  display: flex;\n  justify-content: flex-end;\n`;\nconst Container = styled(Card.Container)`\n  max-width: 35rem;\n`;\nconst ScrollingWindowContainer = styled(Container)`\n  margin-top: 10rem;\n`;\nconst CustomScrollBody = styled(Card.Body)`\n  overflow-y: auto;\n  max-height: 70vh;\n`;\n\nconst Annotation = styled(Spotlight.Annotation)`\n  display: flex;\n  flex-flow: row wrap;\n  max-width: 16rem;\n`;\n\nconst NextButtonContainer = styled(Button.Container)`\n  flex: 1 1 auto;\n  justify-content: center;\n`;\n\nexport const Default: Story = (args: Partial<SpotlightProps>) => {\n  const [currStep, setStep] = useState<number>(0);\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  const cardRef = useRef<HTMLDivElement>(null);\n  const menuRef = useRef<HTMLButtonElement>(null);\n  const [tourStarted, setTour] = useState<boolean>(false);\n\n  const stepOptions = [null, menuRef, cardRef, buttonRef];\n  const messages = [\n    {\n      title: 'Welcome to the tutorial!',\n      subtitle: 'targetElement is null for this part of the tour, so nothing is highlighted!',\n    },\n    { title: 'This is a kebab menu.', subtitle: '' },\n    { title: 'This is the whole card', subtitle: '' },\n    { title: 'Press this button to restart the tour!', subtitle: '(you already knew that though)' },\n  ];\n\n  const goNext = () => {\n    setStep(step => {\n      if (step >= stepOptions.length - 1) {\n        setTour(false);\n        return 0;\n      }\n      return step + 1;\n    });\n  };\n\n  const lastStep = currStep === stepOptions.length - 1;\n\n  return (\n    <>\n      <Card\n        StyledHeader={Header}\n        StyledContainer={ScrollingWindowContainer}\n        containerRef={cardRef}\n        header={\n          <Button\n            containerRef={menuRef}\n            iconSuffix={mdiDotsVertical}\n            variant={variants.text}\n            color=\"black\"\n          />\n        }\n        footer={\n          <Button\n            onClick={() => {\n              setTour(true);\n            }}\n            containerRef={buttonRef}\n            color={colors.tertiary}\n          >\n            Start tour\n          </Button>\n        }\n      >\n        <p>There are a few items in this card we can talk about!</p>\n        <p>\n          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt\n          ut labore et dolore magna aliqua. Ultricies mi eget mauris pharetra et ultrices neque\n          ornare aenean. Vitae purus faucibus ornare suspendisse sed nisi lacus sed viverra.\n          Ullamcorper dignissim cras tincidunt lobortis feugiat vivamus at. Mauris a diam maecenas\n          sed enim ut sem viverra aliquet. Ultrices in iaculis nunc sed augue lacus viverra. Sodales\n          neque sodales ut etiam. Pulvinar neque laoreet suspendisse interdum consectetur libero id\n          faucibus nisl. Ut placerat orci nulla pellentesque dignissim enim sit amet venenatis.\n          Vivamus arcu felis bibendum ut tristique. Netus et malesuada fames ac turpis egestas.\n          Porttitor rhoncus dolor purus non enim. Proin nibh nisl condimentum id. Aliquam ultrices\n          sagittis orci a scelerisque purus semper. Faucibus purus in massa tempor nec feugiat. Et\n          netus et malesuada fames. Cras pulvinar mattis nunc sed blandit libero. Nisi lacus sed\n          viverra tellus in. Tellus rutrum tellus pellentesque eu tincidunt tortor aliquam nulla. Id\n          porta nibh venenatis cras sed felis eget velit. Eros in cursus turpis massa tincidunt dui\n          ut ornare. Proin fermentum leo vel orci porta non. Quisque non tellus orci ac auctor\n          augue.\n        </p>\n      </Card>\n      {tourStarted && (\n        <Spotlight\n          {...args}\n          StyledAnnotation={Annotation}\n          targetElement={stepOptions[currStep]?.current as HTMLElement}\n        >\n          <Text color=\"white\" containerProps={{ as: 'h1', style: { fontSize: '2em' } }}>\n            {messages[currStep].title}\n          </Text>\n          <Text color=\"white\" containerProps={{ style: { fontWeight: '700' } }}>\n            {messages[currStep].subtitle}\n          </Text>\n          <br />\n          <br />\n          <Button\n            color={colors.background}\n            iconSuffix={mdiChevronDoubleRight}\n            variant={variants.outline}\n            onClick={() => {\n              setStep(0);\n              setTour(false);\n            }}\n          >\n            Skip\n          </Button>\n          &nbsp;\n          <Button\n            StyledContainer={NextButtonContainer}\n            iconSuffix={lastStep ? mdiCheckBold : mdiArrowRightBold}\n            elevation={1}\n            color={lastStep ? colors.secondaryDark : colors.primaryDark}\n            onClick={() => {\n              goNext();\n            }}\n          >\n            {lastStep ? 'I got it' : 'Next'}\n          </Button>\n        </Spotlight>\n      )}\n    </>\n  );\n};;\nDefault.args = {\n  padding: 12,\n  shape: 'rounded box',\n  animateTargetChanges: true,\n  backgroundDarkness: 0.3,\n  backgroundBlur: '0.25rem',\n  cornerRadius: 12,\n};\n\nexport const CustomScrollWindow: Story = (args: Partial<SpotlightProps>) => {\n  const [currStep, setStep] = useState<number>(0);\n  const buttonRef = useRef<HTMLButtonElement>(null);\n  const cardRef = useRef<HTMLDivElement>(null);\n  const bodyRef = useRef<HTMLDivElement>(null);\n  const menuRef = useRef<HTMLButtonElement>(null);\n  const [tourStarted, setTour] = useState<boolean>(false);\n\n  const stepOptions = [null, menuRef, cardRef, buttonRef];\n  const messages = [\n    {\n      title: 'Welcome to the tutorial!',\n      subtitle: 'targetElement is null for this part of the tour, so nothing is highlighted!',\n    },\n    { title: 'This is a kebab menu.', subtitle: '' },\n    { title: 'This is the whole card.', subtitle: '' },\n    { title: 'Press this button to restart the tour!', subtitle: '(you already knew that though)' },\n  ];\n\n  const goNext = () => {\n    setStep(step => {\n      if (step >= stepOptions.length - 1) {\n        setTour(false);\n        return 0;\n      }\n      return step + 1;\n    });\n  };\n\n  const lastStep = currStep === stepOptions.length - 1;\n\n  return (\n    <>\n      <Card\n        StyledHeader={Header}\n        StyledContainer={Container}\n        StyledBody={CustomScrollBody}\n        bodyRef={bodyRef}\n        containerRef={cardRef}\n      >\n        <Button\n          containerRef={menuRef}\n          iconSuffix={mdiDotsVertical}\n          variant={variants.text}\n          color=\"black\"\n        />\n        <p>There are a few items in this card we can talk about!</p>\n        <p>\n          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt\n          ut labore et dolore magna aliqua. Ultricies mi eget mauris pharetra et ultrices neque\n          ornare aenean. Vitae purus faucibus ornare suspendisse sed nisi lacus sed viverra.\n          Ullamcorper dignissim cras tincidunt lobortis feugiat vivamus at. Mauris a diam maecenas\n          sed enim ut sem viverra aliquet. Ultrices in iaculis nunc sed augue lacus viverra. Sodales\n          neque sodales ut etiam. Pulvinar neque laoreet suspendisse interdum consectetur libero id\n          faucibus nisl. Ut placerat orci nulla pellentesque dignissim enim sit amet venenatis.\n          Vivamus arcu felis bibendum ut tristique. Netus et malesuada fames ac turpis egestas.\n          Porttitor rhoncus dolor purus non enim. Proin nibh nisl condimentum id. Aliquam ultrices\n          sagittis orci a scelerisque purus semper. Faucibus purus in massa tempor nec feugiat. Et\n          netus et malesuada fames. Cras pulvinar mattis nunc sed blandit libero. Nisi lacus sed\n          viverra tellus in. Tellus rutrum tellus pellentesque eu tincidunt tortor aliquam nulla. Id\n          porta nibh venenatis cras sed felis eget velit. Eros in cursus turpis massa tincidunt dui\n          ut ornare. Proin fermentum leo vel orci porta non. Quisque non tellus orci ac auctor\n          augue.\n        </p>\n        <Button\n          onClick={() => {\n            setTour(true);\n          }}\n          containerRef={buttonRef}\n          color={colors.tertiary}\n        >\n          Start tour\n        </Button>\n      </Card>\n      {tourStarted && (\n        <Spotlight\n          {...args}\n          // scrollingParentElement={bodyRef.current as HTMLElement}\n          StyledAnnotation={Annotation}\n          targetElement={stepOptions[currStep]?.current as HTMLElement}\n        >\n          <Text color=\"white\" containerProps={{ as: 'h1', style: { fontSize: '2em' } }}>\n            {messages[currStep].title}\n          </Text>\n          <Text color=\"white\" containerProps={{ style: { fontWeight: '700' } }}>\n            {messages[currStep].subtitle}\n          </Text>\n          <br />\n          <br />\n          <Button\n            color={colors.background}\n            iconSuffix={mdiChevronDoubleRight}\n            variant={variants.outline}\n            onClick={() => {\n              setStep(0);\n              setTour(false);\n            }}\n          >\n            Skip\n          </Button>\n          &nbsp;\n          <Button\n            StyledContainer={NextButtonContainer}\n            iconSuffix={lastStep ? mdiCheckBold : mdiArrowRightBold}\n            elevation={1}\n            color={lastStep ? colors.secondaryDark : colors.primaryDark}\n            onClick={() => {\n              goNext();\n            }}\n          >\n            {lastStep ? 'I got it' : 'Next'}\n          </Button>\n        </Spotlight>\n      )}\n    </>\n  );\n};\nCustomScrollWindow.args = {\n  padding: 12,\n  shape: 'rounded box',\n  animateTargetChanges: true,\n  backgroundDarkness: 0.3,\n  backgroundBlur: '0.25rem',\n  cornerRadius: 12,\n};\n\nexport default {\n  title: 'Spotlight',\n  component: Spotlight,\n  decorators: [withFoundryContext],\n  parameters: {\n    // { design }, Once we have a design for Spotlight we can link it here\n  },\n} as Meta;\n\n\n\nDefault.parameters = { storySource: { source: \"(args: Partial<SpotlightProps>) => {\\n  const [currStep, setStep] = useState<number>(0);\\n  const buttonRef = useRef<HTMLButtonElement>(null);\\n  const cardRef = useRef<HTMLDivElement>(null);\\n  const menuRef = useRef<HTMLButtonElement>(null);\\n  const [tourStarted, setTour] = useState<boolean>(false);\\n\\n  const stepOptions = [null, menuRef, cardRef, buttonRef];\\n  const messages = [\\n    {\\n      title: 'Welcome to the tutorial!',\\n      subtitle: 'targetElement is null for this part of the tour, so nothing is highlighted!',\\n    },\\n    { title: 'This is a kebab menu.', subtitle: '' },\\n    { title: 'This is the whole card', subtitle: '' },\\n    { title: 'Press this button to restart the tour!', subtitle: '(you already knew that though)' },\\n  ];\\n\\n  const goNext = () => {\\n    setStep(step => {\\n      if (step >= stepOptions.length - 1) {\\n        setTour(false);\\n        return 0;\\n      }\\n      return step + 1;\\n    });\\n  };\\n\\n  const lastStep = currStep === stepOptions.length - 1;\\n\\n  return (\\n    <>\\n      <Card\\n        StyledHeader={Header}\\n        StyledContainer={ScrollingWindowContainer}\\n        containerRef={cardRef}\\n        header={\\n          <Button\\n            containerRef={menuRef}\\n            iconSuffix={mdiDotsVertical}\\n            variant={variants.text}\\n            color=\\\"black\\\"\\n          />\\n        }\\n        footer={\\n          <Button\\n            onClick={() => {\\n              setTour(true);\\n            }}\\n            containerRef={buttonRef}\\n            color={colors.tertiary}\\n          >\\n            Start tour\\n          </Button>\\n        }\\n      >\\n        <p>There are a few items in this card we can talk about!</p>\\n        <p>\\n          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt\\n          ut labore et dolore magna aliqua. Ultricies mi eget mauris pharetra et ultrices neque\\n          ornare aenean. Vitae purus faucibus ornare suspendisse sed nisi lacus sed viverra.\\n          Ullamcorper dignissim cras tincidunt lobortis feugiat vivamus at. Mauris a diam maecenas\\n          sed enim ut sem viverra aliquet. Ultrices in iaculis nunc sed augue lacus viverra. Sodales\\n          neque sodales ut etiam. Pulvinar neque laoreet suspendisse interdum consectetur libero id\\n          faucibus nisl. Ut placerat orci nulla pellentesque dignissim enim sit amet venenatis.\\n          Vivamus arcu felis bibendum ut tristique. Netus et malesuada fames ac turpis egestas.\\n          Porttitor rhoncus dolor purus non enim. Proin nibh nisl condimentum id. Aliquam ultrices\\n          sagittis orci a scelerisque purus semper. Faucibus purus in massa tempor nec feugiat. Et\\n          netus et malesuada fames. Cras pulvinar mattis nunc sed blandit libero. Nisi lacus sed\\n          viverra tellus in. Tellus rutrum tellus pellentesque eu tincidunt tortor aliquam nulla. Id\\n          porta nibh venenatis cras sed felis eget velit. Eros in cursus turpis massa tincidunt dui\\n          ut ornare. Proin fermentum leo vel orci porta non. Quisque non tellus orci ac auctor\\n          augue.\\n        </p>\\n      </Card>\\n      {tourStarted && (\\n        <Spotlight\\n          {...args}\\n          StyledAnnotation={Annotation}\\n          targetElement={stepOptions[currStep]?.current as HTMLElement}\\n        >\\n          <Text color=\\\"white\\\" containerProps={{ as: 'h1', style: { fontSize: '2em' } }}>\\n            {messages[currStep].title}\\n          </Text>\\n          <Text color=\\\"white\\\" containerProps={{ style: { fontWeight: '700' } }}>\\n            {messages[currStep].subtitle}\\n          </Text>\\n          <br />\\n          <br />\\n          <Button\\n            color={colors.background}\\n            iconSuffix={mdiChevronDoubleRight}\\n            variant={variants.outline}\\n            onClick={() => {\\n              setStep(0);\\n              setTour(false);\\n            }}\\n          >\\n            Skip\\n          </Button>\\n          &nbsp;\\n          <Button\\n            StyledContainer={NextButtonContainer}\\n            iconSuffix={lastStep ? mdiCheckBold : mdiArrowRightBold}\\n            elevation={1}\\n            color={lastStep ? colors.secondaryDark : colors.primaryDark}\\n            onClick={() => {\\n              goNext();\\n            }}\\n          >\\n            {lastStep ? 'I got it' : 'Next'}\\n          </Button>\\n        </Spotlight>\\n      )}\\n    </>\\n  );\\n}\" }, ...Default.parameters };\nCustomScrollWindow.parameters = { storySource: { source: \"(args: Partial<SpotlightProps>) => {\\n  const [currStep, setStep] = useState<number>(0);\\n  const buttonRef = useRef<HTMLButtonElement>(null);\\n  const cardRef = useRef<HTMLDivElement>(null);\\n  const bodyRef = useRef<HTMLDivElement>(null);\\n  const menuRef = useRef<HTMLButtonElement>(null);\\n  const [tourStarted, setTour] = useState<boolean>(false);\\n\\n  const stepOptions = [null, menuRef, cardRef, buttonRef];\\n  const messages = [\\n    {\\n      title: 'Welcome to the tutorial!',\\n      subtitle: 'targetElement is null for this part of the tour, so nothing is highlighted!',\\n    },\\n    { title: 'This is a kebab menu.', subtitle: '' },\\n    { title: 'This is the whole card.', subtitle: '' },\\n    { title: 'Press this button to restart the tour!', subtitle: '(you already knew that though)' },\\n  ];\\n\\n  const goNext = () => {\\n    setStep(step => {\\n      if (step >= stepOptions.length - 1) {\\n        setTour(false);\\n        return 0;\\n      }\\n      return step + 1;\\n    });\\n  };\\n\\n  const lastStep = currStep === stepOptions.length - 1;\\n\\n  return (\\n    <>\\n      <Card\\n        StyledHeader={Header}\\n        StyledContainer={Container}\\n        StyledBody={CustomScrollBody}\\n        bodyRef={bodyRef}\\n        containerRef={cardRef}\\n      >\\n        <Button\\n          containerRef={menuRef}\\n          iconSuffix={mdiDotsVertical}\\n          variant={variants.text}\\n          color=\\\"black\\\"\\n        />\\n        <p>There are a few items in this card we can talk about!</p>\\n        <p>\\n          Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt\\n          ut labore et dolore magna aliqua. Ultricies mi eget mauris pharetra et ultrices neque\\n          ornare aenean. Vitae purus faucibus ornare suspendisse sed nisi lacus sed viverra.\\n          Ullamcorper dignissim cras tincidunt lobortis feugiat vivamus at. Mauris a diam maecenas\\n          sed enim ut sem viverra aliquet. Ultrices in iaculis nunc sed augue lacus viverra. Sodales\\n          neque sodales ut etiam. Pulvinar neque laoreet suspendisse interdum consectetur libero id\\n          faucibus nisl. Ut placerat orci nulla pellentesque dignissim enim sit amet venenatis.\\n          Vivamus arcu felis bibendum ut tristique. Netus et malesuada fames ac turpis egestas.\\n          Porttitor rhoncus dolor purus non enim. Proin nibh nisl condimentum id. Aliquam ultrices\\n          sagittis orci a scelerisque purus semper. Faucibus purus in massa tempor nec feugiat. Et\\n          netus et malesuada fames. Cras pulvinar mattis nunc sed blandit libero. Nisi lacus sed\\n          viverra tellus in. Tellus rutrum tellus pellentesque eu tincidunt tortor aliquam nulla. Id\\n          porta nibh venenatis cras sed felis eget velit. Eros in cursus turpis massa tincidunt dui\\n          ut ornare. Proin fermentum leo vel orci porta non. Quisque non tellus orci ac auctor\\n          augue.\\n        </p>\\n        <Button\\n          onClick={() => {\\n            setTour(true);\\n          }}\\n          containerRef={buttonRef}\\n          color={colors.tertiary}\\n        >\\n          Start tour\\n        </Button>\\n      </Card>\\n      {tourStarted && (\\n        <Spotlight\\n          {...args}\\n          // scrollingParentElement={bodyRef.current as HTMLElement}\\n          StyledAnnotation={Annotation}\\n          targetElement={stepOptions[currStep]?.current as HTMLElement}\\n        >\\n          <Text color=\\\"white\\\" containerProps={{ as: 'h1', style: { fontSize: '2em' } }}>\\n            {messages[currStep].title}\\n          </Text>\\n          <Text color=\\\"white\\\" containerProps={{ style: { fontWeight: '700' } }}>\\n            {messages[currStep].subtitle}\\n          </Text>\\n          <br />\\n          <br />\\n          <Button\\n            color={colors.background}\\n            iconSuffix={mdiChevronDoubleRight}\\n            variant={variants.outline}\\n            onClick={() => {\\n              setStep(0);\\n              setTour(false);\\n            }}\\n          >\\n            Skip\\n          </Button>\\n          &nbsp;\\n          <Button\\n            StyledContainer={NextButtonContainer}\\n            iconSuffix={lastStep ? mdiCheckBold : mdiArrowRightBold}\\n            elevation={1}\\n            color={lastStep ? colors.secondaryDark : colors.primaryDark}\\n            onClick={() => {\\n              goNext();\\n            }}\\n          >\\n            {lastStep ? 'I got it' : 'Next'}\\n          </Button>\\n        </Spotlight>\\n      )}\\n    </>\\n  );\\n}\" }, ...CustomScrollWindow.parameters };","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React, { useState } from 'react';\\nimport { Story, Meta } from '@storybook/react';\\n\\nimport styled from 'styled-components';\\nimport Icon from '@mdi/react';\\nimport { mdiClose } from '@mdi/js';\\nimport { name, address, company, commerce } from 'faker';\\n\\nimport Table, { ExpansionIconColumnName } from './Table';\\nimport Checkbox from '../Checkbox/Checkbox';\\nimport { Columns, ExpansionIconProps, RowEntry } from './types';\\nimport { CheckboxTypes } from '../../enums/checkboxTypes';\\n\\ntype SampleDataType = {\\n  name?: string;\\n  title?: string;\\n  address?: string;\\n  notes?: string;\\n  isGroupLabel?: boolean;\\n  selected?: boolean;\\n};\\n\\n// Custom icon used for overriding the default collapse/expand icons\\nconst expansionIconOverride = ({ isCollapsed, onClick }: ExpansionIconProps) => (\\n  <Checkbox\\n    checked={!isCollapsed}\\n    onClick={onClick}\\n    checkboxType={CheckboxTypes.check}\\n    inputProps={{ onChange: () => {} }}\\n  />\\n);\\n\\nconst ActionCellContainer = styled(Table.Cell)`\\n  cursor: pointer;\\n  user-select: none;\\n  font-size: 1rem;\\n  &:hover {\\n    color: red;\\n  }\\n`;\\n\\nconst NoteField = styled.textarea`\\n  width: 100%;\\n  height: 100%;\\n  border-radius: 2px;\\n  resize: none;\\n`;\\n\\nconst generateSampleData = (rows: number): SampleDataType[] => {\\n  const finalData: Array<RowEntry> = [];\\n\\n  for (let i = 0; i < rows; i += 1) {\\n    finalData.push({\\n      name: name.findName(),\\n      title: name.title(),\\n      address: address.streetAddress(),\\n      notes: company.catchPhrase(),\\n    });\\n  }\\n\\n  return finalData;\\n};\\n\\nconst generateSampleGroups = (numberOfGroups = 5, groupSize = 5): Array<SampleDataType[]> => {\\n  const groupData: Array<Array<RowEntry>> = [];\\n  for (let i = 0; i < numberOfGroups; i++) {\\n    const groupRows = generateSampleData(groupSize);\\n    // Add group title row\\n    groupRows.push({\\n      title: `${commerce.department()} Department`,\\n      isGroupLabel: true,\\n    });\\n\\n    groupData.push(groupRows);\\n  }\\n  return groupData;\\n};\\n\\nconst sampleData = generateSampleData(10);\\nconst sampleGroupData = generateSampleGroups();\\n\\ninterface DefaultProps {\\n  'Selection width': string;\\n  'Name width': string;\\n  'Title width': string;\\n  'Address width': string;\\n  'Notes width': string;\\n  'Action width': string;\\n}\\n\\nexport const Default: Story<DefaultProps> = ({\\n  'Selection width': selectionWidth,\\n  'Name width': nameWidth,\\n  'Title width': titleWidth,\\n  'Address width': addressWidth,\\n  'Notes width': notesWidth,\\n  'Action width': actionWidth,\\n}: DefaultProps) => {\\n  const [rows, setRows] = useState(sampleData);\\n\\n  const onDelete = (index: number) => {\\n    const newRows = [...rows];\\n    newRows.splice(index, 1);\\n    setRows(newRows);\\n  };\\n\\n  const onSelect = (index: number, selected: boolean) => {\\n    const newRows = [...rows];\\n    newRows[index].selected = !selected;\\n    setRows(newRows);\\n  };\\n\\n  const selectAll = (event: React.MouseEvent) => {\\n    const target = event.target as HTMLInputElement;\\n    const currentlyChecked = target.checked;\\n    const newRows = rows.map((row: SampleDataType) => ({ ...row, selected: currentlyChecked }));\\n    setRows(newRows);\\n  };\\n\\n  const SelectAllCell = () => {\\n    const checkRowForSelection = (row: SampleDataType) =>\\n      Object.prototype.hasOwnProperty.call(row, 'selected') && row.selected;\\n\\n    // TODO: don't use pointer-events to control if a column is sortable - it should be checked\\n    // within the sorting listeners so that `sortable` doesn't need to be passed here just to give\\n    // it pointer-events\\n    return (\\n      <Table.HeaderCell sortable>\\n        <Checkbox\\n          checkboxType={\\n            rows.filter(checkRowForSelection).length === rows.length\\n              ? CheckboxTypes.check\\n              : CheckboxTypes.neutral\\n          }\\n          checked={Boolean(rows.filter(checkRowForSelection).length)}\\n          onClick={e => selectAll(e)}\\n          inputProps={{ onChange: () => {} }}\\n        />\\n      </Table.HeaderCell>\\n    );\\n  };\\n\\n  const SelectionCell = ({\\n    index,\\n    selected,\\n    reachedMinWidth = false,\\n  }: {\\n    index: number;\\n    selected: boolean;\\n    \\n    reachedMinWidth?: boolean;\\n  }) => (\\n    <Table.Cell>\\n      <Checkbox\\n        onClick={() => onSelect(index, selected)}\\n        checkboxType={CheckboxTypes.check}\\n        checked={selected}\\n        inputProps={{ onChange: () => {} }}\\n      >\\n        {reachedMinWidth ? 'Select for download' : ''}\\n      </Checkbox>\\n    </Table.Cell>\\n  );\\n\\n  const NotesCell = ({ notes }: { notes: string }) => (\\n    <Table.Cell>\\n      <NoteField onChange={() => {}} rows={3} value={notes} />\\n    </Table.Cell>\\n  );\\n\\n  const ActionCell = ({ index, reachedMinWidth }: { index: number; reachedMinWidth: boolean }) => (\\n    <ActionCellContainer\\n      onClick={() => {\\n        onDelete(index);\\n      }}\\n    >\\n      <Icon size=\\\"1rem\\\" path={mdiClose} />\\n      &nbsp;&nbsp;\\n      {reachedMinWidth ? 'Delete user' : ''}\\n    </ActionCellContainer>\\n  );\\n\\n  const sampleColumns: Columns = {\\n    selection: {\\n      name: '',\\n      headerCellComponent: SelectAllCell,\\n      width: selectionWidth,\\n      cellComponent: SelectionCell,\\n      sortable: false,\\n      footerContent: '',\\n    },\\n    name: {\\n      name: 'Name',\\n      width: nameWidth,\\n      footerContent: 'NameFooter',\\n      sortable: true,\\n    },\\n    title: {\\n      name: 'Title',\\n      width: titleWidth,\\n      footerContent: 'TitleFooter',\\n    },\\n    address: {\\n      name: 'Address',\\n      width: addressWidth,\\n      footerContent: 'AddressFooter',\\n    },\\n    notes: {\\n      name: 'Notes',\\n      width: notesWidth,\\n      cellComponent: NotesCell,\\n      minTableWidth: 800,\\n      sortable: true,\\n      sortFunction: (a: string, b: string) => a.length < b.length,\\n      footerContent: 'NotesFooter',\\n    },\\n    action: {\\n      name: '',\\n      sortable: false,\\n      width: actionWidth,\\n      cellComponent: ActionCell,\\n      footerContent: '',\\n    },\\n  };\\n\\n  return <Table columns={sampleColumns} data={rows} />;\\n};\\nDefault.args = {\\n  'Selection width': '2rem',\\n  'Name width': '1fr',\\n  'Title width': '1fr',\\n  'Address width': '1fr',\\n  'Notes width': '12rem',\\n  'Action width': '1rem',\\n};\\n\\ninterface GroupsProps extends DefaultProps {\\n  'Use default expansion column': boolean;\\n  'Expansion Icon width': string;\\n  groupLabelPosition: 'above' | 'below' | undefined;\\n  useCustomLabel: boolean;\\n  sortGroups: boolean;\\n  areGroupsCollapsible: boolean;\\n}\\n\\nexport const Groups: Story<GroupsProps> = ({\\n  'Selection width': selectionWidth,\\n  'Name width': nameWidth,\\n  'Title width': titleWidth,\\n  'Address width': addressWidth,\\n  'Notes width': notesWidth,\\n  'Use default expansion column': useDefaultExpansionColumn,\\n  groupLabelPosition,\\n  sortGroups,\\n  areGroupsCollapsible,\\n  useCustomLabel,\\n  ...args\\n}: GroupsProps) => {\\n  const [rows, setRows] = useState(sampleGroupData);\\n\\n  const onSelect = (index = 0, groupIndex = 0, selected: boolean) => {\\n    const newRows: SampleDataType[][] = [];\\n    rows.forEach(grp => {\\n      newRows.push([...grp]);\\n    });\\n\\n    newRows[groupIndex][index].selected = !selected;\\n    setRows(newRows);\\n  };\\n\\n  const selectAll = (event: React.MouseEvent) => {\\n    const target = event.target as HTMLInputElement;\\n    const currentlyChecked = target.checked;\\n    const newRows: SampleDataType[][] = [];\\n    rows.forEach(group => {\\n      newRows.push(\\n        group.map(row => {\\n          return { ...row, selected: currentlyChecked };\\n        }),\\n      );\\n    });\\n    setRows(newRows);\\n  };\\n\\n  const SelectAllCell = () => {\\n    let totalSelected = 0;\\n    let totalCheckboxesAccumulator = 0;\\n    rows.forEach(groupRows => {\\n      groupRows.forEach(row => {\\n        if (row.isGroupLabel) return;\\n        if (row.selected) totalSelected++;\\n        totalCheckboxesAccumulator++;\\n      });\\n    });\\n    const allChecked = totalSelected === totalCheckboxesAccumulator;\\n\\n    // TODO: don't use pointer-events to control if a column is sortable - it should be checked\\n    // within the sorting listeners so that `sortable` doesn't need to be passed here just to give\\n    // it pointer-events\\n    return (\\n      <Table.HeaderCell sortable>\\n        <Checkbox\\n          checkboxType={allChecked ? CheckboxTypes.check : CheckboxTypes.neutral}\\n          checked={Boolean(totalSelected)}\\n          onClick={selectAll}\\n          inputProps={{ onChange: () => {} }}\\n        />\\n      </Table.HeaderCell>\\n    );\\n  };\\n\\n  const SelectionCell = ({\\n    index = 0,\\n    selected,\\n    reachedMinWidth = false,\\n    groupIndex = 0,\\n  }: {\\n    \\n    index?: number;\\n    selected: boolean;\\n    \\n    reachedMinWidth?: boolean;\\n    \\n    groupIndex?: number;\\n  }) => (\\n    <Table.Cell>\\n      <Checkbox\\n        onClick={() => onSelect(index, groupIndex, selected)}\\n        checkboxType={CheckboxTypes.check}\\n        checked={selected}\\n        inputProps={{ onChange: () => {} }}\\n      >\\n        {reachedMinWidth ? 'Select for download' : ''}\\n      </Checkbox>\\n    </Table.Cell>\\n  );\\n\\n  const EmptyCell = () => <Table.Cell />;\\n\\n  interface NotesCellProps {\\n    notes: string;\\n  }\\n\\n  const NotesCell: React.FC<NotesCellProps> = ({ notes }) => (\\n    <Table.Cell>\\n      <NoteField onChange={() => {}} rows={3} value={notes} />\\n    </Table.Cell>\\n  );\\n\\n  const sampleColumns: Columns = {\\n    selection: {\\n      name: '',\\n      headerCellComponent: SelectAllCell,\\n      width: selectionWidth,\\n      cellComponent: SelectionCell,\\n      sortable: false,\\n      groupCellComponent: EmptyCell,\\n      footerContent: '',\\n    },\\n    name: {\\n      name: 'Name',\\n      width: nameWidth,\\n      sortable: true,\\n    },\\n    title: {\\n      name: 'Title',\\n      width: titleWidth,\\n      sortable: true,\\n    },\\n    address: {\\n      name: 'Address',\\n      width: addressWidth,\\n    },\\n    notes: {\\n      name: 'Notes',\\n      width: notesWidth,\\n      cellComponent: NotesCell,\\n      minTableWidth: 800,\\n      sortFunction: (a: string, b: string) => a.length < b.length,\\n      groupCellComponent: EmptyCell,\\n    },\\n  };\\n\\n  if (!useDefaultExpansionColumn) {\\n    sampleColumns[ExpansionIconColumnName] = {\\n      name: '',\\n      sortable: false,\\n      width: args['Expansion Icon width'],\\n    };\\n  }\\n\\n  const position = groupLabelPosition;\\n\\n  return (\\n    <Table\\n      columns={sampleColumns}\\n      data={rows}\\n      sortGroups={sortGroups}\\n      groupHeaderPosition={position}\\n      areGroupsCollapsible={areGroupsCollapsible}\\n      expansionIconComponent={useCustomLabel ? expansionIconOverride : undefined}\\n      defaultSort={{\\n        sortedColumnKey: 'name',\\n        direction: Table.SortDirection.ascending,\\n      }}\\n    />\\n  );\\n};\\nGroups.args = {\\n  ...Default.args,\\n  'Use default expansion column': false,\\n  'Expansion Icon width': '1rem',\\n  groupLabelPosition: 'above',\\n  useCustomLabel: false,\\n  sortGroups: true,\\n  areGroupsCollapsible: false,\\n};\\n\\nexport default {\\n  title: 'Table',\\n  argTypes: {\\n    groupLabelPosition: {\\n      options: ['above', 'below'],\\n      control: {\\n        type: 'radio',\\n      },\\n    },\\n  },\\n  parameters: {\\n    design: {\\n      type: 'figma',\\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=102%3A86',\\n    },\\n  },\\n} as Meta;\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Default\":{\"startLoc\":{\"col\":44,\"line\":91},\"endLoc\":{\"col\":1,\"line\":227},\"startBody\":{\"col\":44,\"line\":91},\"endBody\":{\"col\":1,\"line\":227}},\"Groups\":{\"startLoc\":{\"col\":42,\"line\":246},\"endLoc\":{\"col\":1,\"line\":408},\"startBody\":{\"col\":42,\"line\":246},\"endBody\":{\"col\":1,\"line\":408}}};\n    \nimport React, { useState } from 'react';\nimport { Story, Meta } from '@storybook/react';\n\nimport styled from 'styled-components';\nimport Icon from '@mdi/react';\nimport { mdiClose } from '@mdi/js';\nimport { name, address, company, commerce } from 'faker';\n\nimport Table, { ExpansionIconColumnName } from './Table';\nimport Checkbox from '../Checkbox/Checkbox';\nimport { Columns, ExpansionIconProps, RowEntry } from './types';\nimport { CheckboxTypes } from '../../enums/checkboxTypes';\n\ntype SampleDataType = {\n  name?: string;\n  title?: string;\n  address?: string;\n  notes?: string;\n  isGroupLabel?: boolean;\n  selected?: boolean;\n};\n\n// Custom icon used for overriding the default collapse/expand icons\nconst expansionIconOverride = ({ isCollapsed, onClick }: ExpansionIconProps) => (\n  <Checkbox\n    checked={!isCollapsed}\n    onClick={onClick}\n    checkboxType={CheckboxTypes.check}\n    inputProps={{ onChange: () => {} }}\n  />\n);\n\nconst ActionCellContainer = styled(Table.Cell)`\n  cursor: pointer;\n  user-select: none;\n  font-size: 1rem;\n  &:hover {\n    color: red;\n  }\n`;\n\nconst NoteField = styled.textarea`\n  width: 100%;\n  height: 100%;\n  border-radius: 2px;\n  resize: none;\n`;\n\nconst generateSampleData = (rows: number): SampleDataType[] => {\n  const finalData: Array<RowEntry> = [];\n\n  for (let i = 0; i < rows; i += 1) {\n    finalData.push({\n      name: name.findName(),\n      title: name.title(),\n      address: address.streetAddress(),\n      notes: company.catchPhrase(),\n    });\n  }\n\n  return finalData;\n};\n\nconst generateSampleGroups = (numberOfGroups = 5, groupSize = 5): Array<SampleDataType[]> => {\n  const groupData: Array<Array<RowEntry>> = [];\n  for (let i = 0; i < numberOfGroups; i++) {\n    const groupRows = generateSampleData(groupSize);\n    // Add group title row\n    groupRows.push({\n      title: `${commerce.department()} Department`,\n      isGroupLabel: true,\n    });\n\n    groupData.push(groupRows);\n  }\n  return groupData;\n};\n\nconst sampleData = generateSampleData(10);\nconst sampleGroupData = generateSampleGroups();\n\ninterface DefaultProps {\n  'Selection width': string;\n  'Name width': string;\n  'Title width': string;\n  'Address width': string;\n  'Notes width': string;\n  'Action width': string;\n}\n\nexport const Default: Story<DefaultProps> = ({\n  'Selection width': selectionWidth,\n  'Name width': nameWidth,\n  'Title width': titleWidth,\n  'Address width': addressWidth,\n  'Notes width': notesWidth,\n  'Action width': actionWidth,\n}: DefaultProps) => {\n  const [rows, setRows] = useState(sampleData);\n\n  const onDelete = (index: number) => {\n    const newRows = [...rows];\n    newRows.splice(index, 1);\n    setRows(newRows);\n  };\n\n  const onSelect = (index: number, selected: boolean) => {\n    const newRows = [...rows];\n    newRows[index].selected = !selected;\n    setRows(newRows);\n  };\n\n  const selectAll = (event: React.MouseEvent) => {\n    const target = event.target as HTMLInputElement;\n    const currentlyChecked = target.checked;\n    const newRows = rows.map((row: SampleDataType) => ({ ...row, selected: currentlyChecked }));\n    setRows(newRows);\n  };\n\n  const SelectAllCell = () => {\n    const checkRowForSelection = (row: SampleDataType) =>\n      Object.prototype.hasOwnProperty.call(row, 'selected') && row.selected;\n\n    // TODO: don't use pointer-events to control if a column is sortable - it should be checked\n    // within the sorting listeners so that `sortable` doesn't need to be passed here just to give\n    // it pointer-events\n    return (\n      <Table.HeaderCell sortable>\n        <Checkbox\n          checkboxType={\n            rows.filter(checkRowForSelection).length === rows.length\n              ? CheckboxTypes.check\n              : CheckboxTypes.neutral\n          }\n          checked={Boolean(rows.filter(checkRowForSelection).length)}\n          onClick={e => selectAll(e)}\n          inputProps={{ onChange: () => {} }}\n        />\n      </Table.HeaderCell>\n    );\n  };\n\n  const SelectionCell = ({\n    index,\n    selected,\n    reachedMinWidth = false,\n  }: {\n    index: number;\n    selected: boolean;\n    // eslint-disable-next-line react/require-default-props\n    reachedMinWidth?: boolean;\n  }) => (\n    <Table.Cell>\n      <Checkbox\n        onClick={() => onSelect(index, selected)}\n        checkboxType={CheckboxTypes.check}\n        checked={selected}\n        inputProps={{ onChange: () => {} }}\n      >\n        {reachedMinWidth ? 'Select for download' : ''}\n      </Checkbox>\n    </Table.Cell>\n  );\n\n  const NotesCell = ({ notes }: { notes: string }) => (\n    <Table.Cell>\n      <NoteField onChange={() => {}} rows={3} value={notes} />\n    </Table.Cell>\n  );\n\n  const ActionCell = ({ index, reachedMinWidth }: { index: number; reachedMinWidth: boolean }) => (\n    <ActionCellContainer\n      onClick={() => {\n        onDelete(index);\n      }}\n    >\n      <Icon size=\"1rem\" path={mdiClose} />\n      &nbsp;&nbsp;\n      {reachedMinWidth ? 'Delete user' : ''}\n    </ActionCellContainer>\n  );\n\n  const sampleColumns: Columns = {\n    selection: {\n      name: '',\n      headerCellComponent: SelectAllCell,\n      width: selectionWidth,\n      cellComponent: SelectionCell,\n      sortable: false,\n      footerContent: '',\n    },\n    name: {\n      name: 'Name',\n      width: nameWidth,\n      footerContent: 'NameFooter',\n      sortable: true,\n    },\n    title: {\n      name: 'Title',\n      width: titleWidth,\n      footerContent: 'TitleFooter',\n    },\n    address: {\n      name: 'Address',\n      width: addressWidth,\n      footerContent: 'AddressFooter',\n    },\n    notes: {\n      name: 'Notes',\n      width: notesWidth,\n      cellComponent: NotesCell,\n      minTableWidth: 800,\n      sortable: true,\n      sortFunction: (a: string, b: string) => a.length < b.length,\n      footerContent: 'NotesFooter',\n    },\n    action: {\n      name: '',\n      sortable: false,\n      width: actionWidth,\n      cellComponent: ActionCell,\n      footerContent: '',\n    },\n  };\n\n  return <Table columns={sampleColumns} data={rows} />;\n};;\nDefault.args = {\n  'Selection width': '2rem',\n  'Name width': '1fr',\n  'Title width': '1fr',\n  'Address width': '1fr',\n  'Notes width': '12rem',\n  'Action width': '1rem',\n};\n\ninterface GroupsProps extends DefaultProps {\n  'Use default expansion column': boolean;\n  'Expansion Icon width': string;\n  groupLabelPosition: 'above' | 'below' | undefined;\n  useCustomLabel: boolean;\n  sortGroups: boolean;\n  areGroupsCollapsible: boolean;\n}\n\nexport const Groups: Story<GroupsProps> = ({\n  'Selection width': selectionWidth,\n  'Name width': nameWidth,\n  'Title width': titleWidth,\n  'Address width': addressWidth,\n  'Notes width': notesWidth,\n  'Use default expansion column': useDefaultExpansionColumn,\n  groupLabelPosition,\n  sortGroups,\n  areGroupsCollapsible,\n  useCustomLabel,\n  ...args\n}: GroupsProps) => {\n  const [rows, setRows] = useState(sampleGroupData);\n\n  const onSelect = (index = 0, groupIndex = 0, selected: boolean) => {\n    const newRows: SampleDataType[][] = [];\n    rows.forEach(grp => {\n      newRows.push([...grp]);\n    });\n\n    newRows[groupIndex][index].selected = !selected;\n    setRows(newRows);\n  };\n\n  const selectAll = (event: React.MouseEvent) => {\n    const target = event.target as HTMLInputElement;\n    const currentlyChecked = target.checked;\n    const newRows: SampleDataType[][] = [];\n    rows.forEach(group => {\n      newRows.push(\n        group.map(row => {\n          return { ...row, selected: currentlyChecked };\n        }),\n      );\n    });\n    setRows(newRows);\n  };\n\n  const SelectAllCell = () => {\n    let totalSelected = 0;\n    let totalCheckboxesAccumulator = 0;\n    rows.forEach(groupRows => {\n      groupRows.forEach(row => {\n        if (row.isGroupLabel) return;\n        if (row.selected) totalSelected++;\n        totalCheckboxesAccumulator++;\n      });\n    });\n    const allChecked = totalSelected === totalCheckboxesAccumulator;\n\n    // TODO: don't use pointer-events to control if a column is sortable - it should be checked\n    // within the sorting listeners so that `sortable` doesn't need to be passed here just to give\n    // it pointer-events\n    return (\n      <Table.HeaderCell sortable>\n        <Checkbox\n          checkboxType={allChecked ? CheckboxTypes.check : CheckboxTypes.neutral}\n          checked={Boolean(totalSelected)}\n          onClick={selectAll}\n          inputProps={{ onChange: () => {} }}\n        />\n      </Table.HeaderCell>\n    );\n  };\n\n  const SelectionCell = ({\n    index = 0,\n    selected,\n    reachedMinWidth = false,\n    groupIndex = 0,\n  }: {\n    // eslint-disable-next-line react/require-default-props\n    index?: number;\n    selected: boolean;\n    // eslint-disable-next-line react/require-default-props\n    reachedMinWidth?: boolean;\n    // eslint-disable-next-line react/require-default-props\n    groupIndex?: number;\n  }) => (\n    <Table.Cell>\n      <Checkbox\n        onClick={() => onSelect(index, groupIndex, selected)}\n        checkboxType={CheckboxTypes.check}\n        checked={selected}\n        inputProps={{ onChange: () => {} }}\n      >\n        {reachedMinWidth ? 'Select for download' : ''}\n      </Checkbox>\n    </Table.Cell>\n  );\n\n  const EmptyCell = () => <Table.Cell />;\n\n  interface NotesCellProps {\n    notes: string;\n  }\n\n  const NotesCell: React.FC<NotesCellProps> = ({ notes }) => (\n    <Table.Cell>\n      <NoteField onChange={() => {}} rows={3} value={notes} />\n    </Table.Cell>\n  );\n\n  const sampleColumns: Columns = {\n    selection: {\n      name: '',\n      headerCellComponent: SelectAllCell,\n      width: selectionWidth,\n      cellComponent: SelectionCell,\n      sortable: false,\n      groupCellComponent: EmptyCell,\n      footerContent: '',\n    },\n    name: {\n      name: 'Name',\n      width: nameWidth,\n      sortable: true,\n    },\n    title: {\n      name: 'Title',\n      width: titleWidth,\n      sortable: true,\n    },\n    address: {\n      name: 'Address',\n      width: addressWidth,\n    },\n    notes: {\n      name: 'Notes',\n      width: notesWidth,\n      cellComponent: NotesCell,\n      minTableWidth: 800,\n      sortFunction: (a: string, b: string) => a.length < b.length,\n      groupCellComponent: EmptyCell,\n    },\n  };\n\n  if (!useDefaultExpansionColumn) {\n    sampleColumns[ExpansionIconColumnName] = {\n      name: '',\n      sortable: false,\n      width: args['Expansion Icon width'],\n    };\n  }\n\n  const position = groupLabelPosition;\n\n  return (\n    <Table\n      columns={sampleColumns}\n      data={rows}\n      sortGroups={sortGroups}\n      groupHeaderPosition={position}\n      areGroupsCollapsible={areGroupsCollapsible}\n      expansionIconComponent={useCustomLabel ? expansionIconOverride : undefined}\n      defaultSort={{\n        sortedColumnKey: 'name',\n        direction: Table.SortDirection.ascending,\n      }}\n    />\n  );\n};\nGroups.args = {\n  ...Default.args,\n  'Use default expansion column': false,\n  'Expansion Icon width': '1rem',\n  groupLabelPosition: 'above',\n  useCustomLabel: false,\n  sortGroups: true,\n  areGroupsCollapsible: false,\n};\n\nexport default {\n  title: 'Table',\n  argTypes: {\n    groupLabelPosition: {\n      options: ['above', 'below'],\n      control: {\n        type: 'radio',\n      },\n    },\n  },\n  parameters: {\n    design: {\n      type: 'figma',\n      url: 'https://www.figma.com/file/3r2G00brulOwr9j7F6JF59/Generic-UI-Style?node-id=102%3A86',\n    },\n  },\n} as Meta;\n\n\n\nDefault.parameters = { storySource: { source: \"({\\n  'Selection width': selectionWidth,\\n  'Name width': nameWidth,\\n  'Title width': titleWidth,\\n  'Address width': addressWidth,\\n  'Notes width': notesWidth,\\n  'Action width': actionWidth,\\n}: DefaultProps) => {\\n  const [rows, setRows] = useState(sampleData);\\n\\n  const onDelete = (index: number) => {\\n    const newRows = [...rows];\\n    newRows.splice(index, 1);\\n    setRows(newRows);\\n  };\\n\\n  const onSelect = (index: number, selected: boolean) => {\\n    const newRows = [...rows];\\n    newRows[index].selected = !selected;\\n    setRows(newRows);\\n  };\\n\\n  const selectAll = (event: React.MouseEvent) => {\\n    const target = event.target as HTMLInputElement;\\n    const currentlyChecked = target.checked;\\n    const newRows = rows.map((row: SampleDataType) => ({ ...row, selected: currentlyChecked }));\\n    setRows(newRows);\\n  };\\n\\n  const SelectAllCell = () => {\\n    const checkRowForSelection = (row: SampleDataType) =>\\n      Object.prototype.hasOwnProperty.call(row, 'selected') && row.selected;\\n\\n    // TODO: don't use pointer-events to control if a column is sortable - it should be checked\\n    // within the sorting listeners so that `sortable` doesn't need to be passed here just to give\\n    // it pointer-events\\n    return (\\n      <Table.HeaderCell sortable>\\n        <Checkbox\\n          checkboxType={\\n            rows.filter(checkRowForSelection).length === rows.length\\n              ? CheckboxTypes.check\\n              : CheckboxTypes.neutral\\n          }\\n          checked={Boolean(rows.filter(checkRowForSelection).length)}\\n          onClick={e => selectAll(e)}\\n          inputProps={{ onChange: () => {} }}\\n        />\\n      </Table.HeaderCell>\\n    );\\n  };\\n\\n  const SelectionCell = ({\\n    index,\\n    selected,\\n    reachedMinWidth = false,\\n  }: {\\n    index: number;\\n    selected: boolean;\\n    \\n    reachedMinWidth?: boolean;\\n  }) => (\\n    <Table.Cell>\\n      <Checkbox\\n        onClick={() => onSelect(index, selected)}\\n        checkboxType={CheckboxTypes.check}\\n        checked={selected}\\n        inputProps={{ onChange: () => {} }}\\n      >\\n        {reachedMinWidth ? 'Select for download' : ''}\\n      </Checkbox>\\n    </Table.Cell>\\n  );\\n\\n  const NotesCell = ({ notes }: { notes: string }) => (\\n    <Table.Cell>\\n      <NoteField onChange={() => {}} rows={3} value={notes} />\\n    </Table.Cell>\\n  );\\n\\n  const ActionCell = ({ index, reachedMinWidth }: { index: number; reachedMinWidth: boolean }) => (\\n    <ActionCellContainer\\n      onClick={() => {\\n        onDelete(index);\\n      }}\\n    >\\n      <Icon size=\\\"1rem\\\" path={mdiClose} />\\n      &nbsp;&nbsp;\\n      {reachedMinWidth ? 'Delete user' : ''}\\n    </ActionCellContainer>\\n  );\\n\\n  const sampleColumns: Columns = {\\n    selection: {\\n      name: '',\\n      headerCellComponent: SelectAllCell,\\n      width: selectionWidth,\\n      cellComponent: SelectionCell,\\n      sortable: false,\\n      footerContent: '',\\n    },\\n    name: {\\n      name: 'Name',\\n      width: nameWidth,\\n      footerContent: 'NameFooter',\\n      sortable: true,\\n    },\\n    title: {\\n      name: 'Title',\\n      width: titleWidth,\\n      footerContent: 'TitleFooter',\\n    },\\n    address: {\\n      name: 'Address',\\n      width: addressWidth,\\n      footerContent: 'AddressFooter',\\n    },\\n    notes: {\\n      name: 'Notes',\\n      width: notesWidth,\\n      cellComponent: NotesCell,\\n      minTableWidth: 800,\\n      sortable: true,\\n      sortFunction: (a: string, b: string) => a.length < b.length,\\n      footerContent: 'NotesFooter',\\n    },\\n    action: {\\n      name: '',\\n      sortable: false,\\n      width: actionWidth,\\n      cellComponent: ActionCell,\\n      footerContent: '',\\n    },\\n  };\\n\\n  return <Table columns={sampleColumns} data={rows} />;\\n}\" }, ...Default.parameters };\nGroups.parameters = { storySource: { source: \"({\\n  'Selection width': selectionWidth,\\n  'Name width': nameWidth,\\n  'Title width': titleWidth,\\n  'Address width': addressWidth,\\n  'Notes width': notesWidth,\\n  'Use default expansion column': useDefaultExpansionColumn,\\n  groupLabelPosition,\\n  sortGroups,\\n  areGroupsCollapsible,\\n  useCustomLabel,\\n  ...args\\n}: GroupsProps) => {\\n  const [rows, setRows] = useState(sampleGroupData);\\n\\n  const onSelect = (index = 0, groupIndex = 0, selected: boolean) => {\\n    const newRows: SampleDataType[][] = [];\\n    rows.forEach(grp => {\\n      newRows.push([...grp]);\\n    });\\n\\n    newRows[groupIndex][index].selected = !selected;\\n    setRows(newRows);\\n  };\\n\\n  const selectAll = (event: React.MouseEvent) => {\\n    const target = event.target as HTMLInputElement;\\n    const currentlyChecked = target.checked;\\n    const newRows: SampleDataType[][] = [];\\n    rows.forEach(group => {\\n      newRows.push(\\n        group.map(row => {\\n          return { ...row, selected: currentlyChecked };\\n        }),\\n      );\\n    });\\n    setRows(newRows);\\n  };\\n\\n  const SelectAllCell = () => {\\n    let totalSelected = 0;\\n    let totalCheckboxesAccumulator = 0;\\n    rows.forEach(groupRows => {\\n      groupRows.forEach(row => {\\n        if (row.isGroupLabel) return;\\n        if (row.selected) totalSelected++;\\n        totalCheckboxesAccumulator++;\\n      });\\n    });\\n    const allChecked = totalSelected === totalCheckboxesAccumulator;\\n\\n    // TODO: don't use pointer-events to control if a column is sortable - it should be checked\\n    // within the sorting listeners so that `sortable` doesn't need to be passed here just to give\\n    // it pointer-events\\n    return (\\n      <Table.HeaderCell sortable>\\n        <Checkbox\\n          checkboxType={allChecked ? CheckboxTypes.check : CheckboxTypes.neutral}\\n          checked={Boolean(totalSelected)}\\n          onClick={selectAll}\\n          inputProps={{ onChange: () => {} }}\\n        />\\n      </Table.HeaderCell>\\n    );\\n  };\\n\\n  const SelectionCell = ({\\n    index = 0,\\n    selected,\\n    reachedMinWidth = false,\\n    groupIndex = 0,\\n  }: {\\n    \\n    index?: number;\\n    selected: boolean;\\n    \\n    reachedMinWidth?: boolean;\\n    \\n    groupIndex?: number;\\n  }) => (\\n    <Table.Cell>\\n      <Checkbox\\n        onClick={() => onSelect(index, groupIndex, selected)}\\n        checkboxType={CheckboxTypes.check}\\n        checked={selected}\\n        inputProps={{ onChange: () => {} }}\\n      >\\n        {reachedMinWidth ? 'Select for download' : ''}\\n      </Checkbox>\\n    </Table.Cell>\\n  );\\n\\n  const EmptyCell = () => <Table.Cell />;\\n\\n  interface NotesCellProps {\\n    notes: string;\\n  }\\n\\n  const NotesCell: React.FC<NotesCellProps> = ({ notes }) => (\\n    <Table.Cell>\\n      <NoteField onChange={() => {}} rows={3} value={notes} />\\n    </Table.Cell>\\n  );\\n\\n  const sampleColumns: Columns = {\\n    selection: {\\n      name: '',\\n      headerCellComponent: SelectAllCell,\\n      width: selectionWidth,\\n      cellComponent: SelectionCell,\\n      sortable: false,\\n      groupCellComponent: EmptyCell,\\n      footerContent: '',\\n    },\\n    name: {\\n      name: 'Name',\\n      width: nameWidth,\\n      sortable: true,\\n    },\\n    title: {\\n      name: 'Title',\\n      width: titleWidth,\\n      sortable: true,\\n    },\\n    address: {\\n      name: 'Address',\\n      width: addressWidth,\\n    },\\n    notes: {\\n      name: 'Notes',\\n      width: notesWidth,\\n      cellComponent: NotesCell,\\n      minTableWidth: 800,\\n      sortFunction: (a: string, b: string) => a.length < b.length,\\n      groupCellComponent: EmptyCell,\\n    },\\n  };\\n\\n  if (!useDefaultExpansionColumn) {\\n    sampleColumns[ExpansionIconColumnName] = {\\n      name: '',\\n      sortable: false,\\n      width: args['Expansion Icon width'],\\n    };\\n  }\\n\\n  const position = groupLabelPosition;\\n\\n  return (\\n    <Table\\n      columns={sampleColumns}\\n      data={rows}\\n      sortGroups={sortGroups}\\n      groupHeaderPosition={position}\\n      areGroupsCollapsible={areGroupsCollapsible}\\n      expansionIconComponent={useCustomLabel ? expansionIconOverride : undefined}\\n      defaultSort={{\\n        sortedColumnKey: 'name',\\n        direction: Table.SortDirection.ascending,\\n      }}\\n    />\\n  );\\n}\" }, ...Groups.parameters };","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport styled from 'styled-components';\nimport React, { ReactNode } from 'react';\nimport { darken, lighten, readableColor } from 'polished';\nimport { StyledBaseSpan } from '../../htmlElements';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport Skeleton from '../Skeleton/Skeleton';\nimport { useTheme } from '../../context';\n\nexport type AvatarContainerProps = {\n  size: number;\n  borderRadiusPercent: number;\n  imgURL?: string;\n  color: string;\n  isLoading: boolean;\n};\n\nexport type AvatarTextProps = {\n  size: number;\n  textColor: string;\n};\n\nexport type AvatarProps = {\n  placeholder?: string | ReactNode;\n  children?: ReactNode;\n  imgURL?: string;\n  size?: number;\n  color?: string;\n  borderRadiusPercent?: number;\n  isLoading?: boolean;\n\n  StyledContainer?: StyledSubcomponentType;\n  StyledText?: StyledSubcomponentType;\n  StyledShimmer?: StyledSubcomponentType;\n  containerProps?: SubcomponentPropsType;\n  textProps?: SubcomponentPropsType;\n  shimmerProps?: SubcomponentPropsType;\n  containerRef?: React.RefObject<HTMLDivElement>;\n  textRef?: React.RefObject<HTMLSpanElement>;\n  shimmerRef?: React.RefObject<HTMLDivElement>;\n};\n\nexport const AvatarContainer = styled(Skeleton.Container)`\n  ${({ size, borderRadiusPercent, imgURL, isLoading, color }: AvatarContainerProps) => {\n    if (imgURL && !isLoading) {\n      return `\n        border-radius: ${borderRadiusPercent}%;\n        overflow: hidden;\n        width: ${size}em;\n        height: ${size}em;\n        background-image: url(${imgURL});\n        background-size: cover;\n      `;\n    }\n    return `\n      display: flex;\n      border-radius: ${borderRadiusPercent}%;\n      padding: 1em;\n      width: ${size}em;\n      height: ${size}em;\n      background-color: ${color};\n      justify-content: center;\n      align-items: center;\n    `;\n  }}\n`;\n\nexport const AvatarText = styled(StyledBaseSpan)`\n  ${({ size, textColor }: AvatarTextProps) => {\n    return `\n      color: ${textColor};\n      font-size: ${size / 3}em; \n      font-weight: 600;\n      `;\n  }};\n`;\n\nexport const AvatarShimmer = styled(Skeleton.Shimmer)`\n  ${({ borderRadiusPercent }: Pick<AvatarProps, 'borderRadiusPercent'>) =>\n    `\n      border-radius: ${borderRadiusPercent}%;\n    `}\n`;\n\nconst Avatar = ({\n  placeholder,\n  children,\n  imgURL,\n  size = 1.5,\n  borderRadiusPercent = 50,\n  color: initialColor,\n  isLoading = false,\n  StyledContainer = AvatarContainer,\n  StyledText = AvatarText,\n  StyledShimmer = AvatarShimmer,\n  textProps = {},\n  containerProps = {},\n  shimmerProps = {},\n  containerRef,\n  textRef,\n  shimmerRef,\n}: AvatarProps): JSX.Element => {\n  const { colors } = useTheme();\n  const color = initialColor || colors.grayXlight;\n  const fontColor = readableColor(color, colors.grayMedium, colors.background);\n  const shimmerColor = fontColor === colors.background ? lighten(0.2, color!) : darken(0.2, color!);\n  return (\n    <Skeleton\n      isLoading={isLoading}\n      color={shimmerColor}\n      StyledContainer={StyledContainer}\n      containerProps={{\n        size,\n        borderRadiusPercent,\n        imgURL,\n        color,\n        ...containerProps,\n        ref: containerRef,\n      }}\n      shimmerProps={{ borderRadiusPercent, ...shimmerProps, ref: shimmerRef }}\n      StyledShimmer={StyledShimmer}\n    >\n      {children}\n      {!imgURL ? (\n        <StyledText {...textProps} ref={textRef} size={size} textColor={fontColor}>\n          {placeholder}\n        </StyledText>\n      ) : (\n        ''\n      )}\n    </Skeleton>\n  );\n};\n\nAvatar.Container = AvatarContainer;\nAvatar.Text = AvatarText;\n\nexport default Avatar;\n","import React, { ComponentProps, PropsWithChildren, ReactNode } from 'react';\nimport UnstyledIcon from '@mdi/react';\nimport { mdiLoading } from '@mdi/js';\nimport styled from 'styled-components';\nimport { darken } from 'polished';\n\nimport FeedbackTypes from '../../enums/feedbackTypes';\nimport timings from '../../enums/timings';\nimport { useAnalytics, useTheme } from '../../context';\nimport variants from '../../enums/variants';\nimport Skeleton from '../Skeleton/Skeleton';\nimport Progress from '../Progress/Progress';\nimport { StyledBaseDiv, StyledBaseButton } from '../../htmlElements';\nimport {\n  getFontColorFromVariant,\n  getBackgroundColorFromVariant,\n  disabledStyles,\n} from '../../utils/color';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { getShadowStyle } from '../../utils/styles';\nimport InteractionFeedback from '../InteractionFeedback';\nimport { InteractionFeedbackProps } from '../InteractionFeedback/InteractionFeedback';\n\nexport type ButtonContainerProps = React.HTMLProps<HTMLButtonElement> & {\n  elevation: number;\n  color: string;\n  variant: variants;\n  type: string;\n  disabled: boolean;\n  feedbackType: FeedbackTypes;\n  isLoading?: boolean;\n};\n\nexport enum ButtonTypes {\n  button = 'button',\n  reset = 'reset',\n  submit = 'submit',\n}\n\nexport type ButtonProps = {\n  StyledContainer?: StyledSubcomponentType<any>;\n  // TODO: rename these to StyledIconPrefixContainer - etc\n  StyledLeftIconContainer?: StyledSubcomponentType;\n  StyledRightIconContainer?: StyledSubcomponentType;\n\n  skeletonShimmerProps?: ComponentProps<typeof Skeleton.Shimmer>;\n  /**\n   * @deprecated The ProgressBar loading skeleton is being replaced by the Skeleton component - use skeletonShimmerProps to customize the Skeleton wrapping the button.\n   */\n  ProgressBar?: JSX.Element | null;\n\n  containerRef?: React.RefObject<HTMLButtonElement>;\n  // TODO: rename these to iconPrefixContainerRef - etc\n  leftIconContainerRef?: React.RefObject<HTMLDivElement>;\n  rightIconContainerRef?: React.RefObject<HTMLDivElement>;\n\n  containerProps?: SubcomponentPropsType;\n  interactionFeedbackProps?: Omit<InteractionFeedbackProps, 'children'>;\n  // TODO: rename these to iconPrefixProps - etc\n  leftIconProps?: SubcomponentPropsType;\n  rightIconProps?: SubcomponentPropsType;\n\n  children?: ReactNode;\n\n  id?: string;\n  disabled?: boolean;\n  elevation?: number;\n  variant?: variants;\n  type?: ButtonTypes;\n  color?: string;\n  feedbackType?: FeedbackTypes;\n  iconPrefix?: string | JSX.Element;\n  iconSuffix?: string | JSX.Element;\n  isLoading?: boolean;\n  isProcessing?: boolean;\n\n  onClick?: React.MouseEventHandler<HTMLButtonElement>;\n  onBlur?: (e: React.FocusEvent) => void;\n  onFocus?: (e: React.FocusEvent) => void;\n  onMouseDown?: (e: React.MouseEvent) => void;\n  onMouseUp?: (e: React.MouseEvent) => void;\n};\n\nconst SkeletonButtonContainer = React.forwardRef(\n  (props: PropsWithChildren<SubcomponentPropsType>, ref) => (\n    <Skeleton.Container ref={ref} as={StyledBaseButton} {...props}>\n      {props.children}\n    </Skeleton.Container>\n  ),\n);\n\nexport const ButtonContainer: StyledSubcomponentType = styled(SkeletonButtonContainer)`\n  ${({ disabled, elevation = 0, color, variant, feedbackType }: ButtonContainerProps) => {\n    const { colors } = useTheme();\n    const backgroundColor = getBackgroundColorFromVariant(variant, color, colors.transparent);\n    const fontColor = getFontColorFromVariant(variant, color, colors.background, colors.grayDark);\n\n    return `\n      -webkit-appearance: none;\n      display: inline-flex;\n      align-items: baseline;\n      position: relative;\n      font-size: 1em;\n      padding: .75em 1em;\n      border-radius: 0.25em;\n      transition:\n        background-color ${timings.fast},\n        color ${timings.slow},\n        outline ${timings.slow},\n        filter ${timings.slow},\n        box-shadow ${timings.slow};\n      ${getShadowStyle(elevation, colors.shadow)}\n      outline: 0 none;\n      border: ${\n        variant === variants.outline\n          ? `1px solid ${color || colors.grayDark}`\n          : '1px solid transparent'\n      };\n      cursor: pointer;\n      background-color: ${backgroundColor};\n      color: ${fontColor};\n      user-select: none;\n      align-items: center;\n      ${disabled ? disabledStyles() : ''}\n      &:hover {\n        background-color: ${\n          backgroundColor !== 'transparent' ? darken(0.05, backgroundColor) : 'rgba(0, 0, 0, 0.05)'\n        };\n      }\n      &:focus {\n        outline: none;\n        box-shadow: 0 0 5px 0.150rem ${colors.tertiaryDark};\n      }\n      ${\n        feedbackType === FeedbackTypes.simple\n          ? `\n            &:active {\n              background-color: ${\n                backgroundColor !== 'transparent'\n                  ? darken(0.1, backgroundColor)\n                  : 'rgba(0, 0, 0, 0.1)'\n              };\n            }\n          `\n          : ''\n      }\n    `;\n  }}\n`;\n\nconst IconContainer = styled(StyledBaseDiv)`\n  vertical-align: middle;\n`;\n\nconst StyledFeedbackContainer = styled(InteractionFeedback.Container)`\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n`;\n\nconst StyledFeedbackSVGContainer = styled(InteractionFeedback.SVGContainer)`\n  border-radius: 0.25em;\n`;\n\nconst LeftIconContainer = styled(IconContainer)`\n  ${({ hasContent }: { hasContent: boolean }) => `\n    ${hasContent ? 'margin-right: 0.75em;' : ''}\n  `}\n`;\n\nconst RightIconContainer = styled(IconContainer)`\n  ${({ hasContent }: { hasContent: boolean }) => `\n    ${hasContent ? 'margin-left: 0.75em;' : ''}\n  `}\n`;\n\nconst Button = ({\n  StyledContainer = ButtonContainer,\n  StyledLeftIconContainer = LeftIconContainer,\n  StyledRightIconContainer = RightIconContainer,\n\n  skeletonShimmerProps,\n  /**\n   * @deprecated The ProgressBar loading skeleton is being replaced by the Skeleton component - use skeletonShimmerProps to customize the Skeleton wrapping the button.\n   */\n  ProgressBar, // Deprecated\n\n  containerProps = {},\n  interactionFeedbackProps,\n  leftIconProps = {},\n  rightIconProps = {},\n\n  containerRef,\n  leftIconContainerRef,\n  rightIconContainerRef,\n\n  iconPrefix,\n  iconSuffix,\n  isLoading,\n  isProcessing,\n  children,\n  elevation = 0,\n  feedbackType = FeedbackTypes.ripple,\n  variant = variants.fill,\n  type = ButtonTypes.button,\n  color,\n  disabled = false,\n  onClick = () => {},\n  onBlur = () => {},\n  onFocus = () => {},\n  onMouseDown = () => {},\n  onMouseUp = () => {},\n  id,\n}: ButtonProps): JSX.Element | null => {\n  const hasContent = Boolean(children);\n  const { colors } = useTheme();\n  const containerColor = color || colors.grayLight;\n  const handleEventWithAnalytics = useAnalytics();\n\n  // get everything we expose + anything consumer wants to send to container\n  const mergedContainerProps: ButtonContainerProps = {\n    id,\n    isLoading,\n    role: 'button',\n    ref: containerRef,\n    elevation,\n    color: containerColor,\n    variant,\n    type,\n    disabled,\n    feedbackType,\n    onClick: e => handleEventWithAnalytics('Button', onClick, 'onClick', e, containerProps),\n    onBlur: e => handleEventWithAnalytics('Button', onBlur, 'onBlur', e, containerProps),\n    onFocus: e => handleEventWithAnalytics('Button', onFocus, 'onFocus', e, containerProps),\n    onMouseDown: e =>\n      handleEventWithAnalytics('Button', onMouseDown, 'onMouseDown', e, containerProps),\n    onMouseUp: e => handleEventWithAnalytics('Button', onMouseUp, 'onMouseUp', e, containerProps),\n    ...containerProps,\n  };\n\n  return (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-expect-error \"as\" not allowed on StyledSubcomponentType. Passing as prop through containerProps still works.\n    <StyledContainer {...mergedContainerProps}>\n      {!isProcessing &&\n        iconPrefix &&\n        (typeof iconPrefix === 'string' && iconPrefix !== '' ? (\n          <StyledLeftIconContainer hasContent={hasContent} ref={leftIconContainerRef}>\n            <UnstyledIcon path={iconPrefix} size=\"1em\" {...leftIconProps} />\n          </StyledLeftIconContainer>\n        ) : (\n          <StyledLeftIconContainer ref={leftIconContainerRef}>{iconPrefix}</StyledLeftIconContainer>\n        ))}\n      {isProcessing && (\n        <StyledLeftIconContainer hasContent={hasContent} ref={leftIconContainerRef}>\n          <UnstyledIcon path={mdiLoading} size=\"1em\" spin={1} />\n        </StyledLeftIconContainer>\n      )}\n      {isLoading && ProgressBar ? <Progress /> : children}\n      {iconSuffix &&\n        (typeof iconSuffix === 'string' ? (\n          <StyledRightIconContainer hasContent={hasContent} ref={rightIconContainerRef}>\n            <UnstyledIcon path={iconSuffix} size=\"1em\" {...rightIconProps} />\n          </StyledRightIconContainer>\n        ) : (\n          <StyledRightIconContainer hasContent={hasContent} ref={rightIconContainerRef}>\n            {iconSuffix}\n          </StyledRightIconContainer>\n        ))}\n      {feedbackType === FeedbackTypes.ripple && !disabled && !isLoading && (\n        <InteractionFeedback\n          StyledContainer={StyledFeedbackContainer}\n          StyledSVGContainer={StyledFeedbackSVGContainer}\n          color={getFontColorFromVariant(variant, containerColor)}\n          {...(interactionFeedbackProps || {})}\n        />\n      )}\n      <Skeleton.Shimmer\n        color={getFontColorFromVariant(variant, containerColor, colors.background, colors.grayDark)}\n        isLoading={isLoading}\n        {...skeletonShimmerProps}\n      />\n    </StyledContainer>\n  );\n};\n\nButton.Container = ButtonContainer;\nButton.ButtonTypes = ButtonTypes;\nButton.LeftIconContainer = LeftIconContainer;\nButton.RightIconContainer = RightIconContainer;\n\nexport default Button;\n","import React, { ReactNode, MouseEvent } from 'react';\nimport styled from 'styled-components';\nimport { darken } from 'polished';\n\nimport timings from '../../enums/timings';\nimport { StyledBaseDiv } from '../../htmlElements';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { useAnalytics, useTheme } from '../../context';\nimport { getShadowStyle } from '../../utils/styles';\nimport InteractionFeedback, {\n  InteractionFeedbackProps,\n} from '../InteractionFeedback/InteractionFeedback';\nimport FeedbackTypes from '../../enums/feedbackTypes';\n\nconst defaultOnClick = () => {};\n\nexport type CardContainerProps = {\n  elevation: number;\n  feedbackType: FeedbackTypes;\n  isDefaultOnClick: boolean;\n};\n\nexport const CardContainer = styled(StyledBaseDiv)`\n  ${({ elevation, feedbackType, isDefaultOnClick }: CardContainerProps) => {\n    const { colors } = useTheme();\n\n    return `\n      ${!isDefaultOnClick ? 'cursor: pointer;' : ''}\n      position: relative;\n      display: inline-flex;\n      flex-flow: column nowrap;\n      font-size: 1em;\n      border-radius: 0.25rem;\n      border: ${!elevation ? `1px solid ${colors.grayXlight}` : '0px solid transparent'};\n      transition:\n        filter ${timings.slow},\n        box-shadow ${timings.slow},\n        border ${timings.normal},\n        background-color ${timings.normal};\n      ${getShadowStyle(elevation, colors.shadow)}\n      background-color: ${colors.background};\n      ${\n        feedbackType === FeedbackTypes.simple && !isDefaultOnClick\n          ? `\n            &:active {\n              background-color: ${\n                colors.background !== 'transparent'\n                  ? darken(0.1, colors.background)\n                  : 'rgba(0, 0, 0, 0.1)'\n              };\n            }\n          `\n          : ''\n      }\n  `;\n  }}\n`;\n\nexport const Header = styled(StyledBaseDiv)`\n  ${({ hasBody, hasFooter }) => {\n    const { colors } = useTheme();\n\n    return `\n      padding: 1.5em 1.5em ${hasBody || hasFooter ? '0em' : ''};\n      border-radius: 0.25rem 0.25rem 0rem 0rem;\n      font-weight: bold;\n      color: ${colors.grayDark};\n    `;\n  }}\n`;\n\nexport const NoPaddingHeader = styled(Header)`\n  padding: 0;\n`;\n\nexport const Body = styled(StyledBaseDiv)`\n  ${() => {\n    const { colors } = useTheme();\n\n    return `\n      padding: 1.5em 1.5em;\n      color: ${colors.grayMedium};\n    `;\n  }}\n`;\n\nexport const Footer = styled(StyledBaseDiv)`\n  ${() => {\n    const { colors } = useTheme();\n\n    return `\n      padding: 1em 1.5em;\n      display: flex;\n      flex-flow: row wrap;\n\n      justify-content: flex-end;\n\n      color: ${colors.grayLight};\n\n      border-radius: 0rem 0rem 0.25rem 0.25rem;\n    `;\n  }}\n`;\n\nconst StyledFeedbackContainer = styled(InteractionFeedback.Container)`\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n`;\nexport interface CardProps {\n  StyledContainer?: StyledSubcomponentType;\n  StyledHeader?: StyledSubcomponentType;\n  StyledBody?: StyledSubcomponentType;\n  StyledFooter?: StyledSubcomponentType;\n\n  containerProps?: SubcomponentPropsType;\n  headerProps?: SubcomponentPropsType;\n  bodyProps?: SubcomponentPropsType;\n  footerProps?: SubcomponentPropsType;\n  interactionFeedbackProps?: Omit<InteractionFeedbackProps, 'children'>;\n\n  onClick?: (evt: MouseEvent) => void;\n\n  header?: ReactNode;\n  children?: ReactNode;\n  footer?: ReactNode;\n\n  elevation?: number;\n  disableFeedback?: boolean;\n  feedbackType?: FeedbackTypes;\n\n  containerRef?: React.RefObject<HTMLDivElement>;\n  headerRef?: React.RefObject<HTMLDivElement>;\n  bodyRef?: React.RefObject<HTMLDivElement>;\n  footerRef?: React.RefObject<HTMLDivElement>;\n  interactiveFeedbackRef?: React.RefObject<HTMLDivElement>;\n}\n\nconst Card = ({\n  StyledContainer = CardContainer,\n  StyledHeader = Header,\n  StyledBody = Body,\n  StyledFooter = Footer,\n\n  containerProps,\n  headerProps,\n  bodyProps,\n  footerProps,\n  interactionFeedbackProps,\n\n  containerRef,\n  headerRef,\n  bodyRef,\n  footerRef,\n  interactiveFeedbackRef,\n\n  onClick = defaultOnClick,\n\n  header,\n  children,\n  footer,\n\n  elevation = 1,\n  feedbackType = FeedbackTypes.ripple,\n}: CardProps): JSX.Element | null => {\n  const transitionProps = {\n    ...InteractionFeedback.defaultTransitionProps,\n    enter: {\n      ...InteractionFeedback.defaultTransitionProps,\n      r: 300,\n    },\n  };\n  const hasHeader = Boolean(header);\n  const hasBody = Boolean(children);\n  const hasFooter = Boolean(footer);\n\n  const handleEventWithAnalytics = useAnalytics();\n  const handleClick = (e: any) =>\n    handleEventWithAnalytics('Card', onClick, 'onClick', e, containerProps || { name: 'Card' });\n  const isDefaultOnClick = onClick === defaultOnClick;\n\n  return (\n    <StyledContainer\n      onClick={handleClick}\n      elevation={elevation}\n      feedbackType={feedbackType}\n      isDefaultOnClick={isDefaultOnClick}\n      {...containerProps}\n      ref={containerRef}\n    >\n      {header && (\n        <StyledHeader hasBody={hasBody} hasFooter={hasFooter} ref={headerRef} {...headerProps}>\n          {header}\n        </StyledHeader>\n      )}\n      {children && (\n        <StyledBody hasHeader={hasHeader} hasFooter={hasFooter} ref={bodyRef} {...bodyProps}>\n          {children}\n        </StyledBody>\n      )}\n      {footer && (\n        <StyledFooter hasHeader={hasHeader} hasBody={hasBody} ref={footerRef} {...footerProps}>\n          {footer}\n        </StyledFooter>\n      )}\n      {feedbackType !== FeedbackTypes.simple && onClick !== defaultOnClick && (\n        <InteractionFeedback\n          color=\"rgba(0,0,0,0.1)\"\n          transitionProps={transitionProps}\n          StyledContainer={StyledFeedbackContainer}\n          containerRef={interactiveFeedbackRef}\n          {...interactionFeedbackProps}\n        />\n      )}\n    </StyledContainer>\n  );\n};\n\nCard.Header = Header;\nCard.NoPaddingHeader = NoPaddingHeader;\nCard.Footer = Footer;\nCard.Body = Body;\nCard.Container = CardContainer;\n\nexport default Card;\n","import React, { RefObject } from 'react';\nimport styled from 'styled-components';\nimport Icon from '@mdi/react';\nimport { mdiCheck, mdiCheckboxBlank, mdiClose, mdiMinus } from '@mdi/js';\n\nimport { darken } from 'polished';\nimport { useCheckbox } from 'react-aria';\nimport { useToggleState } from '@react-stately/toggle';\nimport { StyledBaseDiv, StyledBaseInput, StyledBaseLabel } from '../../htmlElements';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { useAnalytics, useTheme } from '../../context';\nimport variants from '../../enums/variants';\nimport CheckboxTypes from '../../enums/checkboxTypes';\nimport { disabledStyles } from '../../utils/color';\nimport { mergeRefs } from '../../utils/refs';\n\n// Hide checkbox visually but remain accessible to screen readers.\n// Source: https://polished.js.org/docs/#hidevisually\nexport const Input = styled(StyledBaseInput).attrs({ type: 'checkbox' })`\n  border: 0;\n  clip: rect(0 0 0 0);\n  clippath: inset(50%);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n`;\n\nexport const Label = styled(StyledBaseLabel)`\n  ${({ disabled }) => {\n    return `\n      display: flex;\n      align-items: center;\n      cursor: pointer;\n      height: 2em;\n      font-size: 1em;\n      \n      ${disabled ? disabledStyles() : ''}\n    `;\n  }}\n`;\n\nexport const Box = styled(StyledBaseDiv)`\n  ${({ variant, checked, checkboxType }) => {\n    const { colors } = useTheme();\n    let color = colors.grayLight;\n    if (checkboxType === CheckboxTypes.check && checked) color = colors.success;\n    if (checkboxType === CheckboxTypes.cross && checked) color = colors.destructive;\n    const backgroundColor = variant === variants.fill && checked ? color : colors.background;\n\n    return `\n      ${\n        variant === variants.outline || variant === variants.fill\n          ? `border: 1px solid ${color};`\n          : ''\n      } \n      background-color: ${backgroundColor};\n      border-radius: 2px;\n      width: 1em;\n      height: 1em;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      overflow: visible;\n      margin-right: 0.5em;\n      &:hover {\n        background-color: ${darken(0.05, backgroundColor)}\n      }\n    `;\n  }}\n`;\n\nexport const CheckboxContainer = styled.div`\n  ${() => {\n    const { colors } = useTheme();\n    return `\n      display: inline-block;\n      vertical-align: middle;\n      &:focus-within {\n        ${Box} {\n          box-shadow: 0 0 5px 0.150rem ${colors.tertiary};\n        }\n      }\n    `;\n  }}\n`;\n\nexport const BaseIcon = styled(Icon)`\n  overflow: visible;\n  height: 1em;\n  width: 1em;\n` as StyledSubcomponentType;\n\nconst CheckIcon = styled(BaseIcon)`\n  ${({ variant }) => {\n    const { colors } = useTheme();\n    return `\n      color: ${variant === variants.fill ? colors.background : colors.success};\n    `;\n  }}\n`;\n\nconst CrossIcon = styled(BaseIcon)`\n  ${({ variant }) => {\n    const { colors } = useTheme();\n    return `\n      color: ${variant === variants.fill ? colors.background : colors.destructive};\n    `;\n  }}\n`;\n\nconst DefaultIcon = styled(BaseIcon)`\n  ${() => {\n    const { colors } = useTheme();\n    return `\n      color: ${colors.grayLight}\n    `;\n  }}\n`;\n\nconst NeutralIcon = styled(BaseIcon)`\n  ${({ variant }) => {\n    const { colors } = useTheme();\n    const color = variant === variants.fill ? colors.background : colors.grayMedium;\n    return `\n      color: ${color};\n      path {\n        stroke: ${color};\n        stroke-width: 2px;\n      }\n    `;\n  }}\n`;\n\nexport interface CheckboxProps {\n  StyledLabel?: StyledSubcomponentType;\n  StyledCheckboxContainer?: StyledSubcomponentType;\n  StyledBox?: StyledSubcomponentType;\n  StyledInput?: StyledSubcomponentType;\n  StyledIcon?: StyledSubcomponentType;\n\n  labelProps?: SubcomponentPropsType;\n  checkboxContainerProps?: SubcomponentPropsType;\n  boxProps?: SubcomponentPropsType;\n  inputProps?: SubcomponentPropsType;\n  iconProps?: SubcomponentPropsType;\n\n  checkboxType?: CheckboxTypes;\n  variant?: variants;\n  children?: React.ReactNode;\n  checked?: boolean;\n  disabled?: boolean;\n  onClick: (event: React.MouseEvent) => void;\n\n  containerRef?: React.RefObject<HTMLDivElement>;\n  boxRef?: React.RefObject<HTMLDivElement>;\n  labelRef?: React.RefObject<HTMLLabelElement>;\n  inputRef?: React.RefObject<HTMLInputElement>;\n}\n\nconst iconPaths = {\n  [CheckboxTypes.check]: mdiCheck,\n  [CheckboxTypes.cross]: mdiClose,\n  [CheckboxTypes.neutral]: mdiMinus,\n  [CheckboxTypes.default]: mdiCheckboxBlank,\n  [CheckboxTypes.fill]: mdiCheckboxBlank,\n};\n\nexport const iconComponents = {\n  [CheckboxTypes.check]: CheckIcon,\n  [CheckboxTypes.cross]: CrossIcon,\n  [CheckboxTypes.neutral]: NeutralIcon,\n  [CheckboxTypes.default]: DefaultIcon,\n  [CheckboxTypes.fill]: DefaultIcon,\n};\n\nconst Checkbox = ({\n  StyledLabel = Label,\n  StyledCheckboxContainer = CheckboxContainer,\n  StyledBox = Box,\n  StyledInput = Input,\n  StyledIcon,\n\n  labelProps = {},\n  checkboxContainerProps = {},\n  boxProps = {},\n  inputProps = {},\n  iconProps = {},\n\n  checkboxType = CheckboxTypes.check,\n  variant = variants.fill,\n  checked = false,\n  children,\n  disabled = false,\n  onClick,\n  containerRef,\n  boxRef,\n  labelRef,\n  inputRef,\n}: CheckboxProps): JSX.Element => {\n  const iconPath = iconPaths[checkboxType];\n  const IconComponent = StyledIcon || iconComponents[checkboxType];\n\n  // add aria-label for accessibility if no children elements are provided\n  const mergedInputProps = children\n    ? { isDisabled: disabled, isSelected: checked, ...inputProps, children }\n    : { isDisabled: disabled, isSelected: checked, ...inputProps, 'aria-label': 'checkbox' };\n\n  const state = useToggleState({ ...mergedInputProps });\n  const internalRef = React.useRef<HTMLInputElement>();\n  const { inputProps: ariaProps } = useCheckbox(\n    mergedInputProps,\n    state,\n    internalRef as RefObject<HTMLInputElement>,\n  );\n  const handleEventWithAnalytics = useAnalytics();\n  const handleClick = (e: any) =>\n    handleEventWithAnalytics('Checkbox', onClick, 'onClick', e, checkboxContainerProps);\n\n  return (\n    <StyledLabel disabled={disabled} data-test-id=\"hsui-Checkbox\" ref={labelRef} {...labelProps}>\n      <StyledCheckboxContainer ref={containerRef} {...checkboxContainerProps}>\n        <StyledBox\n          checkboxType={checkboxType}\n          checked={checked}\n          variant={variant}\n          {...boxProps}\n          ref={boxRef}\n        >\n          {checked ? (\n            <IconComponent\n              aria-hidden=\"true\"\n              data-test-id=\"hsui-Checkbox-Icon\"\n              path={iconPath}\n              variant={variant}\n              {...iconProps}\n            />\n          ) : null}\n        </StyledBox>\n        <StyledInput\n          role=\"checkbox\"\n          {...ariaProps}\n          data-test-id=\"hsui-Checkbox-Input\"\n          onClick={handleClick}\n          checked={checked}\n          ref={mergeRefs<HTMLInputElement | undefined>([inputRef, internalRef])}\n          {...inputProps}\n        />\n      </StyledCheckboxContainer>\n      {children}\n    </StyledLabel>\n  );\n};\n\nCheckbox.Label = Label;\nCheckbox.Box = Box;\nCheckbox.Input = Input;\nCheckbox.Container = CheckboxContainer;\nCheckbox.Types = CheckboxTypes;\nCheckbox.CheckIcon = CheckIcon;\nCheckbox.CrossIcon = CrossIcon;\nCheckbox.NeutralIcon = NeutralIcon;\nCheckbox.FillIcon = DefaultIcon;\nexport default Checkbox;\n","import React from 'react';\nimport styled from 'styled-components';\n\nimport { useSeparator } from 'react-aria';\nimport { StyledBaseDiv, StyledBaseHR } from '../../htmlElements';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { useTheme } from '../../context';\n\nexport const DefaultDivider = styled(StyledBaseHR)`\n  ${({ width = '90%', height = '1px' }: { width: string; height: string }) => {\n    const { colors } = useTheme();\n    return `\n      border: none;\n      height: ${height};\n      width: ${width};\n      background-color: ${colors.grayLight};\n  `;\n  }}\n`;\n\nexport const DefaultDividerContainer = styled(StyledBaseDiv)`\n  display: flex;\n  justify-content: center;\n  margin-top: 10px;\n  margin-bottom: 10px;\n`;\n\nexport interface DividerProps {\n  StyledDivider?: StyledSubcomponentType;\n  StyledDividerContainer?: StyledSubcomponentType;\n  dividerProps?: SubcomponentPropsType;\n  dividerContainerProps?: SubcomponentPropsType;\n\n  width?: string;\n  height?: string;\n\n  containerRef?: React.RefObject<HTMLDivElement>;\n  dividerRef?: React.RefObject<HTMLHRElement>;\n}\n\nconst Divider = ({\n  StyledDivider = DefaultDivider,\n  StyledDividerContainer = DefaultDividerContainer,\n  dividerProps = {},\n  dividerContainerProps = {},\n  width = '90%',\n  height = '1px',\n  containerRef,\n  dividerRef,\n}: DividerProps): JSX.Element => {\n  const { separatorProps: ariaProps } = useSeparator(dividerProps);\n  return (\n    <StyledDividerContainer\n      data-test-id=\"hsui-Divider\"\n      {...dividerContainerProps}\n      ref={containerRef}\n    >\n      <StyledDivider\n        {...ariaProps}\n        width={width}\n        height={height}\n        ref={dividerRef}\n        {...dividerProps}\n      />\n    </StyledDividerContainer>\n  );\n};\n\nDivider.Container = DefaultDividerContainer;\nDivider.Divider = DefaultDivider;\nexport default Divider;\n","import React, {\n  ReactNode,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport styled from 'styled-components';\nimport Icon from '@mdi/react';\nimport { mdiCheck, mdiClose, mdiMenuDown, mdiMenuUp } from '@mdi/js';\nimport { shade, tint, getLuminance, darken, readableColor } from 'polished';\n\nimport { Components, ListRange, Virtuoso } from 'react-virtuoso';\nimport Fuse from 'fuse.js';\nimport { useAnalytics, useTheme } from '../../context';\nimport Button from '../Button/Button';\nimport variants from '../../enums/variants';\nimport timings from '../../enums/timings';\nimport { StyledBaseDiv, StyledBaseSpan, StyledBaseInput } from '../../htmlElements';\nimport Tag, { TagProps } from '../Tag/Tag';\nimport { getFontColorFromVariant, getBackgroundColorFromVariant } from '../../utils/color';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { getShadowStyle, getDropdownTagStyle } from '../../utils/styles';\nimport { mergeRefs } from '../../utils/refs';\nimport TextInput, { TextInputProps } from '../TextInput/TextInput';\n\nexport type OptionProps = {\n  id: number | string;\n  optionValue: ReactNode;\n  isSelected?: boolean;\n};\n\ntype UsefulDropdownState = {\n  color: string;\n  multi?: boolean;\n  selected?: boolean;\n  variant: variants;\n  isOpenedBelow?: boolean;\n  isHidden?: boolean;\n};\n\nconst Container = styled(StyledBaseDiv)`\n  ${({ elevation, isOpen }) => {\n    const { colors } = useTheme();\n    return `\n      width: fit-content;\n      transition: filter ${timings.slow}, box-shadow ${timings.slow};\n      ${getShadowStyle(elevation, colors.shadow)}\n      position: relative;\n      z-index: ${isOpen ? '7' : '1'};\n    `;\n  }}\n`;\n\n// TODO - Add constants for width\nexport const ValueContainer = styled(Button.Container)`\n  ${({ isOpen, isOpenedBelow, isHidden }) => {\n    const { colors } = useTheme();\n    const openedDirection = isOpenedBelow ? 'bottom' : 'top';\n    const openStyle = `\n      border-${openedDirection}: 0px solid transparent;\n      border-${openedDirection}-right-radius: 0rem;\n      border-${openedDirection}-left-radius: 0rem;\n    `;\n\n    return `\n      user-select: none;\n      display: flex;\n      justify-content: space-between;\n      flex-direction: row;\n      align-items: center;\n      ${isOpen && !isHidden ? openStyle : ''}\n      width: 15em;\n      padding: .5em 1em;\n\n      &:focus-within {\n        outline: none;\n        box-shadow: 0 0 5px 0.150rem ${colors.tertiaryDark};\n      }\n    `;\n  }}\n`;\n\n// TODO: Don't use explicit height here - this div is ending up larger than the icon otherwise\nexport const CloseIconContainer = styled(StyledBaseDiv)`\n  z-index: 1;\n  display: flex;\n  align-items: center;\n`;\n\nexport const ArrowIconContainer = styled(StyledBaseDiv)`\n  height: 1.125em;\n  z-index: 1;\n  pointer-events: none;\n`;\n\nconst ValueItem = styled(StyledBaseDiv)`\n  width: 100%;\n  text-align: left;\n`;\n\nconst OptionsContainer = styled(StyledBaseDiv)`\n  ${({\n    color,\n    variant,\n    isOpenedBelow,\n    isHidden,\n    isVirtual,\n  }: UsefulDropdownState & { isVirtual: boolean }) => {\n    const direction = isOpenedBelow ? 'top' : 'bottom';\n    const borderRadii = isOpenedBelow ? '0rem 0rem 0.25rem 0.25rem' : '0.25rem 0.25rem 0rem 0rem';\n\n    return `\n    background: white;\n    position: absolute;\n    left: 0px;\n    ${isVirtual ? 'height: 10em;' : 'max-height: 10em;'}\n    overflow-y: auto;\n    width: 15em;\n    ${\n      variant !== variants.text\n        ? `\n            border: 1px solid ${color};\n          `\n        : ''\n    }\n    z-index: 1000;\n    ${direction}: 100%;\n    border-${direction}: 0px solid transparent;\n    border-radius: ${borderRadii};\n    ${isHidden ? 'visibility: hidden;' : ''}\n  `;\n  }}\n`;\n\nconst HiddenOptionsContainer = styled(OptionsContainer)`\n  ${({ isOpenedBelow }) => {\n    const direction = isOpenedBelow ? 'top' : 'bottom';\n\n    return `\n    visibility: hidden;\n    ${direction}: 100%;\n  `;\n  }}\n`;\n\nconst OptionItem = styled(StyledBaseDiv)`\n  ${({ selected, color, variant }: UsefulDropdownState) => {\n    const { colors } = useTheme();\n    const unselectedBgColor = getBackgroundColorFromVariant(variant, color);\n    const selectedBgColor = getLuminance(color) > 0.5 ? shade(0.125, color) : tint(0.5, color);\n    const backgroundColor = selected ? selectedBgColor : unselectedBgColor;\n    return `\n      user-select: none;\n      padding: 0.5em;\n      display: flex;\n      align-items: center;\n      color: ${\n        selected\n          ? readableColor(backgroundColor, colors.background, color, true)\n          : getFontColorFromVariant(variant, color)\n      };\n      background-color: ${backgroundColor};\n      &:hover {\n        background-color: ${\n          backgroundColor !== 'transparent' ? darken(0.05, backgroundColor) : 'rgba(0, 0, 0, 0.05)'\n        };\n        cursor: pointer;\n        outline: none;\n      }\n      &:focus {\n        outline: none;\n        background-color: ${\n          backgroundColor !== 'transparent' ? darken(0.05, backgroundColor) : 'rgba(0, 0, 0, 0.1)'\n        };\n      }\n    `;\n  }}\n`;\n\nconst CheckContainer = styled(StyledBaseDiv)`\n  ${({ color }: UsefulDropdownState) => {\n    const { colors } = useTheme();\n    const backgroundColor = getLuminance(color) > 0.5 ? shade(0.125, color) : tint(0.5, color);\n    return `\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      color: ${readableColor(backgroundColor, colors.background, color, true)};\n      padding-right: 0.2em;\n      width: 2em;\n    `;\n  }}\n`;\n\nconst PlaceholderContainer = styled(StyledBaseDiv)`\n  position: absolute;\n  opacity: 0.8;\n`;\n\nconst ValueItemTagContainer = styled(Tag.Container)`\n  ${({\n    dropdownVariant,\n    tagVariant,\n    dropdownColor,\n    transparentColor,\n  }: {\n    dropdownVariant: variants;\n    tagVariant: variants;\n    dropdownColor: string;\n    transparentColor: string;\n  }) => `\n    ${\n      tagVariant === variants.text\n        ? `\n          padding: 0;\n          line-height: 1;\n          margin-top: 0 !important;\n        `\n        : ''\n    }\n    ${getDropdownTagStyle(dropdownVariant, tagVariant, dropdownColor, transparentColor)}\n  `}\n`;\n\nconst SearchContainer = styled(StyledBaseDiv)``;\n\nconst SearchInput = styled(StyledBaseInput)`\n  all: inherit;\n  text-align: left;\n`;\n\nconst ValuesCountContainer = styled(StyledBaseDiv)`\n  ${({\n    variant,\n    color,\n    dropdownVariant,\n    transparentColor,\n  }: UsefulDropdownState & { dropdownVariant: variants; transparentColor: string }) => {\n    return `\n    ${getDropdownTagStyle(dropdownVariant, variant, color, transparentColor)}\n      padding: 0.125rem;\n      border-radius: 1.5rem;\n    `;\n  }}\n`;\n\nexport interface DropdownProps {\n  StyledContainer?: StyledSubcomponentType;\n  StyledValueContainer?: StyledSubcomponentType;\n  StyledValueItem?: StyledSubcomponentType;\n  StyledValueItemTagContainer?: StyledSubcomponentType;\n  StyledOptionsContainer?: StyledSubcomponentType;\n  StyledHiddenOptionsContainer?: StyledSubcomponentType;\n  StyledOptionItem?: StyledSubcomponentType;\n  StyledCheckContainer?: StyledSubcomponentType;\n  StyledPlaceholder?: StyledSubcomponentType;\n  StyledCloseIconContainer?: StyledSubcomponentType;\n  StyledArrowIconContainer?: StyledSubcomponentType;\n  StyledSearchInput?: StyledSubcomponentType;\n  StyledSearchContainer?: StyledSubcomponentType;\n  StyledValueCountContainer?: StyledSubcomponentType;\n\n  containerProps?: SubcomponentPropsType;\n  valueContainerProps?: SubcomponentPropsType;\n  valueItemProps?: SubcomponentPropsType;\n  valueItemTagProps?: TagProps;\n  optionsContainerProps?: SubcomponentPropsType;\n  optionItemProps?: SubcomponentPropsType;\n  checkContainerProps?: SubcomponentPropsType;\n  placeholderProps?: SubcomponentPropsType;\n  closeIconProps?: SubcomponentPropsType;\n  arrowIconProps?: SubcomponentPropsType;\n  searchInputProps?: SubcomponentPropsType;\n  searchContainerProps?: SubcomponentPropsType;\n  valueCountProps?: SubcomponentPropsType;\n\n  containerRef?: React.RefObject<HTMLElement>;\n  optionsContainerRef?: React.RefObject<HTMLElement>;\n  hiddenOptionsContainerRef?: React.RefObject<HTMLElement>;\n  optionItemRef?: React.RefObject<HTMLElement>;\n  valueContainerRef?: React.RefObject<HTMLButtonElement>;\n  valueItemRef?: React.RefObject<HTMLElement>;\n  valueItemTagRef?: React.RefObject<HTMLElement>;\n  checkContainerRef?: React.RefObject<HTMLElement>;\n  placeholderRef?: React.RefObject<HTMLElement>;\n  closeIconRef?: React.RefObject<HTMLElement>;\n  arrowIconRef?: React.RefObject<HTMLElement>;\n  searchContainerRef?: React.RefObject<HTMLDivElement>;\n  searchInputRef?: React.RefObject<HTMLInputElement>;\n  valueCountRef?: React.RefObject<HTMLElement>;\n\n  color?: string;\n  elevation?: number;\n  multi?: boolean;\n  name?: string;\n  placeholder?: string;\n\n  componentUUID?: string;\n\n  onBlur?: () => void;\n  onFocus?: () => void;\n  onClear?: () => void;\n  onSelect: (selected?: Array<string | number>) => void;\n\n  rememberScrollPosition?: boolean;\n\n  values?: Array<string | number>;\n  options?: Array<OptionProps>;\n  tabIndex?: number;\n  variant?: variants;\n  optionsVariant?: variants;\n  valueVariant?: variants;\n  valueCountVariant?: variants;\n\n  shouldStayInView?: boolean;\n  intersectionThreshold?: number;\n  intersectionContainer?: HTMLElement | null;\n  intersectionObserverPrecision?: number;\n  virtualizeOptions?: boolean;\n\n  showValueCount?: boolean;\n  showSelectedValues?: boolean;\n  clearable?: boolean;\n  searchable?: boolean;\n  searchFiltersOptions?: boolean;\n  onSearchChange?: TextInputProps['onChange'];\n  onDebouncedSearchChange?: TextInputProps['debouncedOnChange'];\n}\n\nconst defaultCallback = () => {}; // eslint-disable-line @typescript-eslint/no-empty-function\n\nconst Dropdown = ({\n  StyledContainer = Container,\n  StyledValueContainer = ValueContainer,\n  StyledValueItem = ValueItem,\n  StyledValueItemTagContainer = ValueItemTagContainer,\n  StyledOptionsContainer = OptionsContainer,\n  StyledHiddenOptionsContainer = HiddenOptionsContainer,\n  StyledOptionItem = OptionItem,\n  StyledCheckContainer = CheckContainer,\n  StyledPlaceholder = PlaceholderContainer,\n  StyledCloseIconContainer = CloseIconContainer,\n  StyledArrowIconContainer = ArrowIconContainer,\n  StyledSearchContainer = SearchContainer,\n  StyledSearchInput = SearchInput,\n  StyledValueCountContainer = ValuesCountContainer,\n\n  containerProps,\n  valueContainerProps,\n  valueItemProps,\n  optionsContainerProps,\n  optionItemProps,\n  checkContainerProps,\n  placeholderProps,\n  closeIconProps,\n  arrowIconProps,\n  valueItemTagProps = {},\n  searchInputProps,\n  searchContainerProps,\n  valueCountProps,\n\n  containerRef,\n  optionsContainerRef,\n  hiddenOptionsContainerRef,\n  optionItemRef,\n  valueContainerRef,\n  valueItemRef,\n  valueItemTagRef,\n  checkContainerRef,\n  placeholderRef,\n  closeIconRef,\n  arrowIconRef,\n  searchContainerRef,\n  searchInputRef,\n  valueCountRef,\n\n  color,\n  elevation = 0,\n  multi = false,\n  name = 'dropdown',\n  placeholder,\n\n  onBlur,\n  onFocus,\n  onClear,\n  onSelect,\n  options = [],\n  tabIndex = 0,\n  variant = variants.outline,\n  optionsVariant = variants.outline,\n  rememberScrollPosition = true,\n  valueVariant = variants.text,\n  valueCountVariant = variants.outline,\n  values = [],\n  shouldStayInView = true,\n  intersectionThreshold = 1.0,\n  intersectionContainer = null,\n  intersectionObserverPrecision = 100,\n  virtualizeOptions = true,\n\n  showValueCount = false,\n  showSelectedValues = true,\n  clearable = true,\n  searchable = false,\n  searchFiltersOptions = true,\n  onSearchChange = defaultCallback,\n  onDebouncedSearchChange = defaultCallback,\n}: DropdownProps): JSX.Element | null => {\n  const { colors } = useTheme();\n  const defaultedColor = color || colors.grayDark;\n  const [isOpen, setIsOpen] = useState<boolean>(false);\n  const containerInternalRef = useRef<HTMLDivElement>(null);\n  const optionsContainerInternalRef = useRef<HTMLDivElement>(null);\n  const hiddenOptionsContainerInternalRef = useRef<HTMLDivElement>(null);\n\n  const [focusWithin, setFocusWithin] = useState<boolean>(false);\n  const [focusTimeoutId, setFocusTimeoutId] = useState<number>();\n\n  const [searchValue, setSearchValue] = useState<string>();\n\n  const scrollPos = useRef<number>(0);\n\n  const [isOpenedBelow, setIsOpenedBelow] = useState<boolean>(true);\n  const [isHidden, setIsHidden] = useState<boolean>(true);\n  const [isPageScrollingDown, setIsPageScrollingDown] = useState<boolean | null>(null);\n  const prevIntersectionRatio = useRef<number>(0.5);\n  const ticking = useRef<boolean>(false);\n  const [scrollIndex, setScrollIndex] = useState<number>(0);\n\n  const [isOverflowing, setIsOverflowing] = useState<boolean>(true);\n\n  const handleEventWithAnalytics = useAnalytics();\n\n  const handleOnBlur = useCallback(\n    (e: any) => handleEventWithAnalytics('Dropdown', onBlur || (() => {}), 'onBlur', e, { name }),\n    [handleEventWithAnalytics, onBlur, name],\n  );\n  const handleOnFocus = useCallback(\n    (e: any) => handleEventWithAnalytics('Dropdown', onFocus || (() => {}), 'onFocus', e, { name }),\n    [handleEventWithAnalytics, onFocus, name],\n  );\n  const handleOnClear = useCallback(\n    (e: any) => handleEventWithAnalytics('Dropdown', onClear || (() => {}), 'onClear', e, { name }),\n    [handleEventWithAnalytics, onClear, name],\n  );\n\n  const isVirtual = virtualizeOptions && isOverflowing;\n\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  const [searchCharacterCount, setSearchCharacterCount] = useState<number>(0);\n  const [filteredOptions, setFilteredOptions] = useState<OptionProps[]>([]);\n  const stringifiedOptions = JSON.stringify(options);\n\n  useEffect(() => {\n    setFilteredOptions(options);\n    // empty array of options makes this useEffect loop\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [stringifiedOptions]);\n\n  // Merge the default styled container prop and the placeholderProps object to get user styles\n  const placeholderMergedProps = {\n    StyledContainer: PlaceholderContainer,\n    ...placeholderProps,\n  };\n\n  // effect to determine if user is scrolling up or down\n  useEffect(() => {\n    if (isOpen && shouldStayInView) {\n      const threshold = 0;\n      let lastScrollY = window.pageYOffset;\n\n      const updateScrollDir = () => {\n        const scrollY = window.pageYOffset;\n\n        if (Math.abs(scrollY - lastScrollY) < threshold) {\n          ticking.current = false;\n          return;\n        }\n        setIsPageScrollingDown(scrollY > lastScrollY);\n\n        lastScrollY = scrollY > 0 ? scrollY : 0;\n        ticking.current = false;\n      };\n\n      const onPageScroll = () => {\n        if (!ticking.current) {\n          window.requestAnimationFrame(updateScrollDir);\n          ticking.current = true;\n        }\n      };\n      window.addEventListener('scroll', onPageScroll);\n\n      return () => window.removeEventListener('scroll', onPageScroll);\n    }\n    setIsPageScrollingDown(null);\n  }, [isOpen, shouldStayInView]);\n\n  const intersectOptions = useMemo(() => {\n    const buildThresholdArray = () =>\n      Array.from(\n        Array(intersectionObserverPrecision).keys(),\n        i => i / intersectionObserverPrecision,\n      );\n\n    return {\n      root: intersectionContainer,\n      rootMargin: '0px',\n      threshold: buildThresholdArray(),\n    };\n  }, [intersectionContainer, intersectionObserverPrecision]);\n\n  const intersectionCallback = useCallback(\n    (entries: IntersectionObserverEntry[]) => {\n      if (shouldStayInView) {\n        if (entries.length === 1) {\n          const [entry] = entries;\n          if (\n            entry.intersectionRatio < intersectionThreshold &&\n            entry.target === optionsContainerInternalRef.current\n          ) {\n            // swap the dropdown to open downward if its hitting the top\n            if (\n              isPageScrollingDown &&\n              !isOpenedBelow &&\n              entry.intersectionRatio < prevIntersectionRatio.current\n            ) {\n              setIsOpenedBelow(true);\n            } else if (\n              isPageScrollingDown === false &&\n              isOpenedBelow &&\n              entry.intersectionRatio < prevIntersectionRatio.current\n            ) {\n              setIsOpenedBelow(false);\n            }\n          }\n          prevIntersectionRatio.current = entry.intersectionRatio;\n        } else if (entries.length === 2) {\n          const [dropdown, invisibleDrop] = entries;\n          // flip the view if the other direction is more visible in viewport\n          // and the options container is less than the threshold\n\n          if (\n            dropdown.intersectionRatio < intersectionThreshold &&\n            invisibleDrop.intersectionRatio > dropdown.intersectionRatio\n          ) {\n            setIsOpenedBelow((drop: boolean) => !drop);\n          }\n        }\n      }\n      setIsHidden(false);\n    },\n    [shouldStayInView, intersectionThreshold, isPageScrollingDown, isOpenedBelow],\n  );\n\n  const intersectObserver = useMemo(\n    () => new IntersectionObserver(intersectionCallback, intersectOptions),\n    [intersectOptions, intersectionCallback],\n  );\n\n  const stringifiedFilteredOptions = JSON.stringify(filteredOptions);\n\n  useLayoutEffect(() => {\n    let timer: number;\n    if (isOpen) {\n      // setTimeout ensures this code renders after the initial render\n      timer = window.setTimeout(() => {\n        const optionsContainer = optionsContainerInternalRef.current;\n        const hiddenContainer = hiddenOptionsContainerInternalRef.current;\n\n        if (optionsContainer) {\n          if (shouldStayInView) {\n            const virtuosoContainer = optionsContainer.firstElementChild;\n            const virtuosoScroller = virtuosoContainer?.firstElementChild;\n\n            if (virtuosoScroller && virtuosoScroller.clientHeight < optionsContainer.clientHeight) {\n              setIsOverflowing(false);\n            }\n          } else {\n            setIsOverflowing(optionsContainer.scrollHeight > optionsContainer.clientHeight);\n          }\n        }\n\n        if (optionsContainer && hiddenContainer) {\n          const optionsContainerHeight = optionsContainer.getBoundingClientRect().height;\n          const hiddenContainerHeight = hiddenContainer.getBoundingClientRect().height;\n\n          if (optionsContainerHeight !== hiddenContainerHeight) {\n            // height is returned in pixels\n            hiddenContainer.style.height = `${optionsContainerHeight}px`;\n          }\n\n          intersectObserver.observe(optionsContainer);\n          intersectObserver.observe(hiddenContainer);\n        }\n      }, 0);\n    }\n\n    return () => {\n      clearTimeout(timer);\n      intersectObserver.disconnect();\n    };\n  }, [intersectObserver, shouldStayInView, isOpen, stringifiedFilteredOptions]);\n\n  const optionsHash: { [key: string]: OptionProps } = useMemo(() => {\n    const hash: { [key: string]: OptionProps } = {};\n    options.forEach(option => {\n      hash[option.id] = { ...option, isSelected: values.includes(option.id) };\n    });\n\n    return hash;\n  }, [options, values]);\n\n  const scrollListener = () => {\n    scrollPos.current = optionsContainerInternalRef.current\n      ? optionsContainerInternalRef.current.scrollTop\n      : 0;\n  };\n\n  const handleBlur = useCallback(\n    (e: React.FocusEvent) => {\n      e.preventDefault();\n      e.persist();\n      // when not searchable, blur\n      // when searchable, only blur if the event is from the input\n      setFocusTimeoutId(\n        window.setTimeout(() => {\n          const blurredFromButtom = !searchable && e.target.id === `${name}-dropdown-button`;\n          const blurredFromSearch = searchable && e.target.id === `${name}-search-input`;\n          if (focusWithin && (blurredFromButtom || blurredFromSearch)) {\n            setFocusWithin(false);\n            setIsOpen(false);\n            if (handleOnBlur) {\n              handleOnBlur(e);\n            }\n          }\n        }, 0),\n      );\n    },\n    [handleOnBlur, focusWithin, name, searchable],\n  );\n\n  const handleFocus = useCallback(\n    (e: any) => {\n      e.persist();\n      window.setTimeout(() => {\n        if (document.activeElement?.id === `${name}-dropdown-button`) {\n          inputRef?.current?.focus();\n        }\n      }, 0);\n\n      clearTimeout(focusTimeoutId);\n\n      if (!focusWithin) {\n        setFocusWithin(true);\n        // make sure there is no dropdown flickering when tabbing into dropdown\n        setIsHidden(true);\n        setIsOpenedBelow(true);\n      }\n\n      setIsOpen(true);\n\n      if (handleOnFocus) {\n        handleOnFocus(e);\n      }\n    },\n    [focusTimeoutId, focusWithin, handleOnFocus, name],\n  );\n\n  const handleOnSelect = useCallback(\n    (selected?: Array<string | number>) =>\n      handleEventWithAnalytics('Dropdown', onSelect, 'onSelect', selected, { name }),\n    [handleEventWithAnalytics, onSelect, name],\n  );\n\n  const handleSelect = useCallback(\n    (clickedId: string | number) => {\n      if (!multi) {\n        setIsOpen(false);\n        setFocusWithin(false);\n        handleOnSelect([clickedId]);\n      } else {\n        const previouslySelected = optionsHash[clickedId].isSelected;\n        const newValues = previouslySelected\n          ? values.filter(val => val !== clickedId)\n          : [...values, clickedId];\n        handleOnSelect(newValues);\n      }\n    },\n    [handleOnSelect, multi, values, optionsHash],\n  );\n\n  const handleClear = useCallback(\n    (e: React.MouseEvent) => {\n      e.preventDefault();\n      e.nativeEvent.stopImmediatePropagation();\n      handleOnSelect(multi ? [] : undefined);\n      if (handleOnClear) {\n        handleOnClear(e);\n      }\n    },\n    [multi, handleOnClear, handleOnSelect],\n  );\n\n  const handleMouseDownOnButton = useCallback(\n    (e: React.MouseEvent) => {\n      if (isOpen) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore - It's okay if target is null in this case as we want it to close regardless\n        handleBlur(e);\n      } else {\n        setIsHidden(true);\n        setIsOpenedBelow(true);\n        handleFocus(e);\n      }\n    },\n    [isOpen, handleBlur, handleFocus],\n  );\n\n  const keyDownHandler = useCallback(\n    ({ key }: { key: string }) => {\n      // setTimeout(0) needed when responding to key events to push back call\n      // to activeElement to after it is updated in the DOM\n      window.setTimeout(() => {\n        const focusedElement = document.activeElement;\n\n        if (!focusedElement) return;\n\n        let optionToFocus;\n\n        switch (key) {\n          case 'Enter':\n            const match = focusedElement.id.match(`${name}-option-(.*)`);\n            if (match) {\n              handleSelect(match[1]);\n            }\n            break;\n\n          case 'ArrowUp':\n            if (focusedElement.id.match(`${name}-option-.*`)) {\n              if (isVirtual) {\n                const row = focusedElement.parentElement;\n                const rowPrevSibling = row ? row.previousElementSibling : null;\n                if (rowPrevSibling) {\n                  optionToFocus = rowPrevSibling.firstElementChild;\n                }\n              } else {\n                optionToFocus = focusedElement.previousElementSibling;\n              }\n            }\n            break;\n\n          case 'ArrowDown':\n            if (focusedElement.id === `${name}-dropdown-button`) {\n              const optionsContainer = focusedElement?.nextElementSibling;\n              if (isVirtual) {\n                const virtuosoContainer = optionsContainer?.firstElementChild;\n                const virtuosoScroller = virtuosoContainer?.firstElementChild;\n                optionToFocus = virtuosoScroller?.firstElementChild?.firstElementChild;\n              } else {\n                optionToFocus = optionsContainer?.firstElementChild;\n              }\n            } else if (focusedElement.id.match(`${name}-option-.*`)) {\n              if (isVirtual) {\n                const row = focusedElement.parentElement;\n                const rowNextSibling = row ? row.nextElementSibling : null;\n                if (rowNextSibling) {\n                  optionToFocus = rowNextSibling.firstElementChild;\n                }\n              } else {\n                optionToFocus = focusedElement.nextElementSibling;\n              }\n            } else if (focusedElement.id === `${name}-search-input`) {\n              const searchInputContainer = focusedElement.parentElement;\n              const valueItemContainer = searchInputContainer?.parentElement;\n              const button = valueItemContainer;\n              const optionsContainer = button?.nextElementSibling;\n              if (isVirtual) {\n                const virtuosoContainer = optionsContainer?.firstElementChild;\n                const virtuosoScroller = virtuosoContainer?.firstElementChild;\n                optionToFocus = virtuosoScroller?.firstElementChild?.firstElementChild;\n              } else {\n                optionToFocus = optionsContainer?.firstElementChild;\n              }\n            }\n            break;\n          default:\n            break;\n        }\n        (optionToFocus as HTMLElement)?.focus();\n      }, 0);\n    },\n    [handleSelect, isVirtual, name],\n  );\n\n  useEffect(() => {\n    window.removeEventListener('keydown', keyDownHandler);\n    window.addEventListener('keydown', keyDownHandler);\n    return () => {\n      window.removeEventListener('keydown', keyDownHandler);\n    };\n  }, [keyDownHandler]);\n\n  const optionsScrollListenerCallbackRef = useCallback(\n    (node: HTMLElement | null) => {\n      if (node && rememberScrollPosition) {\n        node.addEventListener('scroll', scrollListener, true);\n\n        if (scrollPos.current) {\n          node.scrollTop = scrollPos.current;\n        }\n      }\n    },\n    [rememberScrollPosition],\n  );\n\n  const valueCountCloseIconHandler = () => {\n    return (\n      <>\n        {showValueCount && (\n          <StyledValueCountContainer\n            variant={valueCountVariant}\n            color={defaultedColor}\n            transparentColor={colors.transparent}\n            ref={valueCountRef}\n            dropdownVariant={variant}\n            {...valueCountProps}\n          >\n            {values.length}\n          </StyledValueCountContainer>\n        )}\n        {clearable && (\n          <StyledCloseIconContainer\n            onMouseDown={(e: React.FocusEvent) => e.stopPropagation()}\n            onClick={handleClear}\n            onFocus={(e: React.FocusEvent) => e.stopPropagation()}\n            tabIndex={tabIndex}\n            ref={closeIconRef}\n            {...closeIconProps}\n          >\n            <Icon path={mdiClose} size=\"1em\" />\n          </StyledCloseIconContainer>\n        )}\n      </>\n    );\n  };\n\n  const infoIcons = (\n    <>\n      {values.length > 0 && valueCountCloseIconHandler()}\n      <StyledArrowIconContainer ref={arrowIconRef} {...arrowIconProps} $isOpen={isOpen}>\n        <Icon path={isOpen ? mdiMenuUp : mdiMenuDown} size=\"1.25em\" />\n      </StyledArrowIconContainer>\n    </>\n  );\n\n  const InternalOptionsContainer = useMemo(\n    () =>\n      React.forwardRef(\n        (\n          { children }: { children: React.ReactNode },\n          listRef: React.ForwardedRef<HTMLDivElement>,\n        ) => (\n          <StyledOptionsContainer\n            color={defaultedColor}\n            variant={optionsVariant}\n            isVirtual={isVirtual}\n            role=\"listbox\"\n            ref={mergeRefs<HTMLDivElement | HTMLElement>([\n              optionsContainerRef,\n              optionsContainerInternalRef,\n              listRef,\n            ])}\n            isOpenedBelow={isOpenedBelow}\n            isHidden={isHidden}\n            {...optionsContainerProps}\n          >\n            {children}\n          </StyledOptionsContainer>\n        ),\n      ),\n    [\n      defaultedColor,\n      isHidden,\n      isOpenedBelow,\n      isVirtual,\n      optionsContainerProps,\n      optionsContainerRef,\n      optionsVariant,\n    ],\n  );\n  const handleSearchChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n      setSearchValue(e.target.value);\n      handleEventWithAnalytics('Dropdown', onSearchChange, 'onSearchChange', e, { name });\n    },\n    [handleEventWithAnalytics, onSearchChange, name],\n  );\n\n  const handleSearchDebouncedChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    handleEventWithAnalytics('Dropdown', onDebouncedSearchChange, 'onDebouncedSearchChange', e, {\n      name,\n    });\n\n    const searchText = e.target.value;\n\n    setSearchCharacterCount(searchText.length);\n\n    if (searchFiltersOptions) {\n      if (searchText.length === 0) {\n        setFilteredOptions(options);\n      } else {\n        const fuse = new Fuse(options, {\n          keys: ['id', 'optionValue'],\n        });\n\n        const result = fuse.search(searchText);\n\n        setFilteredOptions(result.map(r => r.item));\n      }\n    }\n  };\n\n  const optionsToRender: OptionProps[] =\n    searchable && searchFiltersOptions ? filteredOptions : options;\n  const persistPlaceholder = !showSelectedValues && !focusWithin;\n  const blurredEmptyArrEmptySearch =\n    searchCharacterCount === 0 && (!values || !values.length) && !focusWithin;\n  return (\n    <StyledContainer\n      id={`${name}-container`}\n      elevation={elevation}\n      isOpen={isOpen}\n      onBlur={handleBlur}\n      onFocus={handleFocus}\n      name={name}\n      aria-label={placeholder}\n      ref={mergeRefs<HTMLElement | HTMLDivElement>([containerRef, containerInternalRef])}\n      onMouseDown={handleMouseDownOnButton}\n      {...containerProps}\n    >\n      <Button\n        StyledContainer={StyledValueContainer}\n        id={`${name}-dropdown-button`}\n        color={defaultedColor}\n        onMouseDown={handleMouseDownOnButton}\n        variant={variant}\n        containerRef={valueContainerRef}\n        {...valueContainerProps}\n        containerProps={{\n          isOpen,\n          isOpenedBelow,\n          isHidden,\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-expect-error\n          ...(valueContainerProps ? valueContainerProps.containerProps : {}),\n        }}\n      >\n        {(blurredEmptyArrEmptySearch || persistPlaceholder) && (\n          <StyledPlaceholder\n            ref={placeholderRef}\n            id={`${name}-placeholder`}\n            {...placeholderMergedProps}\n          >\n            {placeholder}\n          </StyledPlaceholder>\n        )}\n        {searchable && focusWithin && isOpen ? (\n          <TextInput\n            id={`${name}-search-input`}\n            containerRef={searchContainerRef}\n            aria-label={`${name}-search-input`}\n            role=\"searchbox\"\n            onChange={handleSearchChange}\n            value={searchValue}\n            debouncedOnChange={handleSearchDebouncedChange}\n            StyledContainer={StyledSearchContainer}\n            StyledInput={StyledSearchInput}\n            inputRef={mergeRefs<HTMLInputElement>([searchInputRef, inputRef])}\n            autoComplete=\"off\"\n            inputProps={searchInputProps}\n            containerProps={searchContainerProps}\n          />\n        ) : (\n          <StyledValueItem id={`${name}-value-item`} ref={valueItemRef} {...valueItemProps}>\n            {showSelectedValues\n              ? values\n                  .filter(val => val !== undefined && optionsHash[val] !== undefined)\n                  .map((val, i, arr) =>\n                    optionsHash[val] !== undefined ? (\n                      <Tag\n                        StyledContainer={StyledValueItemTagContainer}\n                        variant={valueVariant}\n                        containerRef={valueItemTagRef}\n                        {...valueItemTagProps}\n                        containerProps={{\n                          dropdownVariant: variant,\n                          tagVariant: valueVariant,\n                          dropdownColor: defaultedColor,\n                          transparentColor: colors.transparent,\n                          ...(valueItemTagProps.containerProps || {}),\n                        }}\n                        key={val}\n                      >\n                        {optionsHash[val].optionValue}\n                        {valueVariant === variants.text && i !== arr.length - 1 && ','}\n                      </Tag>\n                    ) : undefined,\n                  )\n              : undefined}\n          </StyledValueItem>\n        )}\n        {infoIcons}\n      </Button>\n      {isOpen && (\n        <>\n          {isVirtual ? (\n            <Virtuoso\n              data={optionsToRender}\n              rangeChanged={(range: ListRange) => setScrollIndex(range.startIndex)}\n              initialTopMostItemIndex={\n                rememberScrollPosition && scrollIndex < optionsToRender.length ? scrollIndex : 0\n              }\n              components={\n                {\n                  Scroller: InternalOptionsContainer,\n                } as Components\n              }\n              itemContent={(_index: number, option: OptionProps) => (\n                <StyledOptionItem\n                  id={`${name}-option-${option.id}`}\n                  key={`${name}-option-${option.id}`}\n                  onClick={() => handleSelect(option.id)}\n                  tabIndex={-1}\n                  color={defaultedColor}\n                  variant={optionsVariant}\n                  multi={multi}\n                  selected={optionsHash[option.id].isSelected}\n                  ref={optionItemRef}\n                  role=\"option\"\n                  {...optionItemProps}\n                >\n                  {multi && (\n                    <StyledCheckContainer\n                      color={defaultedColor}\n                      selected={optionsHash[option.id].isSelected}\n                      variant={optionsVariant}\n                      multi={multi}\n                      ref={checkContainerRef}\n                      {...checkContainerProps}\n                    >\n                      {optionsHash[option.id].isSelected && <Icon path={mdiCheck} size=\"1em\" />}\n                    </StyledCheckContainer>\n                  )}\n                  <StyledBaseSpan>{option.optionValue}</StyledBaseSpan>\n                </StyledOptionItem>\n              )}\n            />\n          ) : (\n            <InternalOptionsContainer ref={optionsScrollListenerCallbackRef}>\n              {optionsToRender.map(option => (\n                <StyledOptionItem\n                  id={`${name}-option-${option.id}`}\n                  key={`${name}-option-${option.id}`}\n                  onClick={() => handleSelect(option.id)}\n                  tabIndex={-1}\n                  color={defaultedColor}\n                  variant={optionsVariant}\n                  multi={multi}\n                  selected={optionsHash[option.id].isSelected}\n                  ref={optionItemRef}\n                  role=\"option\"\n                  {...optionItemProps}\n                >\n                  {multi && (\n                    <StyledCheckContainer\n                      color={defaultedColor}\n                      selected={optionsHash[option.id].isSelected}\n                      variant={optionsVariant}\n                      multi={multi}\n                      ref={checkContainerRef}\n                      {...checkContainerProps}\n                    >\n                      {optionsHash[option.id].isSelected && <Icon path={mdiCheck} size=\"1em\" />}\n                    </StyledCheckContainer>\n                  )}\n                  <StyledBaseSpan>{option.optionValue}</StyledBaseSpan>\n                </StyledOptionItem>\n              ))}\n            </InternalOptionsContainer>\n          )}\n          {shouldStayInView && (\n            <StyledHiddenOptionsContainer\n              ref={mergeRefs<HTMLDivElement | HTMLElement>([\n                hiddenOptionsContainerInternalRef,\n                hiddenOptionsContainerRef,\n              ])}\n              // HiddenOptionsContainer opens in the opposite direction of OptionsContainer\n              isOpenedBelow={!isOpenedBelow}\n            />\n          )}\n        </>\n      )}\n    </StyledContainer>\n  );\n};\n\nDropdown.Container = Container;\nDropdown.OptionsContainer = OptionsContainer;\nDropdown.HiddenOptionsContainer = HiddenOptionsContainer;\nDropdown.OptionItem = OptionItem;\nDropdown.ValueContainer = ValueContainer;\nDropdown.ValueItem = ValueItem;\nDropdown.ValueItemTagContainer = ValueItemTagContainer;\nDropdown.Placeholder = PlaceholderContainer;\n\nexport default Dropdown;\n","import { animated, useTransition } from '@react-spring/web';\nimport React, { useCallback, useRef, useState } from 'react';\nimport styled from 'styled-components';\nimport useResizeObserver from 'use-resize-observer/polyfilled';\nimport { randomId } from '../../utils/math';\n\nimport { useAnalytics } from '../../context';\nimport colors from '../../enums/colors';\nimport { mergeRefs } from '../../utils/refs';\nimport { StyledSubcomponentType, SubcomponentPropsType } from '../commonTypes';\n\nconst Container = styled(animated.div)`\n  position: relative;\n`;\n\nconst SVGContainer = styled.svg`\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n`;\n\ntype Animation = { cx: string; cy: string; id: string };\ntype Transition = { r: string } & Animation;\nexport type InteractionFeedbackProps = {\n  StyledContainer?: StyledSubcomponentType;\n  StyledSVGContainer?: StyledSubcomponentType;\n  containerProps?: SubcomponentPropsType;\n  svgContainerProps?: SubcomponentPropsType;\n\n  children?: React.ReactNode;\n  color?: string;\n  interpolationFunctions?: Record<string, (val: any) => any>;\n  // TODO add proper type from react-spring\n  transitionProps?: any;\n  containerRef?: React.RefObject<HTMLDivElement>;\n  SVGContainerRef?: React.RefObject<SVGElement>;\n};\n\nconst defaultInterpolationFunctions = {\n  r: (r: any) => r.to((val: string) => `${Math.abs(parseFloat(val)).toFixed(1)}`),\n  opacity: (opacity: any) => opacity.to((val: number) => val.toFixed(2)),\n};\nconst defaultTransitionProps = {\n  from: {\n    r: 0,\n    opacity: 0.5,\n  },\n  enter: {\n    r: 100,\n    opacity: 0,\n  },\n  config: {\n    mass: 90,\n    tension: 1000,\n    friction: 20,\n    round: 1,\n    clamp: false,\n  },\n};\nconst InteractionFeedback = ({\n  StyledContainer = Container,\n  StyledSVGContainer = SVGContainer,\n  containerRef,\n  SVGContainerRef,\n  containerProps = {},\n  svgContainerProps = {},\n  color = colors.primary,\n\n  children,\n  interpolationFunctions = defaultInterpolationFunctions,\n  transitionProps = { ...defaultTransitionProps },\n}: InteractionFeedbackProps): JSX.Element => {\n  const internalRef = useRef<HTMLDivElement>(null);\n  const { ref, width = 0, height = 0 } = useResizeObserver<HTMLDivElement>();\n  const [animations, setAnimations] = useState<Array<Animation>>([]);\n\n  const transitions = useTransition(animations, {\n    keys: (item: Animation) => item.id,\n    onRest: (item: Transition) => setAnimations(a => a.filter(ani => ani.id === item.id)),\n    ...transitionProps,\n  });\n  const fragment = transitions((style, item) => {\n    const circleProps = Object.entries(style).reduce((acc, [key, val]) => {\n      return {\n        ...acc,\n        [key]: interpolationFunctions[key] ? interpolationFunctions[key](val) : val,\n      };\n    }, {});\n    return <animated.circle cx={item.cx} cy={item.cy} fill={color} {...circleProps} />;\n  });\n\n  const mouseDownHandler = useCallback(\n    (e: React.MouseEvent) => {\n      if (internalRef && internalRef.current) {\n        e.persist();\n        const boundingRect = internalRef.current.getBoundingClientRect();\n        const { clientX, clientY } = e;\n        const percentX = (100 * (clientX - boundingRect.left)) / boundingRect.width;\n        const percentY = (100 * (clientY - boundingRect.top)) / boundingRect.height;\n\n        setAnimations(a => [...a, { cx: `${percentX}%`, cy: `${percentY}%`, id: randomId(18) }]);\n      }\n    },\n    [internalRef],\n  );\n\n  const handleEventWithAnalytics = useAnalytics();\n  const handleMouseDown = (e: any) =>\n    handleEventWithAnalytics(\n      'InteractionFeedback',\n      mouseDownHandler,\n      'onMouseDown',\n      e,\n      containerProps,\n    );\n\n  return (\n    <StyledContainer\n      ref={mergeRefs<HTMLDivElement>([ref, internalRef, containerRef])}\n      onMouseDown={handleMouseDown}\n      {...containerProps}\n    >\n      {children}\n      <StyledSVGContainer\n        width={`${width}px`}\n        height={`${height}px`}\n        viewBox={`0 0 ${width} ${height}`}\n        ref={SVGContainerRef}\n        {...svgContainerProps}\n      >\n        {fragment}\n      </StyledSVGContainer>\n    </StyledContainer>\n  );\n};\n\nInteractionFeedback.Container = Container;\nInteractionFeedback.SVGContainer = SVGContainer;\nInteractionFeedback.defaultTransitionProps = defaultTransitionProps;\nInteractionFeedback.defaultInterpolationFunctions = defaultInterpolationFunctions;\n\nexport default InteractionFeedback;\n","import React from 'react';\nimport styled from 'styled-components';\nimport Icon from '@mdi/react';\nimport { mdiCheckBold, mdiAsterisk } from '@mdi/js';\nimport { useLabel } from 'react-aria';\nimport { StyledBaseDiv, StyledBaseLabel, StyledBaseSpan } from '../../htmlElements';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { useTheme } from '../../context';\n\nexport const DefaultStyledLabel = styled(StyledBaseLabel)`\n  ${({ color }: { color: string }) => {\n    const { colors } = useTheme();\n    const labelColor = color || colors.grayLight;\n    return `\n      display: inline-flex;\n      color: ${labelColor};\n      margin-bottom: .25em;\n      font-size: .75em;\n    `;\n  }}\n`;\n\nexport const DefaultStyledTextContainer = styled(StyledBaseDiv)``;\n\nexport const DefaultStyledLabelContainer = styled(StyledBaseDiv)``;\n\nconst DefaultStyledIconContainer = styled(StyledBaseSpan)`\n  display: inline-flex;\n  margin-left: 0.25em;\n`;\n\nexport interface LabelProps {\n  StyledLabelContainer?: StyledSubcomponentType;\n  StyledTextContainer?: StyledSubcomponentType;\n  StyledLabel?: StyledSubcomponentType;\n  StyledIconContainer?: StyledSubcomponentType;\n\n  labelContainerProps?: SubcomponentPropsType;\n  textContainerProps?: SubcomponentPropsType;\n  labelProps?: SubcomponentPropsType;\n  iconContainerProps?: SubcomponentPropsType;\n\n  labelContainerRef?: React.RefObject<HTMLDivElement>;\n  textContainerRef?: React.RefObject<HTMLDivElement>;\n  iconContainerRef?: React.RefObject<HTMLSpanElement>;\n  labelRef?: React.RefObject<HTMLLabelElement>;\n\n  labelText?: string;\n  color?: string;\n  isValid?: boolean;\n  colorValid?: string;\n  colorInvalid?: string;\n  htmlFor?: string;\n  isRequired?: boolean;\n  children?: React.ReactNode;\n}\n\nconst Label = ({\n  StyledLabelContainer = DefaultStyledLabelContainer,\n  StyledTextContainer = DefaultStyledTextContainer,\n  StyledLabel = DefaultStyledLabel,\n  StyledIconContainer = DefaultStyledIconContainer,\n  labelContainerProps = {},\n  textContainerProps = {},\n  labelProps = {},\n  iconContainerProps = {},\n  labelContainerRef,\n  textContainerRef,\n  iconContainerRef,\n  labelRef,\n\n  labelText,\n  color,\n  isValid,\n  colorValid,\n  colorInvalid,\n  htmlFor = 'default',\n  isRequired = false,\n  children,\n}: LabelProps): JSX.Element => {\n  const { colors } = useTheme();\n  let shownColor: string;\n  let shownIcon: string | JSX.Element;\n\n  if (isValid === true) {\n    shownColor = colorValid || colors.success;\n    shownIcon = mdiCheckBold;\n  } else if (isValid === false) {\n    shownColor = colorInvalid || colors.destructive;\n    shownIcon = isRequired ? mdiAsterisk : '';\n  } else {\n    shownColor = color || colors.grayLight;\n    shownIcon = isRequired ? mdiAsterisk : '';\n  }\n\n  // add aria-label for accessibility if no labelText provided\n  const mergedLabelProps = labelText\n    ? { ...labelProps, label: labelText }\n    : { ...labelProps, 'aria-label': 'label' };\n\n  const { labelProps: ariaProps, fieldProps: ariaFieldProps } = useLabel(mergedLabelProps);\n  // add aria props to the child component\n  const childrenWithAriaProps = React.Children.map(children, child => {\n    if (React.isValidElement(child)) {\n      // dont overwrite any preexisting props\n      return React.cloneElement(child, { ...ariaFieldProps, ...child.props });\n    }\n    return child;\n  });\n\n  return (\n    <StyledLabelContainer ref={labelContainerRef} {...labelContainerProps}>\n      <StyledTextContainer ref={textContainerRef} {...textContainerProps}>\n        <StyledLabel\n          {...ariaProps}\n          htmlFor={htmlFor}\n          color={shownColor}\n          ref={labelRef}\n          {...labelProps}\n        >\n          {labelText}\n        </StyledLabel>\n        <StyledIconContainer aria-hidden=\"true\" ref={iconContainerRef} {...iconContainerProps}>\n          <Icon path={shownIcon} size=\".75em\" color={shownColor} />\n        </StyledIconContainer>\n      </StyledTextContainer>\n      {/* Only render children with aria props if there is one child */}\n      {React.Children.count(children) === 1 ? childrenWithAriaProps : children}\n    </StyledLabelContainer>\n  );\n};\n\nLabel.LabelContainer = DefaultStyledLabelContainer;\nLabel.TextContainer = DefaultStyledTextContainer;\nLabel.Label = DefaultStyledLabel;\nLabel.IconContainer = DefaultStyledIconContainer;\n\nexport default Label;\n","import React, {\n  forwardRef,\n  RefObject,\n  ReactNode,\n  useEffect,\n  useCallback,\n  useImperativeHandle,\n} from 'react';\nimport styled from 'styled-components';\nimport { mdiClose } from '@mdi/js';\nimport { useSpring } from '@react-spring/web';\nimport { Portal } from 'react-portal';\nimport { transparentize } from 'polished';\n\nimport variants from '../../enums/variants';\nimport Button from '../Button/Button';\nimport { AnimatedDiv } from '../../htmlElements';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { useAnalytics, useTheme } from '../../context';\n\nconst Underlay = styled(AnimatedDiv)`\n  height: 100%;\n  width: 100%;\n\n  background-color: rgba(0, 0, 0, 0.5);\n\n  position: fixed;\n  top: 0;\n  left: 0;\n\n  z-index: 1000;\n`;\n\nconst Container = styled(AnimatedDiv)`\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n\n  z-index: 1010;\n`;\n\n// Just so that the types can match a styled component\nconst CloseButton = styled(Button)``;\n\nconst CloseButtonContainer = styled(Button.Container)`\n  ${({ closeButtonAttachment }: { closeButtonAttachment: string }) => {\n    let distance;\n    let position;\n    let display = 'inline-flex'; // default display type\n\n    switch (closeButtonAttachment) {\n      case 'inside':\n        distance = '.5rem';\n        position = 'absolute';\n        break;\n      case 'outside':\n        distance = '-2rem';\n        position = 'absolute';\n        break;\n      case 'corner':\n        distance = '1rem';\n        position = 'fixed';\n        break;\n      case 'none':\n        distance = '0rem';\n        position = 'absolute';\n        display = 'none';\n        break;\n      default:\n        distance = '0rem';\n        position = 'absolute';\n        break;\n    }\n\n    return `\n      position: ${position};\n      top: ${distance};\n      right: ${distance};\n      z-index: 1011;\n      border-radius: 50%;\n      padding: .5rem;\n      display: ${display};\n    `;\n  }}\n`;\n\nexport interface ModalProps {\n  // TODO: Make string & StyledComponentBase<> its own type, also see about not using `any`\n  StyledContainer?: StyledSubcomponentType;\n  StyledUnderlay?: StyledSubcomponentType;\n  StyledCloseButton?: StyledSubcomponentType;\n  StyledCloseButtonContainer?: StyledSubcomponentType;\n\n  containerProps?: SubcomponentPropsType;\n  underlayProps?: SubcomponentPropsType;\n  closeButtonProps?: SubcomponentPropsType;\n  closeButtonContainerProps?: SubcomponentPropsType;\n\n  containerRef?: RefObject<HTMLDivElement>;\n  closeButtonContainerRef?: RefObject<HTMLDivElement>;\n  underlayRef?: RefObject<HTMLDivElement>;\n\n  animationSpringConfig?: Record<string, unknown>;\n\n  children: ReactNode;\n\n  onClickOutside?: (e: MouseEvent) => void;\n  onClose?: (e: MouseEvent) => void;\n\n  closeButtonAttachment?: string;\n  backgroundBlur?: string;\n  backgroundDarkness?: number;\n  style?: Record<string, unknown>;\n}\n\nexport type ModalApi = {\n  close: (evt?: any) => void;\n};\n\nconst Modal = forwardRef<ModalApi, ModalProps>(\n  (\n    {\n      StyledContainer = Container,\n      StyledUnderlay = Underlay,\n      StyledCloseButton = CloseButton,\n      StyledCloseButtonContainer = CloseButtonContainer,\n\n      containerProps = {},\n      underlayProps = {},\n      closeButtonProps = {},\n      closeButtonContainerProps = {},\n\n      containerRef,\n      closeButtonContainerRef,\n      underlayRef,\n\n      animationSpringConfig = {},\n\n      children,\n\n      onClickOutside,\n      onClose = () => {}, // eslint-disable-line @typescript-eslint/no-empty-function\n\n      closeButtonAttachment = 'inside',\n      backgroundBlur = '0.5rem',\n      backgroundDarkness = 0.2,\n    }: ModalProps,\n    forwardedRef,\n  ): JSX.Element => {\n    const {\n      colors,\n      accessibilityPreferences: { prefersReducedMotion },\n      performanceInfo: { tier: gpuTier },\n    } = useTheme();\n\n    const { styles: containerStyles }: { styles?: Record<string, unknown> } = containerProps;\n    const { styles: underlayStyles }: { styles?: Record<string, unknown> } = underlayProps;\n\n    const handleEventWithAnalytics = useAnalytics();\n    const handleClickOutside = (e: MouseEvent) => {\n      if (onClickOutside) {\n        handleEventWithAnalytics('Modal', onClickOutside, 'onClickOutside', e, containerProps);\n      }\n    };\n    const handleEsc = useCallback(\n      (e: KeyboardEvent) =>\n        handleEventWithAnalytics('Modal', onClickOutside, 'onEsc', e, containerProps),\n      [containerProps, handleEventWithAnalytics, onClickOutside],\n    );\n    const handleClose = (e: MouseEvent) =>\n      handleEventWithAnalytics('Modal', onClose, 'onClose', e, containerProps);\n\n    const animationPrecision = gpuTier < 2 ? 0.2 : undefined;\n\n    const [springStyles, spring] = useSpring(() => ({\n      containerTransform: 'translate(-50%, -25%)',\n      containerOpacity: 0,\n      underlayBackgroundColor: 'rgba(0,0,0, 0)',\n      underlayBackdropFilter: 'blur(0rem)',\n      config: {\n        immediate: prefersReducedMotion,\n        friction: 75,\n        tension: 550,\n        mass: 5,\n        round: animationPrecision,\n        clamp: false,\n        ...animationSpringConfig,\n      },\n    }));\n\n    useEffect(() => {\n      spring.start({\n        config: {\n          round: animationPrecision,\n        },\n      });\n    }, [animationPrecision, spring]);\n\n    useEffect(() => {\n      spring.start({\n        containerTransform: 'translate(-50%, -50%)',\n        containerOpacity: 1,\n        underlayBackgroundColor: transparentize(1 - backgroundDarkness, colors.black),\n        underlayBackdropFilter: gpuTier < 2 ? 'blur(0rem)' : `blur(${backgroundBlur})`,\n      });\n    }, [backgroundBlur, backgroundDarkness, colors.black, gpuTier, spring]);\n\n    const animateClose = useCallback(\n      (\n        restFunction: typeof handleClose | typeof handleClickOutside | typeof handleEsc,\n        e?: any,\n      ) => {\n        spring.start({\n          containerTransform: 'translate(-50%, -25%)',\n          containerOpacity: 0,\n          underlayBackgroundColor: 'rgba(0,0,0, 0)',\n          underlayBackdropFilter: 'blur(0rem)',\n          config: { friction: 50, clamp: true },\n          onRest: () => restFunction(e),\n        });\n      },\n      [spring],\n    );\n\n    useImperativeHandle(forwardedRef, () => ({\n      close: evt => animateClose(handleClose, evt),\n    }));\n\n    const escFunction = useCallback(\n      (event: KeyboardEvent) => {\n        if (event.code === 'Escape' && onClickOutside) {\n          animateClose(handleEsc, event);\n        }\n      },\n      [animateClose, handleEsc],\n    );\n\n    useEffect(() => {\n      document.addEventListener('keydown', escFunction, false);\n\n      return () => {\n        document.removeEventListener('keydown', escFunction, false);\n      };\n    }, [escFunction]);\n\n    return (\n      <Portal>\n        {closeButtonAttachment === 'corner' && (\n          <StyledCloseButton\n            StyledContainer={StyledCloseButtonContainer}\n            containerProps={{\n              closeButtonAttachment,\n              ...closeButtonContainerProps,\n            }}\n            iconPrefix={mdiClose}\n            color={colors.background}\n            elevation={1}\n            variant={variants.text}\n            onClick={(e: MouseEvent) => animateClose(handleClose, e)}\n            {...closeButtonProps}\n          />\n        )}\n        <StyledContainer\n          ref={containerRef}\n          {...containerProps}\n          style={{\n            transform: springStyles.containerTransform,\n            opacity: springStyles.containerOpacity,\n            ...containerStyles,\n          }}\n        >\n          {children}\n          {closeButtonAttachment !== 'corner' && (\n            <StyledCloseButton\n              StyledContainer={StyledCloseButtonContainer}\n              ref={closeButtonContainerRef}\n              containerProps={{\n                closeButtonAttachment,\n                ...closeButtonContainerProps,\n              }}\n              iconPrefix={mdiClose}\n              color={closeButtonAttachment === 'inside' ? colors.grayDark : colors.background}\n              elevation={closeButtonAttachment === 'inside' ? 0 : 1}\n              variant={variants.text}\n              onClick={(e: MouseEvent) => animateClose(handleClose, e)}\n              {...closeButtonProps}\n            />\n          )}\n        </StyledContainer>\n        <StyledUnderlay\n          colors={colors}\n          onClick={(e: MouseEvent) => {\n            if (onClickOutside) {\n              animateClose(handleClickOutside, e);\n            }\n          }}\n          ref={underlayRef}\n          {...underlayProps}\n          style={{\n            backdropFilter: springStyles.underlayBackdropFilter,\n            backgroundColor: springStyles.underlayBackgroundColor,\n            ...underlayStyles,\n          }}\n        />\n      </Portal>\n    );\n  },\n);\n\n// Typescript doesn't like adding properties to React Forward Ref, but it still works\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nModal.Underlay = Underlay;\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nModal.CloseButtonContainer = CloseButtonContainer;\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nModal.Container = Container;\n\nexport default Modal;\n","import styled, { keyframes, css } from 'styled-components';\nimport { StyledBaseDiv } from '../../htmlElements';\n\n/* Keyframes for the loading bar gradient */\nexport const movingGradient = keyframes`\n  0% { background-position: 200% bottom; }\n  100% { background-position: 0% bottom; }\n`;\n\n/* Animation to scroll the gradient toward the right */\nexport const animation = css`\n  ${movingGradient} 8s linear infinite;\n`;\n\n/* Styled div that represents the scroll bar\n   Note: The border-radius 9999px is used to create a pill shape */\nconst Progress = styled(StyledBaseDiv)`\n  ${() => css`\n    background: linear-gradient(\n        45deg,\n        rgba(255, 255, 255, 0.75),\n        rgba(0, 0, 0, 0.75),\n        rgba(255, 255, 255, 0.75),\n        rgba(0, 0, 0, 0.75),\n        rgba(255, 255, 255, 0.75)\n      )\n      repeat;\n    background-size: 400% 100%;\n    width: 6rem;\n    height: 16px;\n    border-radius: 9999px;\n    animation: ${animation};\n    line-height: 0;\n  `}\n`;\n\nexport default Progress;\n","import React, { useEffect, useRef, useMemo, useState, useCallback } from 'react';\nimport styled from 'styled-components';\nimport debounce from 'lodash/debounce';\n\nimport { useSpring, a } from '@react-spring/web';\nimport { useDrag } from 'react-use-gesture';\nimport useMeasure from 'react-use-measure';\nimport { ResizeObserver } from '@juggle/resize-observer';\n\nimport fonts from '../../enums/fonts';\nimport { clamp } from '../../utils/math';\nimport { mergeRefs } from '../../utils/refs';\n\nimport {\n  ValueProp,\n  ContainerProps,\n  HandleProps,\n  HandleLabelProps,\n  RangeSliderProps,\n  DomainLabelProps,\n} from './types';\nimport { useAccessibilityPreferences, useAnalytics, useTheme } from '../../context';\nimport { StyledBaseDiv } from '../../htmlElements';\n\nexport const Container = styled.div`\n  ${({ showDomainLabels, hasHandleLabels, disabled, beingDragged = false }: ContainerProps) => `\n    display: flex;\n    position: relative;\n    height: 1rem;\n    width: 100%;\n\n    ${fonts.body}\n\n    user-select: none;\n\n    ${beingDragged ? 'cursor: grabbing;' : ''}\n\n    transition: filter .1s;\n\n    ${\n      disabled\n        ? `\n        filter: grayscale(1) contrast(.5) brightness(1.2);\n        pointer-events: none;\n      `\n        : ''\n    }\n\n    \n\n    ${\n      showDomainLabels\n        ? `\n        top: -.5rem;\n        margin-top: 1rem;\n      `\n        : ''\n    };\n\n    ${\n      hasHandleLabels\n        ? `\n      top: -.75rem;\n      margin-top: 1.5rem;\n    `\n        : ''\n    };\n  `}\n`;\n\nexport const DragHandle = styled(a.div)`\n  ${({ $beingDragged = false, color, $readonly }: HandleProps) => {\n    const { colors } = useTheme();\n    const handleColor = color || colors.primary;\n    return `\n      position: absolute;\n      \n      width: 1rem;\n      height: 1rem;\n      align-self: center;\n      left: -.5rem;\n\n      background-color: ${handleColor};\n      color: ${handleColor};\n      border: .125rem solid ${colors.background};\n      border-radius: 50%;\n      \n      touch-action: none;\n      filter: url(#blur);\n      cursor: ${$beingDragged ? 'grabbing' : 'grab'};\n      cursor: ${$readonly ? 'default' : ''};\n      z-index: 2;\n    `;\n  }}\n`;\n\nexport const HandleLabel = styled.div`\n  ${({ velocity = 0 }: HandleLabelProps) => {\n    const { colors } = useTheme();\n    return `\n      position: absolute;\n      bottom: 100%;\n      left: 50%;\n      transform: translateX(-50%) rotate(${clamp(velocity, -45, 45)}deg);\n      background-color: ${colors.background};\n      border-radius: 4px;\n      font-weight: bold;\n      white-space: nowrap;\n      pointer-events: none;\n      z-index: 2;\n    `;\n  }}\n`;\n\nexport const SlideRail = styled.div`\n  ${() => {\n    const { colors } = useTheme();\n    return `\n      position: absolute;\n      width: 100%;\n      height: 0.25rem;\n\n      overflow: hidden;\n      align-self: center;\n\n      border-radius: 0.125rem;\n      background-color: ${colors.grayXlight};\n    `;\n  }}\n`;\n\nexport const SelectedRangeRail = styled(a.div)`\n  ${() => {\n    const { colors } = useTheme(); // TODO: don't force the color to be primary\n    return `\n      position: absolute;\n      top: 0%;\n      height: 100%;\n\n      background-color: ${colors.primary};\n    `;\n  }}\n`;\n\nexport const DomainLabel = styled.div`\n  ${({ position }: DomainLabelProps) => {\n    const { colors } = useTheme();\n    return `\n      position: absolute;\n      bottom: 100%;\n      ${position}: 0rem;\n      color: ${colors.grayMedium};\n      font-size: .5rem;\n    `;\n  }}\n`;\n\nexport const Marker = styled(StyledBaseDiv)`\n  ${({ sliderPosition = 0 }) => {\n    const { colors } = useTheme();\n    return `\n      position: absolute;\n      text-align: center;\n      display: flex;\n      justify-content: center;\n      height: 1rem;\n      width: 2px;\n      left: ${sliderPosition}px;\n      background-color: ${colors.grayLight};\n    `;\n  }}\n`;\nexport const MarkerLabel = styled(StyledBaseDiv)`\n  ${({ color }) => {\n    const { colors } = useTheme();\n    return `\n    position: absolute;\n    bottom: 100%;\n    white-space: nowrap;\n    font-size: .375rem;\n    color: ${color || colors.grayLight};\n  `;\n  }}\n`;\n\nexport const RangeSlider = ({\n  StyledContainer = Container,\n  StyledDragHandle = DragHandle,\n  StyledHandleLabel = HandleLabel,\n  StyledSlideRail = SlideRail,\n  StyledSelectedRangeRail = SelectedRangeRail,\n  StyledDomainLabel = DomainLabel,\n  StyledMarker = Marker,\n  StyledMarkerLabel = MarkerLabel,\n\n  containerProps = {},\n  dragHandleProps = {},\n  handleLabelProps = {},\n  slideRailProps = {},\n  selectedRangeRailProps = {},\n  domainLabelProps = {},\n  markerProps = {},\n  markerLabelProps = {},\n\n  containerRef,\n  dragHandleRef,\n  slideRailRef,\n  handleLabelRef,\n  selectedRangeRailRef,\n  domainLabelRef,\n  markerRef,\n  markerLabelRef,\n\n  showDomainLabels = true,\n  showSelectedRange = true,\n  showHandleLabels = true,\n\n  springOnRelease,\n  animated = true,\n\n  debounceInterval = 8,\n  onDrag,\n  onChange,\n  onDebounceChange,\n  onRelease,\n\n  disabled = false,\n  readonly = false,\n  min,\n  max,\n  values,\n  markers = [],\n  testId,\n  dragHandleAttachment = 'mouse',\n}: RangeSliderProps): JSX.Element | null => {\n  if (onDrag) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'From FoundryUI RangerSlider: onDrag callback is deprecated. Instead, use onChange or onDebounceChange.',\n    );\n  }\n  if (springOnRelease !== undefined) {\n    animated = springOnRelease;\n    // eslint-disable-next-line no-console\n    console.warn(\n      'From FoundryUI RangeSlider: springOnRelease is deprecated. Instead, use animated.',\n    );\n  }\n\n  const { prefersReducedMotion } = useAccessibilityPreferences();\n  const isInitializing = useRef(true);\n\n  const debouncedOnChange = useRef(\n    debounce(newVal => {\n      if (onDrag) onDrag(newVal);\n      if (onDebounceChange) onDebounceChange(newVal);\n    }, debounceInterval),\n  ).current;\n\n  const debouncedOnRelease = useRef(\n    // wait an extra ms. onRelease should be called after onChange\n    debounce(newVal => onRelease && onRelease(newVal), debounceInterval + 1),\n  ).current;\n\n  /** Convert passed-in `number` values into `ValueProps` */\n  const processVal = (val: number | ValueProp): ValueProp =>\n    typeof val === 'number' ? { value: val, label: undefined, color: undefined } : val;\n\n  const processedValues: Array<ValueProp> = useMemo(\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore expression not callable\n    () => values?.map(processVal) ?? [],\n    [values],\n  );\n\n  const processedMarkers: Array<ValueProp> = useMemo(\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore expression not callable\n    () => markers?.map(processVal) ?? [],\n    [markers],\n  );\n\n  const hasHandleLabels = useMemo(\n    () => processedValues?.some(val => val.label !== null && val.label !== undefined),\n    [processedValues],\n  );\n\n  const domain = max - min;\n\n  const handleEventWithAnalytics = useAnalytics();\n\n  const handleDrag = useCallback(\n    (newVal: number) => {\n      if (readonly) return;\n\n      handleEventWithAnalytics(\n        'RangeSlider',\n        () => {\n          if (onChange) onChange(newVal);\n          debouncedOnChange(newVal);\n        },\n        'onDrag',\n        { type: 'onDrag', newVal },\n        containerProps,\n      );\n    },\n\n    [readonly, handleEventWithAnalytics, containerProps, onChange, debouncedOnChange],\n  );\n\n  // set the drag value asynchronously at a lower frequency for better performance\n  const valueBuffer = useRef(0);\n\n  // keep track of which handle is being dragged (if any)\n  const [draggedHandle, setDraggedHandle] = useState(-1);\n  // get the bounding box of the slider\n\n  const [ref, sliderBounds] = useMeasure({ polyfill: ResizeObserver });\n\n  const pixelPositions = processedValues.map(val => {\n    return (val.value / domain) * sliderBounds.width;\n  });\n\n  // get the x offset and an animation setter function\n  const [{ dragHandleX }, springRef] = useSpring(() => ({\n    to: { dragHandleX: 0 },\n    friction: 13,\n    tension: 100,\n  }));\n\n  const handleSlideRailClick = useCallback(\n    (e: React.MouseEvent) => {\n      // Avoiding using another ref here to reduce overhead\n      const pixelPosition = e.clientX;\n      const positionOnRail = pixelPosition - sliderBounds.left;\n      const railPositionRatio = positionOnRail / sliderBounds.width;\n      const clickedValue = railPositionRatio * domain;\n\n      // variables to find the closest handle\n      let closestVal: number | ValueProp | undefined;\n      let smallestDifference: number;\n\n      // Find the closest handle\n      processedValues.forEach(val => {\n        const finalVal = typeof val === 'number' ? val : val.value;\n        // Get the absolute value of the difference\n        const difference = Math.abs(clickedValue - finalVal);\n        if (smallestDifference !== undefined && difference < smallestDifference) {\n          closestVal = val;\n          smallestDifference = difference;\n        } else if (smallestDifference === undefined) {\n          closestVal = val;\n          smallestDifference = difference;\n        }\n      });\n\n      if (closestVal) {\n        if (onDrag) onDrag(clickedValue);\n        if (onChange) onChange(clickedValue);\n        if (onDebounceChange) onDebounceChange(clickedValue);\n        if (onRelease) onRelease(clickedValue);\n\n        if (slideRailProps.onMouseDown && typeof slideRailProps.onMouseDown === 'function') {\n          e.persist();\n          slideRailProps.onMouseDown(e);\n        }\n      }\n    },\n    [\n      slideRailProps,\n      sliderBounds,\n      onChange,\n      onDebounceChange,\n      onRelease,\n      onDrag,\n      domain,\n      processedValues,\n    ],\n  );\n\n  const handleSlideRailClickWithAnalytics = (e: any) => {\n    if (readonly) return;\n    handleEventWithAnalytics('RangeSlider', handleSlideRailClick, 'onClick', e, containerProps);\n  };\n\n  const bind = useDrag(\n    ({ down: isDragging, movement: [deltaX] }) => {\n      if (readonly) return;\n\n      const delta = (deltaX / sliderBounds.width) * domain;\n      valueBuffer.current = clamp(delta, min, max);\n      setDraggedHandle(isDragging ? 0 : -1);\n      handleDrag(valueBuffer.current);\n\n      if (dragHandleAttachment === 'mouse') {\n        if (isDragging) {\n          // constantly follow mouse during drag\n          springRef.start({\n            dragHandleX: deltaX,\n            immediate: true,\n          });\n        } else {\n          // after drag release, spring to value\n          springRef.start({\n            dragHandleX: pixelPositions[0],\n            immediate: prefersReducedMotion || !animated,\n          });\n        }\n      }\n    },\n    {\n      initial: [(pixelPositions ?? [0])[0], 0],\n      threshold: 1,\n      bounds: {\n        left: 0,\n        right: sliderBounds.width + 4,\n        top: -8,\n        bottom: sliderBounds.height / 2 + 8,\n      },\n      rubberband: 0.1,\n    },\n  );\n\n  // Once sliderBounds are read, set initial position\n  useEffect(() => {\n    if (isInitializing.current && sliderBounds.width) {\n      springRef.start({\n        dragHandleX: pixelPositions[0],\n        immediate: true,\n        onResolve: () => {\n          isInitializing.current = false;\n        },\n      });\n    }\n  }, [springRef, sliderBounds, isInitializing, pixelPositions]);\n\n  // For snap to value, listen to changes in value and always animate to value. Also listens to clicks\n  useEffect(() => {\n    if (dragHandleAttachment === 'value' || draggedHandle === -1) {\n      springRef.start({\n        dragHandleX: pixelPositions[0],\n        immediate: prefersReducedMotion || !animated,\n      });\n    }\n  }, [\n    dragHandleAttachment,\n    springRef,\n    pixelPositions,\n    prefersReducedMotion,\n    sliderBounds,\n    animated,\n    draggedHandle,\n  ]);\n\n  // Dispose of debounce timers\n  useEffect(() => {\n    return () => {\n      debouncedOnChange.cancel();\n      debouncedOnRelease.cancel();\n    };\n  }, [debouncedOnChange, debouncedOnRelease]);\n\n  return (\n    <StyledContainer\n      data-test-id={['hs-ui-range-slider', testId].join('-')}\n      disabled={disabled}\n      readonly={readonly}\n      hasHandleLabels={hasHandleLabels}\n      showHandleLabels={showHandleLabels}\n      showDomainLabels={showDomainLabels}\n      ref={containerRef}\n      {...containerProps}\n    >\n      <StyledSlideRail\n        ref={mergeRefs<HTMLDivElement>([slideRailRef, ref])}\n        {...slideRailProps}\n        onMouseDown={handleSlideRailClickWithAnalytics}\n      >\n        {showSelectedRange && values && (\n          <StyledSelectedRangeRail\n            min={min}\n            max={max}\n            values={processedValues}\n            style={{\n              width: dragHandleX,\n            }}\n            ref={selectedRangeRailRef}\n            {...selectedRangeRailProps}\n          />\n        )}\n      </StyledSlideRail>\n\n      {showDomainLabels && (\n        <>\n          <StyledDomainLabel position=\"left\" ref={domainLabelRef} {...domainLabelProps}>\n            {min}\n          </StyledDomainLabel>\n          <StyledDomainLabel position=\"right\" {...domainLabelProps}>\n            {max}\n          </StyledDomainLabel>\n        </>\n      )}\n\n      {processedValues.map(({ value, color, label }, i) => (\n        <StyledDragHandle\n          // eslint-disable-next-line react/jsx-props-no-spreading\n          {...bind()}\n          draggable={false}\n          $beingDragged={i === draggedHandle}\n          style={{ x: dragHandleX }}\n          color={color}\n          // eslint-disable-next-line react/no-array-index-key\n          key={`handle${i}`}\n          ref={dragHandleRef}\n          onMouseUp={() => debouncedOnRelease(value)}\n          $readonly={readonly}\n          {...dragHandleProps}\n        >\n          {showHandleLabels && (\n            <StyledHandleLabel value={value} ref={handleLabelRef} {...handleLabelProps}>\n              {label}\n            </StyledHandleLabel>\n          )}\n        </StyledDragHandle>\n      ))}\n\n      {processedMarkers.map(({ value, color, label }) => (\n        <StyledMarker\n          key={`marker-${value}`}\n          id={`marker-${value}`}\n          sliderPosition={(value / domain) * sliderBounds.width}\n          ref={markerRef}\n          {...markerProps}\n        >\n          <StyledMarkerLabel color={color} ref={markerLabelRef} {...markerLabelProps}>\n            {label}\n          </StyledMarkerLabel>\n        </StyledMarker>\n      ))}\n    </StyledContainer>\n  );\n};\n\nRangeSlider.Container = Container;\nRangeSlider.DragHandle = DragHandle;\nRangeSlider.HandleLabel = HandleLabel;\nRangeSlider.SlideRail = SlideRail;\nRangeSlider.SelectedRangeRail = SelectedRangeRail;\nRangeSlider.DomainLabel = DomainLabel;\nRangeSlider.Marker = Marker;\nRangeSlider.MarkerLabel = MarkerLabel;\n\nexport default RangeSlider;\n","import React from 'react';\nimport { parseToRgb } from 'polished';\nimport styled, { keyframes, css } from 'styled-components';\n\nimport { useAccessibilityPreferences, useTheme } from '../../context';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { StyledBaseDiv } from '../../htmlElements';\n\nexport const movingGradient = keyframes`\n  0% { background-position: 0vw bottom; }\n  100% { background-position: 100vw bottom; }\n`;\n\nexport const animation = css`\n  ${movingGradient} 2s linear infinite;\n`;\n\nconst SkeletonShimmer = styled(StyledBaseDiv)`\n  ${({ isLoading, color, animatedShimmer }) => {\n    const rgb = parseToRgb(color);\n\n    return css`\n      opacity: ${isLoading ? 1 : 0};\n\n      background: linear-gradient(\n          90deg,\n          rgba(${Object.values(rgb).join(', ')}, 0.75),\n          rgba(${Object.values(rgb).join(', ')}, 0.25),\n          rgba(${Object.values(rgb).join(', ')}, 0.75)\n        )\n        repeat;\n\n      color: transparent;\n      user-select: none;\n      pointer-events: none;\n\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n\n      background-size: 100vw 100vh;\n      background-attachment: fixed;\n      border-radius: 0.25rem;\n      animation: ${animatedShimmer ? animation : 'none'};\n    `;\n  }}\n`;\n\nconst SkeletonContainer = styled(StyledBaseDiv)`\n  ${({ isLoading }: { isLoading: boolean }) => `\n  display: block;\n\n  position: relative;\n    & > * {\n      transition: opacity .2s;\n    }\n\n  ${\n    isLoading\n      ? `\n        color: transparent !important;\n        & > *:not(${SkeletonShimmer}) {\n          opacity: 0 !important;\n          user-select: none;\n          pointer-events: none;\n        }\n    `\n      : ''\n  }\n  `}\n`;\n\nexport type SkeletonProps = {\n  StyledContainer?: StyledSubcomponentType;\n  StyledShimmer?: StyledSubcomponentType;\n\n  containerProps?: SubcomponentPropsType;\n  shimmerProps?: SubcomponentPropsType;\n\n  containerRef?: React.RefObject<HTMLElement>;\n  shimmerRef?: React.RefObject<HTMLElement>;\n\n  children?: React.ReactNode;\n  color?: string;\n  isLoading?: boolean;\n  animatedShimmer?: boolean;\n};\n\nconst Skeleton = ({\n  StyledContainer = SkeletonContainer,\n  StyledShimmer = SkeletonShimmer,\n  containerProps,\n  shimmerProps,\n  containerRef,\n  shimmerRef,\n  children,\n  color,\n  isLoading = false,\n  animatedShimmer = true,\n}: SkeletonProps): JSX.Element | null => {\n  const { colors } = useTheme();\n  const { prefersReducedMotion } = useAccessibilityPreferences();\n\n  const finalColor = color || colors.grayLight;\n  const finalAnimationPreference = !prefersReducedMotion && animatedShimmer;\n\n  return (\n    <StyledContainer isLoading={isLoading} {...containerProps} ref={containerRef}>\n      {children}\n      <StyledShimmer\n        animatedShimmer={finalAnimationPreference}\n        isLoading={isLoading}\n        color={finalColor}\n        {...shimmerProps}\n        ref={shimmerRef}\n      />\n    </StyledContainer>\n  );\n};\n\nSkeleton.Container = SkeletonContainer;\nSkeleton.Shimmer = SkeletonShimmer;\n\nexport default Skeleton;\n","import React, {\n  MouseEvent,\n  ReactNode,\n  RefObject,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport styled from 'styled-components';\nimport { animated, useSpring } from '@react-spring/web';\nimport { Portal } from 'react-portal';\n\nimport { mergeRefs } from '../../utils/refs';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { useScrollObserver, useWindowSizeObserver } from '../../utils/hooks';\nimport { useTheme, useAnalytics } from '../../context';\nimport { AnimatedDiv } from '../../htmlElements';\n\nconst SpotlightContainer = styled(AnimatedDiv)`\n  height: 100%;\n  width: 100%;\n\n  position: fixed;\n  top: 0;\n  left: 0;\n  contain: strict;\n  clip-path: url(#foundryMask);\n  z-index: 200;\n`;\n\nconst BackgroundBlurrer = styled(AnimatedDiv)`\n  position: fixed;\n  z-index: -1;\n`;\n\nconst Annotation = styled(AnimatedDiv)`\n  display: inline-block;\n  position: fixed;\n  top: 0;\n  left: 0;\n  padding-bottom: 1rem;\n\n  z-index: 201;\n\n  width: fit-content;\n  max-width: 50vw;\n`;\n\nexport enum SpotlightShapes {\n  circular = 'circular',\n  round = 'round',\n  box = 'box',\n  'roundedBox' = 'rounded box',\n}\n\n// Recursively crawl the dom to find the nearest scrolling parent of the target element\nconst findNearestScrollingParent = (el: HTMLElement | Element): HTMLElement | Element | null => {\n  const parent = el.parentElement;\n\n  if (parent && parent.tagName !== 'HTML') {\n    if (parent?.scrollHeight > parent?.clientHeight) {\n      // found it!\n      return parent;\n    }\n    return findNearestScrollingParent(parent);\n  }\n\n  // passing it back down\n  return null;\n};\n\nexport type SpotlightProps = {\n  StyledContainer?: StyledSubcomponentType;\n  containerProps?: SubcomponentPropsType;\n  containerRef?: RefObject<HTMLElement>;\n\n  StyledAnnotation?: StyledSubcomponentType;\n  annotationProps?: SubcomponentPropsType;\n  annotationRef?: RefObject<HTMLElement>;\n\n  children?: ReactNode;\n  targetElement?: HTMLElement | Element;\n  scrollingParentElement?: HTMLElement | Element;\n  backgroundBlur?: string;\n  backgroundDarkness?: number;\n  shape?: SpotlightShapes;\n  cornerRadius?: number;\n  padding?: number;\n  onClick?: (e: MouseEvent) => void;\n  animateTargetChanges?: boolean;\n  // onAnimationEnd?: ControllerProps['onRest'];\n  onAnimationEnd?: () => void;\n  animationSpringConfig?: Record<string, unknown>;\n  resizeUpdateInterval?: number;\n  scrollUpdateInterval?: number;\n};\n\nconst Spotlight = ({\n  StyledContainer = SpotlightContainer,\n  containerProps,\n  containerRef,\n\n  StyledAnnotation = Annotation,\n  annotationProps,\n  annotationRef,\n\n  children,\n  targetElement,\n  scrollingParentElement, // this will get automatically picked if not defined\n  backgroundBlur = '0.25rem',\n  backgroundDarkness = 0.3,\n  shape = SpotlightShapes.circular,\n  cornerRadius = 12,\n  padding = 12, // 8px === .5rem\n  onClick,\n  animateTargetChanges = true,\n  onAnimationEnd,\n  animationSpringConfig,\n  resizeUpdateInterval = 0,\n  scrollUpdateInterval = 0,\n}: SpotlightProps): JSX.Element | null => {\n  const handleEventWithAnalytics = useAnalytics();\n  const scrollTarget = useRef(scrollingParentElement || null);\n\n  const {\n    width: windowWidth,\n    height: windowHeight,\n    isResizing,\n  } = useWindowSizeObserver(resizeUpdateInterval, 50);\n\n  const { scrollY, isScrolling } = useScrollObserver(scrollUpdateInterval, 50, {\n    target: scrollTarget.current || undefined,\n  });\n\n  const {\n    performanceInfo: { tier: gpuTier },\n    accessibilityPreferences: { prefersReducedMotion },\n  } = useTheme();\n\n  const internalAnnotationRef: RefObject<HTMLElement> = useRef(null);\n\n  /* Scroll to new position if need-be */\n\n  const [isAutoScrolling, setIsAutoScrolling] = useState(false);\n\n  useEffect(() => {\n    if (targetElement && !scrollTarget.current) {\n      scrollTarget.current = findNearestScrollingParent(targetElement);\n    }\n  }, [targetElement]);\n\n  useEffect(() => {\n    if (targetElement) {\n      const newTargetTop = targetElement?.getBoundingClientRect().top ?? 0;\n      const annotationHeight = internalAnnotationRef?.current?.getBoundingClientRect().height;\n      // TODO: https://github.com/Headstorm/foundry-ui/issues/315\n      // This assumes the annotation is above the target\n      // when custom above/under alignment is implemented, this logic should change\n      // (if the annotation is below the target, this should be an addition, not subtraction)\n      const offset = annotationHeight ? newTargetTop - annotationHeight : newTargetTop;\n\n      if (scrollTarget.current) {\n        // TODO: https://github.com/Headstorm/foundry-ui/issues/483\n        // compare offset with the scrollTarget scrollHeight,\n        // if it's larger, subtract them and scroll the window next\n\n        scrollTarget.current.scrollTo({\n          top: offset,\n          left: 0,\n          behavior: !animateTargetChanges || prefersReducedMotion ? 'auto' : 'smooth',\n        });\n      } else {\n        window.scrollBy({\n          top: offset,\n          left: 0,\n          behavior: !animateTargetChanges || prefersReducedMotion ? 'auto' : 'smooth',\n        });\n      }\n\n      setIsAutoScrolling(true);\n    }\n  }, [\n    animateTargetChanges,\n    internalAnnotationRef,\n    prefersReducedMotion,\n    scrollTarget,\n    targetElement,\n  ]);\n\n  useEffect(() => {\n    // check if auto scroll has completed\n    if (isScrolling === false && isAutoScrolling === true) {\n      setIsAutoScrolling(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isScrolling]);\n\n  /* Build spotlight shape */\n\n  const rect = useMemo<Pick<DOMRect, 'x' | 'y' | 'width' | 'height' | 'bottom' | 'right'>>(() => {\n    const defaultVal = {\n      x: windowWidth / 2,\n      y: windowHeight / 2,\n      width: 0,\n      height: 0,\n      bottom: windowHeight / 2,\n      left: windowWidth / 2,\n      top: windowHeight / 2,\n      right: windowWidth / 2,\n    };\n\n    if (targetElement) {\n      const bounds = targetElement?.getBoundingClientRect();\n\n      if (shape === SpotlightShapes.circular) {\n        if (bounds.width > bounds.height) {\n          const newHeight = bounds.width;\n          bounds.y -= (newHeight - bounds.height) * 0.5;\n          bounds.height = newHeight;\n        } else if (bounds.width < bounds.height) {\n          const newWidth = bounds.height;\n          bounds.x -= (newWidth - bounds.width) / 2;\n          bounds.width = newWidth;\n        }\n      }\n\n      bounds.x -= padding;\n      bounds.y -= padding;\n      bounds.width += padding * 2;\n      bounds.height += padding * 2;\n      return bounds;\n    }\n    return defaultVal;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [targetElement, padding, windowWidth, windowHeight, shape, scrollY]);\n\n  const radii = [Math.min(cornerRadius, rect.width / 2), Math.min(cornerRadius, rect.height / 2)];\n  if (shape === SpotlightShapes.round) {\n    radii[0] = rect.width / 2;\n    radii[1] = rect.height / 2;\n  } else if (shape === SpotlightShapes.box) {\n    radii[0] = 0;\n    radii[1] = 0;\n  }\n\n  const outerRectPath = `M 0 0 h${windowWidth} v${windowHeight} h-${windowWidth}`;\n  const innerShapePath = `\n    M ${rect.x} ${rect.y + radii[1]}\n    Q ${rect.x} ${rect.y}, ${rect.x + radii[0]} ${rect.y}\n    L ${rect.x + rect.width - radii[0]} ${rect.y}\n    Q ${rect.x + rect.width} ${rect.y}, ${rect.x + rect.width} ${rect.y + radii[1]}\n    L ${rect.x + rect.width} ${rect.y + rect.height - radii[1]}\n    Q ${rect.x + rect.width} ${rect.y + rect.height}, ${rect.x + rect.width - radii[0]} ${\n    rect.y + rect.height\n  }\n    L ${rect.x + radii[0]} ${rect.y + rect.height}\n    Q ${rect.x} ${rect.y + rect.height}, ${rect.x} ${rect.y + rect.height - radii[1]}\n    L ${rect.x} ${rect.y + radii[1]}\n  `;\n\n  const radius = Math.max(rect.width, rect.height) / 2;\n  const circularPath = `${outerRectPath} \n    M ${rect.x} ${rect.y + rect.height / 2}\n    A ${radius}, ${radius}, 0, 1, 1, ${rect.x} ${rect.y + rect.height / 2 + 1}\n    L ${rect.x} ${rect.y + rect.height / 2}\n  `;\n  const finalRectangularPath = `${outerRectPath} ${innerShapePath}`;\n\n  /* Setup animation */\n\n  const [\n    {\n      containerFilter,\n      containerBackgroundColor,\n      lightPath,\n      circularLightPath,\n\n      annotationTransform,\n\n      topBlurHeight,\n      topBlurWidth,\n      bottomBlurY,\n      bottomBlurHeight,\n      bottomBlurWidth,\n      leftBlurY,\n      leftBlurHeight,\n      leftBlurWidth,\n      rightBlurY,\n      rightBlurHeight,\n      rightBlurWidth,\n    },\n    spring,\n  ] = useSpring(() => ({\n    containerOpacity: 0,\n    containerFilter: 'blur(0rem)',\n    containerBackgroundColor: 'rgba(0,0,0,0)',\n\n    lightPath: finalRectangularPath,\n    circularLightPath: circularPath,\n\n    annotationTransform: `translate(${rect.x}px, ${rect.y}px) translate(0%, -100%)`,\n\n    topBlurWidth: windowWidth,\n    topBlurHeight: rect.y - 1,\n\n    bottomBlurY: rect.bottom,\n    bottomBlurWidth: windowWidth,\n    bottomBlurHeight: windowHeight - rect.bottom - 1,\n\n    leftBlurY: rect.y,\n    leftBlurWidth: rect.x,\n    leftBlurHeight: rect.height + 2,\n\n    rightBlurY: rect.y,\n    rightBlurWidth: windowWidth - rect.right - padding - 4,\n    rightBlurHeight: rect.height + 2,\n    immediate:\n      !animateTargetChanges ||\n      prefersReducedMotion ||\n      (isScrolling && !isAutoScrolling) ||\n      isResizing,\n    config: {\n      round: gpuTier < 2 ? 1 : undefined,\n      ...animationSpringConfig,\n    },\n    onRest: onAnimationEnd,\n  }));\n\n  useEffect(() => {\n    spring.start(() => ({\n      containerOpacity: 1,\n      containerFilter: gpuTier < 2 ? 'blur(0rem)' : `blur(${backgroundBlur})`,\n      containerBackgroundColor: `rgba(0,0,0,${1 - backgroundDarkness})`,\n\n      lightPath: finalRectangularPath,\n      circularLightPath: circularPath,\n\n      annotationTransform: `translate(${rect.x}px, ${rect.y}px) translate(0%, -100%)`, // TODO: change second translate to make different attach positions https://github.com/Headstorm/foundry-ui/issues/315\n\n      topBlurWidth: windowWidth,\n      topBlurHeight: Math.max(rect.y - 1, 0),\n\n      bottomBlurY: rect.bottom,\n      bottomBlurWidth: windowWidth,\n      bottomBlurHeight: windowHeight - rect.bottom - 1,\n\n      leftBlurY: rect.y,\n      leftBlurWidth: rect.x,\n      leftBlurHeight: rect.height + 2,\n\n      rightBlurY: rect.y,\n      rightBlurWidth: windowWidth - rect.right - padding - 4,\n      rightBlurHeight: rect.height + 2,\n\n      onRest: onAnimationEnd,\n      immediate:\n        !animateTargetChanges ||\n        prefersReducedMotion ||\n        (isScrolling && !isAutoScrolling) ||\n        isResizing,\n    }));\n  }, [\n    targetElement,\n    shape,\n    backgroundBlur,\n    backgroundDarkness,\n    padding,\n    cornerRadius,\n    windowWidth,\n    windowHeight,\n    isScrolling,\n    scrollY,\n    isAutoScrolling,\n    isResizing,\n    spring,\n    finalRectangularPath,\n    circularPath,\n    rect.x,\n    rect.y,\n    rect.bottom,\n    rect.height,\n    rect.right,\n    animateTargetChanges,\n    onAnimationEnd,\n    gpuTier,\n    prefersReducedMotion,\n  ]);\n\n  /* onClick */\n\n  const handleClick = (evt: MouseEvent) => {\n    // TODO: Rename to onClickOutside?\n    handleEventWithAnalytics('Spotlight', onClick, 'onClick', evt, containerProps);\n  };\n\n  return (\n    <Portal>\n      <StyledContainer\n        onClick={handleClick}\n        style={{\n          backgroundColor: containerBackgroundColor,\n        }}\n        ref={containerRef}\n        {...containerProps}\n      >\n        <BackgroundBlurrer\n          style={{\n            backdropFilter: containerFilter,\n            top: 0,\n            left: 0,\n            width: topBlurWidth,\n            height: topBlurHeight,\n          }}\n        />\n        <BackgroundBlurrer\n          style={{\n            backdropFilter: containerFilter,\n            top: bottomBlurY,\n            left: 0,\n            width: bottomBlurWidth,\n            height: bottomBlurHeight,\n          }}\n        />\n        <BackgroundBlurrer\n          style={{\n            backdropFilter: containerFilter,\n            top: leftBlurY,\n            left: 0,\n            width: leftBlurWidth,\n            height: leftBlurHeight,\n          }}\n        />\n        <BackgroundBlurrer\n          style={{\n            backdropFilter: containerFilter,\n            top: rightBlurY,\n            right: 0,\n            width: rightBlurWidth,\n            height: rightBlurHeight,\n          }}\n        />\n      </StyledContainer>\n      <svg\n        style={{ position: 'fixed', top: 0, left: 0 }}\n        viewBox={`0 0 ${windowWidth} ${windowHeight}`}\n        width={0}\n        height={0}\n      >\n        <defs>\n          <clipPath clipRule=\"evenodd\" id=\"foundryMask\">\n            <animated.path\n              fill=\"#FFFFFF\"\n              d={shape === SpotlightShapes.circular ? circularLightPath : lightPath}\n            />\n          </clipPath>\n        </defs>\n      </svg>\n      <StyledAnnotation\n        style={{ transform: annotationTransform }}\n        ref={mergeRefs<HTMLElement>([annotationRef, internalAnnotationRef])}\n        {...annotationProps}\n      >\n        {children}\n      </StyledAnnotation>\n    </Portal>\n  );\n};\n\nSpotlight.Container = SpotlightContainer;\nSpotlight.Annotation = Annotation;\nSpotlight.SpotlightShapes = SpotlightShapes;\n\nexport default Spotlight;\n","import React, { useEffect, useState } from 'react';\nimport styled, { css } from 'styled-components';\nimport useResizeObserver from 'use-resize-observer/polyfilled';\nimport { mdiArrowDown, mdiChevronDown, mdiChevronRight, mdiChevronUp } from '@mdi/js';\nimport Icon from '@mdi/react';\nimport {\n  StyledBaseDiv,\n  StyledBaseSpan,\n  StyledBaseTable,\n  StyledBaseTD,\n  StyledBaseTH,\n  StyledBaseTR,\n} from '../../htmlElements';\nimport {\n  CellOptions,\n  Column,\n  InternalExpansionIconProps,\n  RowEntry,\n  RowProps,\n  SortDirection,\n  SortState,\n  TableProps,\n} from './types';\nimport { useAnalytics, useTheme } from '../../context';\nimport { mergeRefs } from '../../utils/refs';\n\n/** Start of styled components */\n\nconst StyledExpansionIconSpan = styled(StyledBaseSpan)`\n  cursor: pointer;\n`;\n\nexport const TableContainer = styled(StyledBaseTable)`\n  ${({ reachedMinWidth }: { reachedMinWidth?: boolean }) => {\n    const { colors } = useTheme();\n    return css`\n      width: ${reachedMinWidth ? '100%' : 'auto'};\n      background-color: ${colors.background};\n      border-collapse: collapse;\n\n      border-radius: 8px;\n      overflow: hidden;\n    `;\n  }}\n`;\n\nexport const Header = styled(StyledBaseTR)`\n  ${({ columnGap, columnWidths }: RowProps) => {\n    const { colors } = useTheme();\n    return css`\n      display: grid;\n      grid-template-columns: ${columnWidths};\n      padding: 0em 2em;\n      column-gap: ${columnGap};\n      user-select: none;\n\n      background-color: ${colors.primary};\n      color: white;\n    `;\n  }}\n`;\n\nexport const HeaderCell = styled(StyledBaseTH)`\n  ${({ sortable }: { sortable: boolean }) => css`\n    display: flex;\n    flex-flow: row;\n    cursor: pointer;\n    padding: 1em 0em 1em 1em;\n    margin-left: -1em;\n\n    transition: background-color 0.5s;\n\n    ${sortable ? '' : 'pointer-events: none;'}\n\n    &:hover {\n      background-color: rgba(255, 255, 255, 0.2);\n    }\n  `}\n`;\n\nexport const Footer = styled(StyledBaseTR)`\n  ${({ columnGap, columnWidths }: RowProps) => {\n    const { colors } = useTheme();\n    return css`\n      display: grid;\n      grid-template-columns: ${columnWidths};\n      padding: 0em 2em;\n      column-gap: ${columnGap};\n      user-select: none;\n\n      background-color: ${colors.grayXlight};\n      color: ${colors.black};\n    `;\n  }}\n`;\n\nexport const FooterCell = styled(StyledBaseTH)`\n  display: flex;\n  flex-flow: row;\n  cursor: pointer;\n  padding: 1em 0em 1em 1em;\n  margin-left: -1em;\n\n  transition: background-color 0.5s;\n  &:hover {\n    background-color: rgba(255, 255, 255, 0.2);\n  }\n`;\n\nexport const ResponsiveHeaderCell = styled(StyledBaseSpan)`\n  ${({ sortable }: { sortable: boolean }) => {\n    const { colors } = useTheme();\n    return css`\n      display: block;\n      word-break: break-word;\n      hyphens: auto;\n      color: ${colors.primary};\n      user-select: none;\n      padding: 0.5em;\n      cursor: pointer;\n      margin-right: 0.5em;\n      background-color: rgba(0, 0, 0, 0.05);\n      border-radius: 0.5rem;\n      ${sortable ? '' : 'pointer-events: none;'}\n    `;\n  }}\n`;\n\nexport const Row = styled(StyledBaseTR)`\n  ${({ columnGap, columnWidths, reachedMinWidth, isCollapsed = false }: RowProps) => {\n    const { colors } = useTheme();\n    return css`\n      display: grid;\n      grid-template-columns: ${reachedMinWidth ? '100%' : columnWidths};\n      padding: ${reachedMinWidth ? '1em' : '0em'} 2em;\n      row-gap: 0.5em;\n      column-gap: ${columnGap};\n      position: relative;\n      background-color: ${colors.background};\n      ${isCollapsed ? 'height: 0px;' : ''}\n\n      &:not(:last-child) {\n        border-bottom: 1px solid rgb(211, 214, 215);\n      }\n\n      &:before {\n        content: '';\n        z-index: 0;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.2);\n        opacity: 0;\n        transition: opacity 0.3s;\n\n        pointer-events: none;\n      }\n      &:hover:before {\n        opacity: 0.3;\n      }\n    `;\n  }}\n`;\n\nexport const GroupRow = styled(Row)`\n  ${() => {\n    const { colors } = useTheme();\n    return `\n      background-color: ${colors.grayXlight};\n    `;\n  }}\n`;\n\nexport const Cell = styled(StyledBaseTD)`\n  display: block;\n  word-break: break-word;\n  hyphens: auto;\n  width: unset;\n  padding: 0.5em 0;\n`;\n\n/** Accepts the `$direction` prop of type `SortDirection` */\nexport const SortIcon = styled(Icon)`\n  ${({ $direction }: { $direction?: SortDirection | boolean | null }) => {\n    if (typeof $direction === 'boolean') {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'From FoundryUI Table: Passing a boolean to the `direction` prop on `SortIcon` is deprecated. Use the `Table.SortDirection` enum instead.',\n      );\n    }\n    return css`\n      margin-left: 1em;\n      fill: white;\n      width: 1em;\n      transition: transform 0.2s, opacity 0.5s;\n      opacity: ${$direction === null || $direction === SortDirection.noSort ? 0 : 1};\n      transform: rotate(\n        ${$direction === true || $direction === SortDirection.ascending ? 0 : 180}deg\n      );\n    `;\n  }};\n`;\n\nconst CellContainer = styled(StyledBaseDiv)`\n  display: flex;\n  padding: 0.5em 0;\n`;\n\n/** Start of variables */\n\nconst defaultCollapsed: Record<string, string> = {};\n\n// Default expansion column added if there isn't one\nconst collapsedExpandedIconColumn = {\n  name: '',\n  sortable: false,\n  width: '1em',\n};\n\n// Keyboard listener required for a11y on the clickable span\nconst onKeyPress = (evt: React.KeyboardEvent<HTMLSpanElement>) => {\n  if (evt.key === 'Enter' || evt.key === ' ') {\n    evt.preventDefault();\n    (evt.target as any).click();\n  }\n};\n\n// Supporting component used for the collapse icon by default in the Table\nconst ExpansionIcon: React.FunctionComponent<InternalExpansionIconProps> = ({\n  isCollapsed,\n  groupHeaderPosition,\n  onClick,\n}: InternalExpansionIconProps) => {\n  const expanded = groupHeaderPosition === 'above' ? mdiChevronDown : mdiChevronUp;\n  const path = isCollapsed ? mdiChevronRight : expanded;\n\n  const handleEventWithAnalytics = useAnalytics();\n\n  const handleClick = (e: any) =>\n    handleEventWithAnalytics('ExpansionIcon', onClick, isCollapsed ? 'expand' : 'collapse', e, {\n      name: 'ExpansionIcon',\n    });\n\n  return (\n    <StyledExpansionIconSpan\n      tabIndex={0}\n      onClick={handleClick}\n      role=\"button\"\n      onKeyPress={onKeyPress}\n    >\n      <Icon path={path} size=\"1em\" />\n    </StyledExpansionIconSpan>\n  );\n};\n\nexport const ExpansionIconColumnName = '__EXPANSION_COLUMN__';\n\n// TODO: Add the table width observer to a container which fills the area, so the table can grow\n// once there is enough room for it to do so (if the table itself isn't full width)\n// TODO: Add window width media query to complement the table width media query API\n\nconst Table = ({\n  columnGap = '1em',\n  columns,\n  areGroupsCollapsible = false,\n  data = [],\n  defaultSort = { sortedColumnKey: undefined, direction: SortDirection.noSort },\n  groupHeaderPosition = 'above',\n  expansionIconComponent,\n  minWidthBreakpoint = 640,\n  sortGroups = false,\n\n  StyledCell = Cell,\n  StyledContainer = TableContainer,\n  StyledGroupLabelRow = GroupRow,\n  StyledHeader = Header,\n  StyledHeaderCell = HeaderCell,\n  StyledResponsiveHeaderCell = ResponsiveHeaderCell,\n  StyledRow = Row,\n  StyledFooter = Footer,\n  StyledFooterCell = FooterCell,\n  StyledCellContainer = CellContainer,\n\n  cellProps = {},\n  containerProps = {},\n  groupLabelRowProps = {},\n  headerProps = {},\n  headerCellProps = {},\n  responsiveHeaderCellProps = {},\n  rowProps = {},\n\n  containerRef,\n  groupLabelRowRef,\n  headerRef,\n}: TableProps): JSX.Element => {\n  // Convert defaultSort argument if provided in the deprecated form [key, bool]\n  if (Array.isArray(defaultSort)) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'From FoundryUI Table: Passing `defaultSort` prop as type [string, boolean] is deprecated. Instead, pass an argument of type `Table.SortState`.',\n    );\n    let direction: SortDirection;\n\n    if (defaultSort[0] === '') {\n      direction = SortDirection.noSort;\n    } else {\n      direction = defaultSort[1] ? SortDirection.ascending : SortDirection.descending;\n    }\n    defaultSort = {\n      direction,\n      sortedColumnKey: defaultSort[0],\n    };\n  }\n\n  const [sortedData, setSortedData] = useState(data);\n  const [sortState, setSortState] = useState<SortState>(defaultSort);\n  const [collapsedGroups, setCollapsedGroups] = useState(defaultCollapsed);\n  const { ref, width = Infinity } = useResizeObserver({ box: 'border-box' });\n\n  const usingGroups: boolean = data && data.length > 0 && Array.isArray(data[0]);\n  const copiedColumns = { ...columns }; // Shallow copy so not to manipulate props\n  if (areGroupsCollapsible && !copiedColumns[ExpansionIconColumnName]) {\n    copiedColumns[ExpansionIconColumnName] = collapsedExpandedIconColumn;\n  }\n\n  // this builds the string from the columns\n  const columnWidths = Object.values(copiedColumns)\n    .map((col: Column) => {\n      if (col.minTableWidth && width <= col.minTableWidth) {\n        return '0px';\n      }\n      return col.width || '1fr';\n    })\n    .join(' ');\n\n  /**\n   * Toggles a group's collapse state\n   * @param key\n   */\n  const toggleGroupCollapse = (key: string) => {\n    const group = collapsedGroups[key];\n\n    // Make a copy of the dictionary-like object. Because this object\n    // doesn't have nested objects, a shallow copy is fine\n    const temp = { ...collapsedGroups };\n    if (group) {\n      delete temp[key];\n    } else {\n      temp[key] = key;\n    }\n\n    setCollapsedGroups(temp);\n  };\n\n  /**\n   * A compare function that returns a comparison integer (1 or -1).\n   * Used to compare the values at one column key across two different rows when sorting.\n   */\n  const compareEntries = (\n    entry1: any,\n    entry2: any,\n    column: Column,\n    sortDirection: SortDirection,\n  ) => {\n    // If this column has a sort custom sort function, use it.\n    if (column && Object.prototype.hasOwnProperty.call(column, 'sortFunction')) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore Cannot invoke an object which is possibly 'undefined'.ts(2722)\n      const customComparison = column.sortFunction(entry1, entry2);\n      if (sortDirection === SortDirection.ascending) {\n        return customComparison ? -1 : 1;\n      }\n      return customComparison ? 1 : -1;\n    }\n\n    // No sort function, use default comparison operator.\n    if (typeof entry1 === 'string' && typeof entry2 === 'string') {\n      const comparison =\n        sortDirection === SortDirection.ascending\n          ? entry1.toLocaleLowerCase() < entry2.toLocaleLowerCase()\n          : entry1.toLocaleLowerCase() > entry2.toLocaleLowerCase();\n      return comparison ? -1 : 1;\n    }\n\n    const comparison =\n      sortDirection === SortDirection.ascending ? entry1 < entry2 : entry1 > entry2;\n    return comparison ? -1 : 1;\n  };\n\n  /**\n   * Sorts the data in the table. If the table is using groups, group contents are sorted.\n   * If the group order is chosen to be sorted as well, the group contents are sorted, followed\n   * by the sorting of the groups based on the first element in the group\n   * @param key\n   * @param newDirection\n   */\n  const onSort = ({ sortedColumnKey: key, direction: newDirection }: SortState) => {\n    setSortState({ sortedColumnKey: key, direction: newDirection });\n    setCollapsedGroups(defaultCollapsed);\n\n    // no sort, reset data to passed-in data prop\n    if (key === undefined || newDirection === SortDirection.noSort) {\n      setSortedData(data);\n      return;\n    }\n\n    // Shallow copy the data to keep `data` prop un-mutated.\n    const localData = [...data];\n\n    // If the first element of the data is not an array, then we do not have groups\n    if (!Array.isArray(localData[0])) {\n      // No groups, sort all data\n      localData.sort((row1: any, row2: any) =>\n        compareEntries(row1[key], row2[key], copiedColumns[key], newDirection),\n      );\n    } else {\n      // Shallow copy each group\n      for (let groupIndex = 0; groupIndex < localData.length; groupIndex++) {\n        localData[groupIndex] = [...(localData[groupIndex] as RowEntry[])];\n      }\n\n      // Sort the content of each group\n      (localData as Array<Array<RowEntry>>).forEach(group => {\n        group.sort((row1: any, row2: any) =>\n          compareEntries(row1[key], row2[key], copiedColumns[key], newDirection),\n        );\n      });\n\n      // Sort the groups\n      if (sortGroups) {\n        (localData as Array<Array<RowEntry>>).sort(\n          (group1: Array<RowEntry>, group2: Array<RowEntry>) =>\n            compareEntries(group1[0][key], group2[0][key], copiedColumns[key], newDirection),\n        );\n      }\n    }\n\n    setSortedData(localData);\n  };\n\n  const handleEventWithAnalytics = useAnalytics();\n  const handleOnSort = (sort: SortState) =>\n    handleEventWithAnalytics('Table', () => onSort(sort), 'onSort', sort, { containerProps });\n\n  useEffect(() => {\n    handleOnSort(sortState);\n  }, [data]); // eslint-disable-line react-hooks/exhaustive-deps\n\n  const getNewSortState = (key: string): SortState => ({\n    sortedColumnKey: key,\n    // If we're changing sort state of an already-sorted column, cycle through direction. Otherwise, start at ascending.\n    direction:\n      sortState.sortedColumnKey === key ? (sortState.direction + 1) % 3 : SortDirection.ascending,\n  });\n\n  /**\n   * Creates a cell to render\n   * @param {CellOptions} options - The options used when building a cell\n   * @param {any} options.RenderedCell - The component used as the cell\n   * @param {string} options.headerColumnKey - The header column key for the cell\n   * @param {boolean} options.breakPointHit - If the breakpoint has been hit for width\n   * @param {RowEntry} options.row - the data for the row, each cell should be able to the row's data\n   * @param {number} options.index - The index of the cell in the row\n   * @param {number} options.indexModifier - Used only when creating cells in a group. Used to account for group labels\n   * @param {any} options.CollapseExpandedIcon - Component to be used for the collapse icon. Only used for collapsible group label cells\n   * @param {number} options.groupIndex - The index of the group. Used only when creating cells as part of a group\n   * @param {boolean} options.isCollapsed - Used when creating cells with a CollapseExpandedIcon\n   * @param {string} options.groupLabelDataString - The stringified version of the group label row\n   * @param {any} options.cellProps - Props to pass through to RenderedCell\n   */\n  const createCell = ({\n    RenderedCell,\n    headerColumnKey,\n    breakPointHit,\n    row,\n    index,\n    indexModifier = 0,\n    CollapseExpandedIcon,\n    groupIndex,\n    isCollapsed = false,\n    groupLabelDataString,\n    cellProps: cellPropsInput,\n  }: CellOptions): JSX.Element | false => {\n    return (\n      (!copiedColumns[headerColumnKey].minTableWidth || breakPointHit) && (\n        <StyledCellContainer>\n          {columns[headerColumnKey].name !== '' &&\n            width < minWidthBreakpoint &&\n            !groupLabelDataString && (\n              <StyledResponsiveHeaderCell\n                onClick={() => {\n                  handleOnSort(getNewSortState(headerColumnKey));\n                }}\n                sortable={copiedColumns[headerColumnKey].sortable}\n                isSorted={\n                  sortState.sortedColumnKey === headerColumnKey &&\n                  sortState.direction !== SortDirection.noSort\n                }\n                {...responsiveHeaderCellProps}\n              >\n                {copiedColumns[headerColumnKey].name}\n                <SortIcon\n                  $direction={\n                    sortState.sortedColumnKey && sortState.sortedColumnKey === headerColumnKey\n                      ? sortState.direction\n                      : SortDirection.noSort\n                  }\n                  path={mdiArrowDown}\n                />\n              </StyledResponsiveHeaderCell>\n            )}\n\n          <RenderedCell\n            // all cells should have full access to all the data in the row\n            {...row}\n            index={index}\n            groupIndex={groupIndex}\n            reachedMinWidth={width < minWidthBreakpoint}\n            key={`${headerColumnKey}${index + indexModifier}`}\n            {...cellPropsInput}\n          >\n            {row && row[headerColumnKey]}\n            {CollapseExpandedIcon &&\n            usingGroups &&\n            areGroupsCollapsible &&\n            headerColumnKey === ExpansionIconColumnName ? (\n              <CollapseExpandedIcon\n                isCollapsed={isCollapsed}\n                groupHeaderPosition={groupHeaderPosition}\n                onClick={() => {\n                  toggleGroupCollapse((groupLabelDataString || JSON.stringify(row)) + groupIndex);\n                }}\n              />\n            ) : null}\n          </RenderedCell>\n        </StyledCellContainer>\n      )\n    );\n  };\n\n  /**\n   * Creates groups to be rendered within the Table.\n   */\n  const createGroups = () => {\n    // Generate groupings - Note that we are making shallow copies of the arrays so that we do not\n    // modify the props directly since this is an Array of Arrays.\n    return [...(sortedData as Array<Array<RowEntry>>)].map(\n      (group: Array<RowEntry>, idx: number) => {\n        const groupLabelIndex: number = group.findIndex(grp => {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          return grp.isGroupLabel === true;\n        });\n\n        // Copy to avoid manipulating props directly\n        const groupCopy = [...group];\n\n        // Get the group label data. This is to be used to generate the group 'header'\n        const groupLabelData = groupLabelIndex >= 0 ? groupCopy[groupLabelIndex] : undefined;\n\n        // Stringify the object one time to save cpu cycles later.\n        const groupLabelDataString = JSON.stringify(groupLabelData);\n\n        // Get index modifier for creating the rows of the data. Everything group element's index\n        // should be increased by 1 for all labels that are above the group\n        const indexModifier = groupHeaderPosition === 'above' ? 1 : 0;\n        const isCollapsed = !!collapsedGroups[groupLabelDataString + idx];\n\n        // Generate the rows for this group\n        const rows = groupCopy.map((row: RowEntry, index: number) => {\n          const RenderedRow = row.rowComponent || StyledRow;\n          if (index === groupLabelIndex) return null;\n\n          return (\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore - TS2604: JSX element type does not have any construct or call signatures\n            <RenderedRow\n              columnGap={columnGap}\n              columnWidths={columnWidths}\n              rowNum={index + indexModifier}\n              key={`row${JSON.stringify(row) + index}`}\n              reachedMinWidth={width < minWidthBreakpoint}\n              isCollapsed={areGroupsCollapsible && isCollapsed}\n              {...row}\n              {...rowProps}\n            >\n              {Object.keys(copiedColumns).map(headerColumnKey => {\n                const RenderedCell = copiedColumns[headerColumnKey].cellComponent || StyledCell;\n                const breakPointHit =\n                  width > (copiedColumns[headerColumnKey].minTableWidth || Infinity);\n\n                const options: CellOptions = {\n                  RenderedCell,\n                  headerColumnKey,\n                  breakPointHit,\n                  row,\n                  index,\n                  indexModifier,\n                  groupIndex: idx,\n                  isCollapsed,\n                };\n                // Declaring each cell of the row\n                return (\n                  (!copiedColumns[headerColumnKey].minTableWidth || breakPointHit) &&\n                  createCell(options)\n                );\n              })}\n            </RenderedRow>\n          );\n        });\n\n        // Remove the null entered for group label if it exists\n        if (groupLabelIndex >= 0) {\n          rows.splice(groupLabelIndex, 1);\n        }\n\n        // Check to see if a group label should be created and inserted into the row\n        if (groupLabelData) {\n          const index = indexModifier === 0 ? rows.length : 0;\n          const RenderedRow = groupLabelData.rowComponent || StyledGroupLabelRow;\n          const CollapseExpandedIcon = expansionIconComponent || ExpansionIcon;\n          const label = (\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore - TS2604: JSX element type does not have any construct or call signatures\n            <RenderedRow\n              columnGap={columnGap}\n              columnWidths={columnWidths}\n              rowNum={index}\n              key={`row${groupLabelDataString}`}\n              reachedMinWidth={width < minWidthBreakpoint}\n              ref={groupLabelRowRef}\n              {...groupLabelData}\n              {...groupLabelRowProps}\n            >\n              {Object.keys(copiedColumns).map(headerColumnKey => {\n                const RenderedCell = usingGroups\n                  ? copiedColumns[headerColumnKey].groupCellComponent ||\n                    copiedColumns[headerColumnKey].cellComponent ||\n                    StyledCell\n                  : copiedColumns[headerColumnKey].cellComponent || StyledCell;\n                const breakPointHit =\n                  width > (copiedColumns[headerColumnKey].minTableWidth || Infinity);\n\n                const options = {\n                  breakPointHit,\n                  RenderedCell,\n                  headerColumnKey,\n                  row: groupLabelData,\n                  groupLabelDataString,\n                  index,\n                  groupIndex: idx,\n                  CollapseExpandedIcon,\n                  isCollapsed,\n                  cellProps,\n                };\n                // Create each cell for the row\n                return (\n                  (!copiedColumns[headerColumnKey].minTableWidth || breakPointHit) &&\n                  createCell(options)\n                );\n              })}\n            </RenderedRow>\n          );\n\n          // Place the group label at the appropriate index to get rendered\n          if (index === 0) {\n            rows.splice(0, 0, label);\n          } else {\n            rows.push(label);\n          }\n        }\n\n        return <tbody key={`group${idx}`}>{rows}</tbody>;\n      },\n    );\n  };\n\n  /**\n   * Generates the rows that appear in the Table\n   */\n  const createRows = () => {\n    // If there are groups, create the groups using special logic\n    if (usingGroups) {\n      return createGroups();\n    }\n\n    return (\n      <tbody>\n        {(sortedData as Array<RowEntry>).map((row: RowEntry, index: number) => {\n          // map over the rows\n          const RenderedRow = row.rowComponent || StyledRow;\n          // Rows.map return\n          return (\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore - TS2604: JSX element type does not have any construct or call signatures\n            <RenderedRow\n              columnGap={columnGap}\n              columnWidths={columnWidths}\n              rowNum={index}\n              key={`row${JSON.stringify(row)}`}\n              reachedMinWidth={width < minWidthBreakpoint}\n              {...row}\n              {...rowProps}\n            >\n              {Object.keys(copiedColumns).map(headerColumnKey => {\n                const RenderedCell = copiedColumns[headerColumnKey].cellComponent || StyledCell;\n                const breakPointHit =\n                  width > (copiedColumns[headerColumnKey].minTableWidth || Infinity);\n                // Create each cell of the row\n                return createCell({ RenderedCell, headerColumnKey, breakPointHit, row, index });\n              })}\n            </RenderedRow>\n          );\n        })}\n      </tbody>\n    );\n  };\n\n  const hasFooter = Object.values(copiedColumns)\n    // this table has a footer if any of the columns have footerContent\n    .some(col => {\n      return (\n        Object.prototype.hasOwnProperty.call(col, 'footerContent') &&\n        col.footerContent !== null && // isn't null\n        col.footerContent !== undefined &&\n        col.footerContent !== ''\n      );\n    });\n\n  // Table return\n  return (\n    <StyledContainer\n      ref={mergeRefs<HTMLTableElement>([ref, containerRef])}\n      reachedMinWidth={width < minWidthBreakpoint}\n      {...containerProps}\n    >\n      <thead>\n        {width > minWidthBreakpoint && (\n          <StyledHeader\n            columnGap={columnGap}\n            columnWidths={columnWidths}\n            ref={headerRef}\n            {...headerProps}\n          >\n            {Object.keys(copiedColumns).map((headerColumnKey: string) => {\n              const RenderedHeaderCell =\n                copiedColumns[headerColumnKey].headerCellComponent || StyledHeaderCell;\n              const breakpointHit =\n                width > (copiedColumns[headerColumnKey].minTableWidth || Infinity);\n\n              // columns.map return\n              return (\n                (!copiedColumns[headerColumnKey].minTableWidth || breakpointHit) && (\n                  <RenderedHeaderCell\n                    key={headerColumnKey}\n                    onClick={() => handleOnSort(getNewSortState(headerColumnKey))}\n                    sortable={copiedColumns[headerColumnKey].sortable}\n                    isSorted={\n                      sortState.sortedColumnKey === headerColumnKey &&\n                      sortState.direction !== SortDirection.noSort\n                    }\n                    {...headerCellProps}\n                  >\n                    {copiedColumns[headerColumnKey].name}\n                    <SortIcon\n                      $direction={\n                        sortState.sortedColumnKey && sortState.sortedColumnKey === headerColumnKey\n                          ? sortState.direction\n                          : SortDirection.noSort\n                      }\n                      path={mdiArrowDown}\n                    />\n                  </RenderedHeaderCell>\n                )\n              );\n            })}\n          </StyledHeader>\n        )}\n      </thead>\n      {createRows()}\n      <tfoot>\n        {width > minWidthBreakpoint && hasFooter && (\n          <StyledFooter columnGap={columnGap} columnWidths={columnWidths}>\n            {Object.keys(copiedColumns).map((headerColumnKey: string, index: number) => {\n              const RenderedFooterCell = StyledFooterCell;\n              const breakpointHit =\n                width > (copiedColumns[headerColumnKey].minTableWidth || Infinity);\n              return (\n                (!copiedColumns[headerColumnKey].minTableWidth || breakpointHit) && (\n                  <RenderedFooterCell key={`f${index}`}>\n                    {copiedColumns[headerColumnKey].footerContent}\n                  </RenderedFooterCell>\n                )\n              );\n            })}\n          </StyledFooter>\n        )}\n      </tfoot>\n    </StyledContainer>\n  );\n};\n\nTable.Container = TableContainer;\nTable.Header = Header;\nTable.HeaderCell = HeaderCell;\nTable.Row = Row;\nTable.GroupRow = GroupRow;\nTable.Cell = Cell;\n/**\n * @deprecated use Table.ResponsiveTitle\n */\nTable.Title = ResponsiveHeaderCell;\nTable.ResponsiveHeaderCell = ResponsiveHeaderCell;\nTable.CellContainer = CellContainer;\nTable.ExpansionIconColumnName = ExpansionIconColumnName;\nTable.SortDirection = SortDirection;\n\nexport default Table;\n","import React, { ReactNode } from 'react';\nimport UnstyledIcon from '@mdi/react';\nimport { mdiLoading } from '@mdi/js';\nimport styled, { StyledComponentBase } from 'styled-components';\nimport timings from '../../enums/timings';\nimport { useTheme } from '../../context';\nimport variants from '../../enums/variants';\nimport Progress from '../Progress/Progress';\nimport { StyledBaseDiv, StyledBaseSpan } from '../../htmlElements';\nimport { getFontColorFromVariant, getBackgroundColorFromVariant } from '../../utils/color';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { getShadowStyle } from '../../utils/styles';\n\nexport type TagContainerProps = {\n  elevation: number;\n  color: string;\n  variant: variants;\n  type: string;\n  disabled: boolean;\n};\n\nexport type IconContainerProps = {\n  hasContent: boolean;\n  position: 'right' | 'left';\n};\n\nexport type TagProps = {\n  iconPrefix?: string | JSX.Element;\n  iconSuffix?: string | JSX.Element;\n  isLoading?: boolean;\n  isProcessing?: boolean;\n  children?: ReactNode;\n  elevation?: number;\n  variant?: variants;\n  color?: string;\n  id?: string;\n\n  containerProps?: SubcomponentPropsType;\n  iconPrefixContainerProps?: SubcomponentPropsType;\n  iconSuffixContainerProps?: SubcomponentPropsType;\n  loadingBarProps?: SubcomponentPropsType;\n  StyledContainer?: StyledSubcomponentType;\n  StyledIconContainer?: StyledSubcomponentType;\n  StyledLoadingBar?: StyledSubcomponentType;\n  containerRef?: React.RefObject<HTMLSpanElement>;\n  iconPrefixContainerRef?: React.RefObject<HTMLElement>;\n  iconSuffixContainerRef?: React.RefObject<HTMLElement>;\n  loadingBarRef?: React.RefObject<HTMLElement>;\n};\n\nexport const Container: string & StyledComponentBase<any, {}, TagContainerProps> = styled(\n  StyledBaseSpan,\n)`\n  ${({ elevation = 0, color, variant }: TagContainerProps) => {\n    const { colors } = useTheme();\n    const backgroundColor = getBackgroundColorFromVariant(variant, color, colors.transparent);\n    const fontColor = getFontColorFromVariant(variant, color, colors.background, colors.grayDark);\n\n    return `\n      display: inline-flex;\n      font-size: 1em;\n      padding: .75em 1em;\n      border-radius: 0.25em;\n      transition:\n        background-color ${timings.fast},\n        color ${timings.slow},\n        outline ${timings.slow},\n        filter ${timings.slow},\n        box-shadow ${timings.slow};\n      ${getShadowStyle(elevation, colors.shadow)}\n      outline: 0 none;\n      border: ${variant === variants.outline ? `1px solid ${color || colors.grayDark};` : '0 none;'}\n      background-color: ${backgroundColor};\n      color: ${fontColor};\n      align-items: center;\n    `;\n  }}\n`;\n\nconst StyledProgress = styled(Progress)`\n  width: 5em;\n  height: 10px;\n  margin-top: -5px;\n  margin-bottom: -5px;\n`;\n\nconst IconContainer = styled(StyledBaseDiv)`\n  ${({ position, hasContent }: IconContainerProps) => {\n    return `\n    height: 1em;\n    ${hasContent ? `margin-${position === 'right' ? 'left' : 'right'}: 1em;` : ''}\n  `;\n  }}\n`;\n\nconst Tag = ({\n  iconPrefix,\n  iconSuffix,\n  isLoading,\n  isProcessing,\n  children,\n  elevation = 0,\n  variant = variants.fill,\n  color,\n  id,\n\n  containerProps = {},\n  iconPrefixContainerProps = {},\n  iconSuffixContainerProps = {},\n  loadingBarProps = {},\n\n  containerRef,\n  iconPrefixContainerRef,\n  iconSuffixContainerRef,\n  loadingBarRef,\n\n  StyledContainer = Container,\n  StyledIconContainer = IconContainer,\n  StyledLoadingBar = StyledProgress,\n}: TagProps): JSX.Element => {\n  const hasContent = Boolean(children);\n  const { colors } = useTheme();\n  const containerColor = color || colors.grayLight;\n  // get everything we expose + anything consumer wants to send to container\n  const mergedContainerProps = {\n    id,\n    elevation,\n    color: containerColor,\n    variant,\n    ...containerProps,\n  };\n\n  return isLoading ? (\n    <StyledContainer ref={containerRef} {...mergedContainerProps}>\n      <StyledLoadingBar ref={loadingBarRef} {...loadingBarProps} />\n    </StyledContainer>\n  ) : (\n    <StyledContainer ref={containerRef} {...mergedContainerProps}>\n      {!isProcessing &&\n        iconPrefix &&\n        (typeof iconPrefix === 'string' && iconPrefix !== '' ? (\n          <StyledIconContainer\n            hasContent={hasContent}\n            position=\"left\"\n            ref={iconPrefixContainerRef}\n            {...iconPrefixContainerProps}\n          >\n            <UnstyledIcon path={iconPrefix} size=\"1em\" />\n          </StyledIconContainer>\n        ) : (\n          <StyledIconContainer ref={iconPrefixContainerRef}>{iconPrefix}</StyledIconContainer>\n        ))}\n      {isProcessing && (\n        <StyledIconContainer\n          hasContent={hasContent}\n          position=\"left\"\n          ref={iconPrefixContainerRef}\n          {...iconPrefixContainerProps}\n        >\n          <UnstyledIcon path={mdiLoading} size=\"1em\" spin={1} />\n        </StyledIconContainer>\n      )}\n      {children}\n\n      {iconSuffix &&\n        (typeof iconSuffix === 'string' ? (\n          <StyledIconContainer\n            hasContent={hasContent}\n            position=\"right\"\n            ref={iconSuffixContainerRef}\n            {...iconSuffixContainerProps}\n          >\n            <UnstyledIcon path={iconSuffix} size=\"1em\" />\n          </StyledIconContainer>\n        ) : (\n          <StyledIconContainer\n            hasContent={hasContent}\n            position=\"right\"\n            ref={iconSuffixContainerRef}\n            {...iconSuffixContainerProps}\n          >\n            {iconSuffix}\n          </StyledIconContainer>\n        ))}\n    </StyledContainer>\n  );\n};\n\nTag.Container = Container;\nTag.LoadingBar = StyledProgress;\nTag.IconContainer = IconContainer;\nexport default Tag;\n","import React, { ReactNode, RefObject } from 'react';\nimport styled from 'styled-components';\nimport Icon from '@mdi/react';\nimport { mdiLoading } from '@mdi/js';\nimport Skeleton from '../Skeleton/Skeleton';\nimport { StyledBaseSpan } from '../../htmlElements';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\n\n/* Default Styled Text Container */\nexport const TextContainer = styled(StyledBaseSpan)`\n  ${({ size, color }: { size: string; color: string }) => `\n    font-size: ${size};\n    color: ${color};\n  `}\n`;\n\nexport interface TextProps {\n  children?: ReactNode;\n  color?: string;\n  iconPrefix?: string | JSX.Element;\n  iconSuffix?: string | JSX.Element;\n  isLoading?: boolean;\n  isProcessing?: boolean;\n  size?: string;\n  StyledSkeletonContainer?: StyledSubcomponentType;\n  StyledContainer?: StyledSubcomponentType;\n  StyledIconContainer?: StyledSubcomponentType;\n  containerProps?: SubcomponentPropsType;\n  iconContainerProps?: SubcomponentPropsType;\n  skeletonProps?: SubcomponentPropsType;\n  containerRef?: RefObject<HTMLDivElement>;\n  iconPrefixContainerRef?: RefObject<HTMLElement>;\n  iconSuffixContainerRef?: RefObject<HTMLElement>;\n  skeletonRef?: RefObject<HTMLElement>;\n  shimmerRef?: RefObject<HTMLElement>;\n}\n\nconst StyledSkeletonContainer = styled(Skeleton.Container)`\n  display: inline;\n`;\n\nconst IconContainer = styled(StyledBaseSpan)`\n  ${({ side }: { side: 'left' | 'right' }) => `\n    margin-${side === 'left' ? 'right' : 'left'}: .5em;\n    display: inline-flex;\n    vertical-align: middle;\n  `}\n`;\n\n// TODO: If children are passed in and loading===true,\n// set the children to visibility: none and have the loading bar fill their width\n// that way the end developer can pass \"placeholder\" text for how long the text will probably be\n// when loaded\nconst Text = ({\n  children,\n  color,\n  iconPrefix,\n  iconSuffix,\n  isLoading,\n  isProcessing,\n  size = '1em',\n  StyledContainer = TextContainer,\n  StyledIconContainer = IconContainer,\n  containerProps = {},\n  iconContainerProps = {},\n  skeletonProps = {},\n  containerRef,\n  iconPrefixContainerRef,\n  iconSuffixContainerRef,\n  skeletonRef,\n  shimmerRef,\n}: TextProps): JSX.Element => (\n  <StyledContainer\n    data-test-id=\"hsui-Text\"\n    size={size}\n    color={color}\n    ref={containerRef}\n    {...containerProps}\n  >\n    {!isProcessing &&\n      iconPrefix &&\n      (typeof iconPrefix === 'string' && iconPrefix !== '' ? (\n        <StyledIconContainer side=\"left\" ref={iconPrefixContainerRef} {...iconContainerProps}>\n          <Icon path={iconPrefix} size={size} />\n        </StyledIconContainer>\n      ) : (\n        <StyledIconContainer\n          side=\"left\"\n          size={size}\n          ref={iconPrefixContainerRef}\n          {...iconContainerProps}\n        >\n          {iconPrefix}\n        </StyledIconContainer>\n      ))}\n    {isProcessing && (\n      <StyledIconContainer side=\"left\" ref={iconPrefixContainerRef} {...iconContainerProps}>\n        <Icon aria-hidden=\"true\" path={mdiLoading} size={size} spin={1} />\n      </StyledIconContainer>\n    )}\n    <Skeleton\n      color={color}\n      isLoading={isLoading}\n      containerRef={skeletonRef}\n      shimmerRef={shimmerRef}\n      StyledContainer={StyledSkeletonContainer}\n      {...skeletonProps}\n    >\n      <StyledBaseSpan>{children}</StyledBaseSpan>\n    </Skeleton>\n\n    {iconSuffix &&\n      (typeof iconSuffix === 'string' && iconSuffix !== '' ? (\n        <StyledIconContainer side=\"right\" ref={iconSuffixContainerRef} {...iconContainerProps}>\n          <Icon path={iconSuffix} size={size} />\n        </StyledIconContainer>\n      ) : (\n        <StyledIconContainer\n          side=\"right\"\n          size={size}\n          ref={iconSuffixContainerRef}\n          {...iconContainerProps}\n        >\n          {iconSuffix}\n        </StyledIconContainer>\n      ))}\n  </StyledContainer>\n);\n\nText.Container = TextContainer;\nText.IconContainer = IconContainer;\nexport default Text;\n","import React, {\n  ChangeEvent,\n  EventHandler,\n  ReactNode,\n  SyntheticEvent,\n  useCallback,\n  useState,\n  TextareaHTMLAttributes,\n  InputHTMLAttributes,\n  useRef,\n  useEffect,\n} from 'react';\nimport styled, { css } from 'styled-components';\nimport Icon from '@mdi/react';\nimport debounce from 'lodash/debounce';\nimport { mdiClose } from '@mdi/js';\nimport { darken } from 'polished';\n\nimport { StyledBaseDiv, StyledBaseInput, StyledBaseTextArea } from '../../htmlElements';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { mergeRefs } from '../../utils/refs';\nimport { useAnalytics, useTheme } from '../../context';\nimport { disabledStyles } from '../../utils/color';\nimport variants from '../../enums/variants';\nimport Button from '../Button';\n\nexport type TextInputContainerProps = {\n  disabled?: boolean;\n  isValid?: boolean;\n  variant?: variants;\n};\n\nconst Container = styled(StyledBaseDiv)`\n  ${({ disabled = false, isValid, variant = variants.outline }: TextInputContainerProps) => {\n    const { colors } = useTheme();\n    const borderColor = isValid === false ? colors.destructive : colors.grayMedium;\n    return `\n      min-width: 10em;\n      position: relative;\n      display: flex;\n      flex-flow: row;\n      align-items: stretch;\n      border-radius: 0.25em;\n      border: ${\n        variant === variants.outline ? `1px solid ${borderColor}` : '1px solid transparent'\n      };\n\n      &:focus-within {\n        outline: none;\n        box-shadow: 0 0 5px 0.150rem ${colors.tertiary};\n      }\n      \n      ${\n        variant === variants.fill\n          ? `border-bottom: 1px solid ${borderColor}; \n            border-bottom-left-radius: 0; \n            border-bottom-right-radius: 0;`\n          : ''\n      }\n      background-color: ${\n        variant === variants.fill ? darken(0.1, colors.background) : colors.background\n      };\n      ${disabled ? disabledStyles() : ''}\n    `;\n  }}\n`;\n\nconst TextInputContainer = styled(StyledBaseInput)`\n  ${() => {\n    const { colors } = useTheme();\n    return `\n      border: 0 none;\n      flex-grow: 1;\n      outline: 0 none;\n      font-size: 1em;\n      padding: 0.5em;\n      background-color: ${colors.transparent};\n  `;\n  }}\n`;\n\nconst TextAreaInputContainer = styled(StyledBaseTextArea)`\n  ${({ multiLineIsResizable }: TextInputProps) => {\n    const { colors } = useTheme();\n    return `\n      border: 0 none;\n      flex-grow: 1;\n      outline: 0 none;\n      font-size: 1em;\n      min-width: 0px;\n      padding: .5em;\n      background-color: ${colors.transparent};\n      resize: ${multiLineIsResizable ? 'both' : 'none'};\n    `;\n  }}\n`;\n\nconst ClearButtonContainer = styled(Button.Container)`\n  padding: 0.5em;\n  height: 100%;\n`;\n\nconst IconContainer = styled(StyledBaseDiv)`\n  ${() => {\n    const { colors } = useTheme();\n    return `\n      padding: 0.5em;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      color: ${colors.grayMedium};\n      cursor: text;\n    `;\n  }}\n`;\n\nconst CharacterCount = styled(StyledBaseDiv)`\n  ${({ textIsTooLong, isValid, errorMessage }) => {\n    const { colors } = useTheme();\n    return css`\n      position: absolute;\n      top: calc(100% + ${isValid && (!errorMessage || errorMessage !== '') ? '0.25em' : '2em'});\n      right: 0.25em;\n      color: ${textIsTooLong ? colors.destructive : colors.grayLight};\n    `;\n  }}\n`;\n\nconst ErrorContainer = styled(StyledBaseDiv)`\n  ${() => {\n    const { colors } = useTheme();\n    return css`\n      position: absolute;\n      top: calc(100% + 0.25em);\n      color: ${colors.destructive};\n      font-size: 0.75em;\n    `;\n  }}\n`;\n\nexport type TextInputProps = InputHTMLAttributes<HTMLInputElement> &\n  TextareaHTMLAttributes<HTMLTextAreaElement> & {\n    iconPrefix?: string | ReactNode;\n    onClear?: (event: SyntheticEvent) => void;\n    clearable?: boolean;\n    debouncedOnChange?: EventHandler<ChangeEvent<HTMLInputElement>>;\n    isValid?: boolean;\n    isMultiline?: boolean;\n    errorMessage?: string;\n    variant?: variants;\n    debounceInterval?: number;\n    multiLineIsResizable?: boolean;\n    maxLength?: number;\n    allowTextBeyondMaxLength?: boolean;\n    showCharacterCount?: boolean;\n\n    StyledContainer?: StyledSubcomponentType;\n    StyledInput?: StyledSubcomponentType;\n    StyledIconContainer?: StyledSubcomponentType;\n    StyledClearButtonContainer?: StyledSubcomponentType;\n    StyledErrorContainer?: StyledSubcomponentType;\n    StyledTextArea?: StyledSubcomponentType;\n    StyledCharacterCount?: StyledSubcomponentType;\n\n    containerProps?: SubcomponentPropsType;\n    inputProps?: SubcomponentPropsType;\n    iconContainerProps?: SubcomponentPropsType;\n    clearButtonContainerProps?: SubcomponentPropsType;\n    errorContainerProps?: SubcomponentPropsType;\n    characterCountProps?: SubcomponentPropsType;\n\n    containerRef?: React.RefObject<HTMLDivElement>;\n    inputRef?: React.RefObject<HTMLInputElement> | ((inst: HTMLInputElement) => void);\n    iconContainerRef?: React.RefObject<HTMLDivElement>;\n    clearButtonContainerRef?: React.RefObject<HTMLButtonElement>;\n    errorContainerRef?: React.RefObject<HTMLDivElement>;\n    characterCountRef?: React.RefObject<HTMLDivElement>;\n  };\n\nconst defaultCallback = () => {}; // eslint-disable-line @typescript-eslint/no-empty-function\n\nconst TextInput = ({\n  debouncedOnChange = defaultCallback,\n  onClear,\n  clearable,\n  iconPrefix,\n  isValid = true,\n  isMultiline,\n  errorMessage,\n  variant = variants.outline,\n  debounceInterval = 8,\n  multiLineIsResizable,\n  maxLength,\n  allowTextBeyondMaxLength = false,\n  showCharacterCount = false,\n\n  StyledContainer = Container,\n  StyledInput = TextInputContainer,\n  StyledIconContainer = IconContainer,\n  StyledClearButtonContainer = ClearButtonContainer,\n  StyledErrorContainer = ErrorContainer,\n  StyledTextArea = TextAreaInputContainer,\n  StyledCharacterCount = CharacterCount,\n\n  containerProps = {},\n  inputProps = {},\n  iconContainerProps = {},\n  clearButtonContainerProps = {},\n  errorContainerProps = {},\n  characterCountProps = {},\n\n  containerRef,\n  inputRef,\n  iconContainerRef,\n  clearButtonContainerRef,\n  errorContainerRef,\n  characterCountRef,\n\n  ...nativeHTMLAttributes\n}: TextInputProps): JSX.Element => {\n  const handleEventWithAnalytics = useAnalytics();\n  const theme = useTheme();\n\n  const handleDebouncedOnChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) =>\n    handleEventWithAnalytics(\n      'TextInput',\n      debouncedOnChange,\n      'debouncedOnChange',\n      e,\n      containerProps,\n    );\n\n  // Debounce the change function using useCallback so that the function is not initialized each time it renders\n  const debouncedChange = useCallback(debounce(handleDebouncedOnChange, debounceInterval), [\n    handleDebouncedOnChange,\n    debounceInterval,\n  ]);\n\n  const internalInputRef = useRef<HTMLInputElement>(null);\n\n  const InputComponent: StyledSubcomponentType = isMultiline ? StyledTextArea : StyledInput;\n\n  const [internalValue, setInternalValue] = useState(\n    nativeHTMLAttributes.value || nativeHTMLAttributes.defaultValue || '',\n  );\n\n  const onClearToUse = useCallback(\n    (evt: SyntheticEvent<Element, Event>) => {\n      // if this is an uncontrolled input\n      if (nativeHTMLAttributes.value === undefined) {\n        if (internalInputRef?.current) {\n          internalInputRef.current.value = '';\n        }\n        setInternalValue('');\n      }\n      if (onClear) {\n        onClear(evt);\n      }\n    },\n    [nativeHTMLAttributes.value, onClear],\n  );\n\n  const handleClear = (e: any) => {\n    handleEventWithAnalytics('TextInput', onClearToUse, 'onClear', e, containerProps);\n  };\n\n  useEffect(() => {\n    if (internalValue !== nativeHTMLAttributes.value && nativeHTMLAttributes.value === '') {\n      setInternalValue('');\n    }\n  }, [internalValue, nativeHTMLAttributes.value]);\n\n  return (\n    <StyledContainer\n      disabled={nativeHTMLAttributes.disabled}\n      isValid={isValid}\n      variant={variant}\n      ref={containerRef}\n      {...containerProps}\n    >\n      {iconPrefix &&\n        (typeof iconPrefix === 'string' ? (\n          <StyledIconContainer\n            onClick={() => internalInputRef.current?.focus()}\n            {...iconContainerProps}\n            ref={iconContainerRef}\n          >\n            <Icon aria-hidden=\"true\" size=\"1em\" path={iconPrefix} />\n          </StyledIconContainer>\n        ) : (\n          <StyledIconContainer onClick={() => internalInputRef.current?.focus()}>\n            {iconPrefix}\n          </StyledIconContainer>\n        ))}\n      <InputComponent\n        // Set default values above nativeHTMLAttributes\n        type=\"text\"\n        disabled={false}\n        cols={10}\n        rows={10}\n        role=\"textbox\"\n        {...nativeHTMLAttributes}\n        onChange={(e: ChangeEvent<HTMLInputElement>) => {\n          e.persist();\n          if (maxLength && maxLength >= 0) {\n            e.target.value = allowTextBeyondMaxLength\n              ? e.target.value\n              : e.target.value.slice(0, maxLength);\n          }\n          setInternalValue(e.target.value);\n          if (nativeHTMLAttributes.onChange) {\n            nativeHTMLAttributes.onChange(e);\n          }\n          debouncedChange(e);\n        }}\n        multiLineIsResizable={multiLineIsResizable}\n        ref={internalInputRef ? mergeRefs<HTMLInputElement>([inputRef, internalInputRef]) : null}\n        {...inputProps}\n      />\n      {clearable && (\n        <Button\n          StyledContainer={StyledClearButtonContainer}\n          containerRef={clearButtonContainerRef}\n          containerProps={{\n            'aria-label': 'Clear',\n            style: { lineHeight: '0' },\n            ...clearButtonContainerProps,\n          }}\n          iconPrefix={mdiClose}\n          leftIconProps={{ style: { height: '1em', width: '1em' } }}\n          disabled={internalValue === ''}\n          onClick={handleClear}\n          color={theme.colors.grayMedium}\n          variant={variants.text}\n        />\n      )}\n      {showCharacterCount && (\n        <StyledCharacterCount\n          ref={characterCountRef}\n          errorMessage={errorMessage}\n          isValid={isValid}\n          textIsTooLong={maxLength ? (internalValue as string).length > maxLength : false}\n          {...characterCountProps}\n        >\n          {(internalValue as string).length} {maxLength !== undefined ? `/ ${maxLength}` : null}\n        </StyledCharacterCount>\n      )}\n      {isValid === false && errorMessage && (\n        <StyledErrorContainer ref={errorContainerRef} {...errorContainerProps}>\n          {errorMessage}\n        </StyledErrorContainer>\n      )}\n    </StyledContainer>\n  );\n};\n\nTextInput.Container = Container;\nTextInput.ErrorContainer = ErrorContainer;\nTextInput.Input = TextInputContainer;\nTextInput.IconContainer = IconContainer;\nTextInput.ClearButtonContainer = ClearButtonContainer;\nTextInput.TextArea = TextAreaInputContainer;\nTextInput.CharacterCount = CharacterCount;\n\nexport default TextInput;\n","import React, { RefObject } from 'react';\nimport styled from 'styled-components';\n\nimport { setLightness, mix, transparentize, readableColor } from 'polished';\nimport { useSwitch } from 'react-aria';\nimport { useToggleState } from '@react-stately/toggle';\nimport { useSpring } from '@react-spring/web';\nimport useMeasure from 'react-use-measure';\nimport { ResizeObserver } from '@juggle/resize-observer';\n\nimport { AnimatedDiv, StyledBaseInput, StyledBaseLabel } from '../../htmlElements';\nimport { SubcomponentPropsType, StyledSubcomponentType } from '../commonTypes';\nimport { useAnalytics, useTheme } from '../../context';\nimport variants from '../../enums/variants';\nimport { disabledStyles } from '../../utils/color';\nimport { mergeRefs } from '../../utils/refs';\n\n// Hide toggle visually but remain accessible to screen readers.\n// Source: https://polished.js.org/docs/#hidevisually\nexport const Input = styled(StyledBaseInput).attrs({ type: 'checkbox' })`\n  border: 0;\n  clip: rect(0 0 0 0);\n  clippath: inset(50%);\n  height: 1px;\n  margin: -1px;\n  overflow: hidden;\n  padding: 0;\n  position: absolute;\n  white-space: nowrap;\n  width: 1px;\n`;\n\nexport const Handle = styled(AnimatedDiv)`\n  ${({ variant, color }) => `\n      ${\n        variant === variants.outline || variant === variants.text\n          ? `border: 1px solid ${color};\n          margin-left: -1px;`\n          : ''\n      }\n      ${\n        variant === variants.fill || variant === variants.text\n          ? `\n              background-color: ${color};\n          `\n          : ''\n      }\n      ${\n        variant === variants.fill\n          ? `\n        box-shadow: 0 .125em .125em -.125em ${transparentize(0.3, setLightness(0.2, color))}; \n      `\n          : ''\n      }\n\n      position: absolute;\n      top: 50%;\n      left 0;\n      transform: translateY(-50%) translateX(0px - calc(.25em / 2));\n\n      border-radius: .5em;\n      width: calc(1em - (.25em));\n      height: calc(1em - (.25em));\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      overflow: visible;\n      margin-right: 0.5em;\n  `}}\n`;\n\nexport const Container = styled(StyledBaseLabel)`\n  ${({\n    color,\n    variant,\n    focusRingColor,\n    disabled,\n  }: {\n    color: string;\n    variant: variants;\n    focusRingColor: string;\n    disabled: boolean;\n  }) => `\n      ${\n        variant === variants.outline || variant === variants.text\n          ? `border: 1px solid ${color};`\n          : ''\n      }\n      ${\n        variant === variants.fill\n          ? `\n        background-color: ${mix(0.4, color, readableColor(color))};\n        box-shadow: 0 .125em .25em -.125em ${transparentize(0.3, setLightness(0.2, color))} inset; \n      `\n          : ''\n      }\n      &:hover {\n        background-color: ${mix(0.3, color, readableColor(color))}\n      }\n      transition: background-color .2s;\n      overflow: hidden;\n\n      position: relative;\n      cursor: pointer;\n      border-radius: .75em;\n      width: 2em;\n      height: 1em;\n      display: inline-block;\n      vertical-align: top;\n\n      &:focus-within {\n        ${Handle} {\n          box-shadow: 0 0 5px 0.150rem ${focusRingColor};\n        }\n      }\n\n      ${disabled ? disabledStyles() : ''}\n    `}\n`;\n\nconst Toggle = ({\n  color,\n  StyledContainer = Container,\n  StyledHandle = Handle,\n  StyledInput = Input,\n\n  containerProps = {},\n  handleProps = {},\n  inputProps = {},\n\n  variant = variants.fill,\n  checked = false,\n  disabled = false,\n  onToggle,\n  containerRef,\n  handleRef,\n  inputRef,\n}: {\n  color?: string;\n\n  StyledContainer?: StyledSubcomponentType;\n  StyledHandle?: StyledSubcomponentType;\n  StyledInput?: StyledSubcomponentType;\n  StyledIcon?: StyledSubcomponentType;\n\n  containerProps?: SubcomponentPropsType;\n  handleProps?: SubcomponentPropsType;\n  inputProps?: SubcomponentPropsType;\n  iconProps?: SubcomponentPropsType;\n\n  variant?: variants;\n  checked?: boolean;\n  disabled?: boolean;\n  onToggle?: (event: React.MouseEvent) => void;\n\n  containerRef?: React.RefObject<HTMLLabelElement>;\n  handleRef?: React.RefObject<HTMLDivElement>;\n  inputRef?: React.RefObject<HTMLInputElement>;\n}): JSX.Element => {\n  const { colors } = useTheme();\n\n  const [measurableContainerRef, containerBounds] = useMeasure({ polyfill: ResizeObserver });\n  const [measurableHandleRef, handleBounds] = useMeasure({ polyfill: ResizeObserver });\n\n  const mergedInputProps = {\n    isDisabled: disabled,\n    isSelected: checked,\n    'aria-label': 'toggle',\n    ...inputProps,\n  };\n\n  const state = useToggleState(mergedInputProps);\n\n  const gutterWidth = (containerBounds.height - handleBounds.height) / 2;\n\n  const { transform } = useSpring({\n    transform: checked\n      ? `translateY(-50%) translateX(${containerBounds.width - handleBounds.width - gutterWidth}px)`\n      : `translateY(-50%) translateX(${gutterWidth}px)`,\n    config: { tension: 250, friction: 20 },\n  });\n\n  const internalRef = React.useRef<HTMLInputElement>(null);\n  const { inputProps: ariaProps } = useSwitch(\n    mergedInputProps,\n    state,\n    internalRef as RefObject<HTMLInputElement>,\n  );\n  const handleEventWithAnalytics = useAnalytics();\n  const handleToggle = (e: any) =>\n    handleEventWithAnalytics('Toggle', onToggle, 'onToggle', e, containerProps);\n\n  return (\n    <StyledContainer\n      color={color || colors.background}\n      ref={mergeRefs<HTMLLabelElement>([containerRef, measurableContainerRef])}\n      variant={variant}\n      focusRingColor={colors.tertiary}\n      disabled={disabled}\n      {...containerProps}\n    >\n      <StyledHandle\n        color={color || colors.background}\n        style={{ transform }}\n        ref={mergeRefs<HTMLDivElement>([handleRef, measurableHandleRef])}\n        checked={checked}\n        variant={variant}\n        {...handleProps}\n      />\n      <StyledInput\n        role=\"switch\"\n        {...ariaProps}\n        checked={checked}\n        onClick={handleToggle}\n        ref={mergeRefs<HTMLInputElement>([inputRef, internalRef])}\n        {...inputProps}\n      />\n    </StyledContainer>\n  );\n};\n\nToggle.Handle = Handle;\nToggle.Input = Input;\nToggle.Container = Container;\n\nexport default Toggle;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport React, { useContext } from 'react';\nimport styled from 'styled-components';\nimport { deviceDetect } from 'react-device-detect';\nimport { TierResult, TierType } from 'detect-gpu';\n\nimport { useReducedMotion } from '../utils/a11y';\nimport { usePerformanceInfo } from '../utils/performance';\nimport fonts from '../enums/fonts';\nimport colorsEnum from '../enums/colors';\nimport { StyledSubcomponentType } from '../components/commonTypes';\n\nexport const defaultGlobalStyles = `\n  ${\n    process.env.NODE_ENV === 'test'\n      ? ''\n      : `\n          box-sizing: border-box;\n          ${fonts.body}\n          `\n  }\n`;\n\n// in order to let users add their own colors to their theme provider,\n// added generic string keys, which makes the type ambiguous but gives users access to colorsEnum\nexport type FoundryColorsType = Record<keyof typeof colorsEnum | string, string>;\n\nexport type AnalyticsFunctionType = (\n  componentType?: string,\n  eventType?: string,\n  eventArgs?: React.ChangeEvent<HTMLInputElement>,\n  dateTime?: Date,\n  deviceInfo?: Record<string, unknown>,\n  currentURL?: string,\n  props?: any,\n) => any;\n\nexport type AccessibilityPreferences = {\n  // TODO: Add to this\n  prefersReducedMotion: boolean;\n};\n\nexport const defaultAnalyticsFunction: AnalyticsFunctionType = (\n  componentType?: string,\n  eventType?: string,\n  eventArgs?: any,\n  dateTime?: Date,\n  deviceInfo?: Record<string, unknown>,\n  currentURL?: string,\n  props?: any,\n): Record<string, unknown> => ({\n  componentType,\n  eventType,\n  eventArgs,\n  dateTime,\n  deviceInfo,\n  currentURL,\n  name: props?.name ? props.name : 'No name provided',\n  analytics: props?.analytics ? props.analytics : 'No analytics object provided',\n});\n\nexport const defaultAccessibilityPreferences: AccessibilityPreferences = {\n  prefersReducedMotion: true,\n};\n\nexport type FoundryContextType = {\n  globalStyles: string;\n  colors: FoundryColorsType;\n  analyticsFunction: AnalyticsFunctionType;\n  performanceInfo: TierResult;\n  accessibilityPreferences: AccessibilityPreferences;\n  styleConstants: Record<string, number | string>;\n};\n\nconst defaultContextValue = {\n  globalStyles: defaultGlobalStyles,\n  colors: colorsEnum,\n  accessibilityPreferences: defaultAccessibilityPreferences,\n  performanceInfo: { tier: 2, type: 'BENCHMARK' as TierType },\n  analyticsFunction: defaultAnalyticsFunction,\n  styleConstants: {},\n  // TODO Add Foundry's \"theme\" to items here and pull from the ContextProvider\n};\n\nexport const FoundryContext = React.createContext<FoundryContextType>(defaultContextValue);\n\nexport const FoundryProvider = ({\n  value = defaultContextValue,\n  children,\n}: {\n  value?: {\n    globalStyles?: string;\n    colors?: FoundryColorsType;\n    analyticsFunction?: AnalyticsFunctionType;\n    styleConstants?: Record<string, string | number>;\n  };\n  children: React.ReactNode;\n}): JSX.Element => {\n  const {\n    globalStyles = defaultGlobalStyles,\n    colors = colorsEnum,\n    styleConstants = {},\n    analyticsFunction = defaultAnalyticsFunction,\n  } = value;\n\n  // causes a rerender\n  const prefersReducedMotion = useReducedMotion();\n  // causes a rerender\n  const performanceInfo = usePerformanceInfo();\n\n  // use the default set of styles, unless we've got something to override\n  const mergedGlobalStyles =\n    globalStyles === defaultGlobalStyles\n      ? globalStyles\n      : `\n    ${defaultGlobalStyles}\n    ${globalStyles}\n  `;\n  const mergedColors = {\n    ...colorsEnum,\n    ...colors,\n  };\n\n  return (\n    <FoundryContext.Provider\n      value={{\n        globalStyles: mergedGlobalStyles,\n        colors: mergedColors,\n        analyticsFunction,\n        accessibilityPreferences: { prefersReducedMotion },\n        performanceInfo,\n        styleConstants,\n      }}\n    >\n      {children}\n    </FoundryContext.Provider>\n  );\n};\n\nexport const useTheme = (): FoundryContextType => {\n  const theme = useContext(FoundryContext);\n  return theme;\n};\n\nexport const useColors = (): FoundryColorsType => {\n  const { colors } = useContext(FoundryContext);\n  return colors;\n};\n\nexport const useAccessibilityPreferences = (): AccessibilityPreferences => {\n  const { accessibilityPreferences } = useContext(FoundryContext);\n  return accessibilityPreferences;\n};\n\nexport const withGlobalStyle = (\n  Component: StyledSubcomponentType,\n): React.ForwardRefExoticComponent<any> => {\n  const ComponentWithGlobalStyles = styled(Component)`\n    ${props => {\n      return props.globalStyles;\n    }}\n  `;\n\n  return React.forwardRef((props: any, ref: any) => {\n    const { globalStyles } = useContext(FoundryContext);\n    return <ComponentWithGlobalStyles globalStyles={globalStyles} {...props} ref={ref} />;\n  });\n};\n\nexport const useAnalytics = (): ((\n  componentType: string,\n  eventFunction: any,\n  eventType: string,\n  eventArgs: any,\n  props: any,\n) => void) => {\n  const context = useContext(FoundryContext);\n  return (\n    componentType: string,\n    eventFunction: any,\n    eventType: string,\n    eventArgs: any,\n    props: any,\n  ): void => {\n    if (eventFunction !== undefined) {\n      eventFunction(eventArgs);\n    }\n    const dateTime = new Date();\n    const deviceInfo: Record<string, unknown> = deviceDetect();\n    deviceInfo.innerHeight =\n      typeof window !== 'undefined'\n        ? window.innerHeight\n        : 'Server Side Rendering Requires the analytics function to handle window dimensions';\n    deviceInfo.innerWidth =\n      typeof window !== 'undefined'\n        ? window.innerWidth\n        : 'Server Side Rendering Requires the analytics function to handle window dimensions';\n\n    const currURL =\n      typeof window !== 'undefined'\n        ? window.location.href\n        : 'Server Side Rendering Requires the analytics function to handle window URL';\n\n    context.analyticsFunction(\n      componentType,\n      eventType,\n      eventArgs,\n      dateTime,\n      deviceInfo,\n      currURL,\n      props,\n    );\n  };\n};\n"],"names":[],"sourceRoot":""}